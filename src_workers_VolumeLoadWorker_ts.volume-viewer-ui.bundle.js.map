{"version":3,"file":"src_workers_VolumeLoadWorker_ts.volume-viewer-ui.bundle.js","mappings":"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,UAAU,CAAC;IACpDC,aAAa,EAAE,IAAIP,0CAAO,CAAC,CAAC,CAACwyB,IAAI,CAACjxB,SAAS,CAAChB,aAAa,CAAC;IAC1DC,eAAe,EAAE,IAAIR,0CAAO,CAAC,CAAC,CAACwyB,IAAI,CAACjxB,SAAS,CAACf,eAAe,CAAC;IAC9DC,iBAAiB,EAAE,IAAIT,0CAAO,CAAC,CAAC,CAACwyB,IAAI,CAACjxB,SAAS,CAACd,iBAAiB,CAAC;IAClEU,SAAS,EAAE;MACTC,WAAW,EAAE,IAAIpB,0CAAO,CAAC,CAAC,CAACwyB,IAAI,CAACjxB,SAAS,CAACJ,SAAS,CAACC,WAAW,CAAC;MAChEC,QAAQ,EAAE,IAAIrB,0CAAO,CAAC,CAAC,CAACwyB,IAAI,CAACjxB,SAAS,CAACJ,SAAS,CAACE,QAAQ;IAC3D;EAAC;AAEL;;;;;;;;;;AC3BA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WClCA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WClBA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;UENA;UACA","sources":["webpack://@aics/volume-viewer/./src/Channel.ts","webpack://@aics/volume-viewer/./src/Histogram.ts","webpack://@aics/volume-viewer/./src/Volume.ts","webpack://@aics/volume-viewer/./src/VolumeCache.ts","webpack://@aics/volume-viewer/./src/constants/colors.ts","webpack://@aics/volume-viewer/./src/loaders/IVolumeLoader.ts","webpack://@aics/volume-viewer/./src/loaders/JsonImageInfoLoader.ts","webpack://@aics/volume-viewer/./src/loaders/OmeZarrLoader.ts","webpack://@aics/volume-viewer/./src/loaders/TiffLoader.ts","webpack://@aics/volume-viewer/./src/loaders/VolumeLoaderUtils.ts","webpack://@aics/volume-viewer/./src/loaders/index.ts","webpack://@aics/volume-viewer/./src/loaders/zarr_utils/ChunkPrefetchIterator.ts","webpack://@aics/volume-viewer/./src/loaders/zarr_utils/WrappedStore.ts","webpack://@aics/volume-viewer/./src/loaders/zarr_utils/types.ts","webpack://@aics/volume-viewer/./src/loaders/zarr_utils/utils.ts","webpack://@aics/volume-viewer/./src/utils/RequestQueue.ts","webpack://@aics/volume-viewer/./src/utils/SubscribableRequestQueue.ts","webpack://@aics/volume-viewer/./src/workers/VolumeLoadWorker.ts","webpack://@aics/volume-viewer/./src/workers/types.ts","webpack://@aics/volume-viewer/./src/workers/util.ts","webpack://@aics/volume-viewer/ignored|/home/runner/work/volume-viewer/volume-viewer/node_modules/geotiff/dist-module/source/client|http","webpack://@aics/volume-viewer/ignored|/home/runner/work/volume-viewer/volume-viewer/node_modules/geotiff/dist-module/source/client|https","webpack://@aics/volume-viewer/ignored|/home/runner/work/volume-viewer/volume-viewer/node_modules/geotiff/dist-module/source/client|url","webpack://@aics/volume-viewer/ignored|/home/runner/work/volume-viewer/volume-viewer/node_modules/geotiff/dist-module/source|fs","webpack://@aics/volume-viewer/webpack/bootstrap","webpack://@aics/volume-viewer/webpack/runtime/chunk loaded","webpack://@aics/volume-viewer/webpack/runtime/compat get default export","webpack://@aics/volume-viewer/webpack/runtime/define property getters","webpack://@aics/volume-viewer/webpack/runtime/ensure chunk","webpack://@aics/volume-viewer/webpack/runtime/get javascript chunk filename","webpack://@aics/volume-viewer/webpack/runtime/global","webpack://@aics/volume-viewer/webpack/runtime/hasOwnProperty shorthand","webpack://@aics/volume-viewer/webpack/runtime/make namespace object","webpack://@aics/volume-viewer/webpack/runtime/publicPath","webpack://@aics/volume-viewer/webpack/runtime/importScripts chunk loading","webpack://@aics/volume-viewer/webpack/runtime/startup chunk dependencies","webpack://@aics/volume-viewer/webpack/before-startup","webpack://@aics/volume-viewer/webpack/startup","webpack://@aics/volume-viewer/webpack/after-startup"],"sourcesContent":["import { DataTexture, RedFormat, UnsignedByteType, RGBAFormat, LinearFilter, NearestFilter } from \"three\";\nimport Histogram, { LUT_ARRAY_LENGTH } from \"./Histogram.js\";\n\ninterface ChannelImageData {\n  /** Returns the one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255. */\n  readonly data: Uint8ClampedArray;\n  /** Returns the actual dimensions of the data in the ImageData object, in pixels. */\n  readonly height: number;\n  /** Returns the actual dimensions of the data in the ImageData object, in pixels. */\n  readonly width: number;\n}\n\n// Data and processing for a single channel\nexport default class Channel {\n  public loaded: boolean;\n  public imgData: ChannelImageData;\n  public volumeData: Uint8Array;\n  public name: string;\n  public histogram: Histogram;\n  public lut: Uint8Array;\n  public colorPalette: Uint8Array;\n  public colorPaletteAlpha: number;\n  public dims: [number, number, number];\n  public dataTexture: DataTexture;\n  public lutTexture: DataTexture;\n\n  constructor(name: string) {\n    this.loaded = false;\n    this.imgData = { data: new Uint8ClampedArray(), width: 0, height: 0 };\n\n    // on gpu\n    this.dataTexture = new DataTexture(new Uint8Array(), 0, 0);\n    this.lutTexture = new DataTexture(new Uint8Array(LUT_ARRAY_LENGTH), 256, 1, RGBAFormat, UnsignedByteType);\n    this.lutTexture.minFilter = this.lutTexture.magFilter = LinearFilter;\n    this.lutTexture.generateMipmaps = false;\n\n    this.volumeData = new Uint8Array();\n    this.name = name;\n    this.histogram = new Histogram(new Uint8Array());\n    this.dims = [0, 0, 0];\n\n    // intensity remapping lookup table\n    this.lut = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n    // per-intensity color labeling (disabled initially)\n    this.colorPalette = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n    // store in 0..1 range. 1 means fully colorPalette, 0 means fully lut.\n    this.colorPaletteAlpha = 0.0;\n  }\n\n  // rgbColor is [0..255, 0..255, 0..255]\n  public combineLuts(rgbColor: [number, number, number] | number, out?: Uint8Array): Uint8Array {\n    const ret = out ? out : new Uint8Array(LUT_ARRAY_LENGTH);\n    if (!rgbColor) {\n      return ret;\n    }\n    const rgb = [rgbColor[0] / 255.0, rgbColor[1] / 255.0, rgbColor[2] / 255.0];\n    // colorPalette*alpha + rgb*lut*(1-alpha)\n    // a tiny bit faster for the edge cases\n    if (this.colorPaletteAlpha === 1.0) {\n      ret.set(this.colorPalette);\n    } else if (this.colorPaletteAlpha === 0.0) {\n      ret.set(this.lut);\n      for (let i = 0; i < LUT_ARRAY_LENGTH / 4; ++i) {\n        ret[i * 4 + 0] *= rgb[0];\n        ret[i * 4 + 1] *= rgb[1];\n        ret[i * 4 + 2] *= rgb[2];\n      }\n    } else {\n      for (let i = 0; i < LUT_ARRAY_LENGTH / 4; ++i) {\n        ret[i * 4 + 0] =\n          this.colorPalette[i * 4 + 0] * this.colorPaletteAlpha +\n          this.lut[i * 4 + 0] * (1.0 - this.colorPaletteAlpha) * rgb[0];\n        ret[i * 4 + 1] =\n          this.colorPalette[i * 4 + 1] * this.colorPaletteAlpha +\n          this.lut[i * 4 + 1] * (1.0 - this.colorPaletteAlpha) * rgb[1];\n        ret[i * 4 + 2] =\n          this.colorPalette[i * 4 + 2] * this.colorPaletteAlpha +\n          this.lut[i * 4 + 2] * (1.0 - this.colorPaletteAlpha) * rgb[2];\n        ret[i * 4 + 3] =\n          this.colorPalette[i * 4 + 3] * this.colorPaletteAlpha + this.lut[i * 4 + 3] * (1.0 - this.colorPaletteAlpha);\n      }\n    }\n\n    this.lutTexture.image.data.set(ret);\n    this.lutTexture.needsUpdate = true;\n\n    return ret;\n  }\n\n  public getHistogram(): Histogram {\n    return this.histogram;\n  }\n\n  public getIntensity(x: number, y: number, z: number): number {\n    return this.volumeData[x + y * this.dims[0] + z * (this.dims[0] * this.dims[1])];\n  }\n\n  // how to index into tiled texture atlas\n  public getIntensityFromAtlas(x: number, y: number, z: number): number {\n    const numXtiles = this.imgData.width / this.dims[0];\n    const tilex = z % numXtiles;\n    const tiley = Math.floor(z / numXtiles);\n    const offset = tilex * this.dims[0] + x + (tiley * this.dims[1] + y) * this.imgData.width;\n    return this.imgData.data[offset];\n  }\n\n  private rebuildDataTexture(data: Uint8ClampedArray, w: number, h: number): void {\n    if (this.dataTexture) {\n      this.dataTexture.dispose();\n    }\n    this.dataTexture = new DataTexture(data, w, h);\n    this.dataTexture.format = RedFormat;\n    this.dataTexture.type = UnsignedByteType;\n    this.dataTexture.magFilter = NearestFilter;\n    this.dataTexture.minFilter = NearestFilter;\n    this.dataTexture.generateMipmaps = false;\n    this.dataTexture.needsUpdate = true;\n  }\n\n  // give the channel fresh data and initialize from that data\n  // data is formatted as a texture atlas where each tile is a z slice of the volume\n  public setBits(bitsArray: Uint8Array, w: number, h: number): void {\n    this.imgData = { data: new Uint8ClampedArray(bitsArray.buffer), width: w, height: h };\n\n    this.rebuildDataTexture(this.imgData.data, w, h);\n\n    this.loaded = true;\n    this.histogram = new Histogram(bitsArray);\n\n    this.lutGenerator_auto2();\n  }\n\n  // let's rearrange this.imgData.data into a 3d array.\n  // it is assumed to be coming in as a flat Uint8Array of size x*y*z\n  // with x*y*z layout (first row of first plane is the first data in the layout,\n  // then second row of first plane, etc)\n  public unpackVolumeFromAtlas(x: number, y: number, z: number): void {\n    const volimgdata = this.imgData.data;\n\n    this.dims = [x, y, z];\n    this.volumeData = new Uint8Array(x * y * z);\n\n    const numXtiles = this.imgData.width / x;\n    const atlasrow = this.imgData.width;\n    let tilex = 0,\n      tiley = 0,\n      tileoffset = 0,\n      tilerowoffset = 0;\n    for (let i = 0; i < z; ++i) {\n      // tile offset\n      tilex = i % numXtiles;\n      tiley = Math.floor(i / numXtiles);\n      tileoffset = tilex * x + tiley * y * atlasrow;\n      for (let j = 0; j < y; ++j) {\n        tilerowoffset = j * atlasrow;\n        for (let k = 0; k < x; ++k) {\n          this.volumeData[i * (x * y) + j * x + k] = volimgdata[tileoffset + tilerowoffset + k];\n        }\n      }\n    }\n  }\n\n  // give the channel fresh volume data and initialize from that data\n  public setFromVolumeData(bitsArray: Uint8Array, vx: number, vy: number, vz: number, ax: number, ay: number): void {\n    this.dims = [vx, vy, vz];\n    this.volumeData = bitsArray;\n    // TODO FIXME performance hit for shuffling the data and storing 2 versions of it (could do this in worker at least?)\n    this.packToAtlas(vx, vy, vz, ax, ay);\n    this.loaded = true;\n    this.histogram = new Histogram(this.volumeData);\n    this.lutGenerator_auto2();\n  }\n\n  // given this.volumeData, let's unpack it into a flat textureatlas and fill up this.imgData.\n  private packToAtlas(vx: number, vy: number, vz: number, ax: number, ay: number): void {\n    // big assumptions:\n    // atlassize is a perfect multiple of volumesize in both x and y\n    // ax % vx == 0\n    // ay % vy == 0\n    // and num slices <= num possible slices in atlas.\n    // (ax/vx) * (ay/vy) >= vz\n    if (ax % vx !== 0 || ay % vy !== 0 || (ax / vx) * (ay / vy) < vz) {\n      console.log(\"ERROR - atlas and volume dims are inconsistent\");\n      console.log(ax, ay, vx, vy, vz);\n    }\n\n    this.imgData = {\n      width: ax,\n      height: ay,\n      data: new Uint8ClampedArray(ax * ay),\n    };\n    this.imgData.data.fill(0);\n\n    // deposit slices one by one into the imgData.data from volData.\n    const volimgdata = this.imgData.data;\n\n    const x = vx,\n      y = vy,\n      z = vz;\n\n    const numXtiles = this.imgData.width / x;\n    const atlasrow = this.imgData.width;\n    let tilex = 0,\n      tiley = 0,\n      tileoffset = 0,\n      tilerowoffset = 0;\n    for (let i = 0; i < z; ++i) {\n      // tile offset\n      tilex = i % numXtiles;\n      tiley = Math.floor(i / numXtiles);\n      tileoffset = tilex * x + tiley * y * atlasrow;\n      for (let j = 0; j < y; ++j) {\n        tilerowoffset = j * atlasrow;\n        for (let k = 0; k < x; ++k) {\n          volimgdata[tileoffset + tilerowoffset + k] = this.volumeData[i * (x * y) + j * x + k];\n        }\n      }\n    }\n\n    this.rebuildDataTexture(this.imgData.data, ax, ay);\n  }\n\n  // lut should be an uint8array of 256*4 elements (256 rgba8 values)\n  public setLut(lut: Uint8Array): void {\n    this.lut = lut;\n  }\n\n  // palette should be an uint8array of 256*4 elements (256 rgba8 values)\n  public setColorPalette(palette: Uint8Array): void {\n    this.colorPalette = palette;\n  }\n\n  public setColorPaletteAlpha(alpha: number): void {\n    this.colorPaletteAlpha = alpha;\n  }\n\n  /* eslint-disable @typescript-eslint/naming-convention */\n  public lutGenerator_windowLevel(wnd: number, lvl: number): void {\n    if (!this.loaded) {\n      return;\n    }\n    const lut = this.histogram.lutGenerator_windowLevel(wnd, lvl);\n    this.setLut(lut.lut);\n  }\n\n  public lutGenerator_fullRange(): void {\n    if (!this.loaded) {\n      return;\n    }\n    const lut = this.histogram.lutGenerator_fullRange();\n    this.setLut(lut.lut);\n  }\n\n  public lutGenerator_dataRange(): void {\n    if (!this.loaded) {\n      return;\n    }\n    const lut = this.histogram.lutGenerator_dataRange();\n    this.setLut(lut.lut);\n  }\n\n  public lutGenerator_bestFit(): void {\n    if (!this.loaded) {\n      return;\n    }\n    const lut = this.histogram.lutGenerator_bestFit();\n    this.setLut(lut.lut);\n  }\n\n  // attempt to redo imagej's Auto\n  public lutGenerator_auto2(): void {\n    if (!this.loaded) {\n      return;\n    }\n    const lut = this.histogram.lutGenerator_auto2();\n    this.setLut(lut.lut);\n  }\n\n  public lutGenerator_auto(): void {\n    if (!this.loaded) {\n      return;\n    }\n    const lut = this.histogram.lutGenerator_auto();\n    this.setLut(lut.lut);\n  }\n\n  public lutGenerator_equalize(): void {\n    if (!this.loaded) {\n      return;\n    }\n    const lut = this.histogram.lutGenerator_equalize();\n    this.setLut(lut.lut);\n  }\n\n  public lutGenerator_percentiles(lo: number, hi: number): void {\n    if (!this.loaded) {\n      return;\n    }\n    const lut = this.histogram.lutGenerator_percentiles(lo, hi);\n    this.setLut(lut.lut);\n  }\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n","import { getColorByChannelIndex } from \"./constants/colors.js\";\n\nfunction clamp(val: number, cmin: number, cmax: number): number {\n  return Math.min(Math.max(cmin, val), cmax);\n}\n\nfunction controlPointToRGBA(controlPoint) {\n  return [controlPoint.color[0], controlPoint.color[1], controlPoint.color[2], Math.floor(controlPoint.opacity * 255)];\n}\n\nfunction lerp(xmin, xmax, a) {\n  return a * (xmax - xmin) + xmin;\n}\n\nconst LUT_ENTRIES = 256;\nconst LUT_ARRAY_LENGTH = LUT_ENTRIES * 4;\n\n/**\n * @typedef {Object} ControlPoint Used for the TF (transfer function) editor GUI.\n * Need to be converted to LUT for rendering.\n * @property {number} x The X Coordinate\n * @property {number} opacity The Opacity, from 0 to 1\n * @property {Array.<number>} color The Color, 3 numbers from 0-255 for r,g,b\n */\n\n/**\n * @typedef {Object} Lut Used for rendering.\n * @property {Array.<number>} lut LUT_ARRAY_LENGTH element lookup table as array\n * (maps scalar intensity to a rgb color plus alpha, with each value from 0-255)\n * @property {Array.<ControlPoint>} controlPoints\n */\nexport type ControlPoint = {\n  x: number;\n  opacity: number;\n  color: [number, number, number];\n};\nexport type Lut = {\n  lut: Uint8Array;\n  controlPoints: ControlPoint[];\n};\n\n/**\n * Builds a histogram with 256 bins from a data array. Assume data is 8 bit single channel grayscale.\n * @class\n * @param {Array.<number>} data\n */\nexport default class Histogram {\n  private bins: Uint32Array;\n  private dataMin: number;\n  private dataMax: number;\n  private nonzeroPixelCount: number;\n  public maxBin: number;\n\n  constructor(data: Uint8Array) {\n    // no more than 2^32 pixels of any one intensity in the data!?!?!\n    this.bins = new Uint32Array(256);\n    this.bins.fill(0);\n    this.dataMin = 255;\n    this.dataMax = 0;\n    this.maxBin = 0;\n\n    // build up the histogram\n    for (let i = 0; i < data.length; ++i) {\n      this.bins[data[i]]++;\n    }\n    // track the first and last nonzero bins with at least 1 sample\n    for (let i = 1; i < this.bins.length; i++) {\n      if (this.bins[i] > 0) {\n        this.dataMin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 1; i--) {\n      if (this.bins[i] > 0) {\n        this.dataMax = i;\n        break;\n      }\n    }\n\n    // total number of pixels minus the number of zero pixels\n    this.nonzeroPixelCount = data.length - this.bins[0];\n\n    // get the bin with the most frequently occurring NONZERO value\n    this.maxBin = 1;\n    let max = this.bins[1];\n    for (let i = 1; i < this.bins.length; i++) {\n      if (this.bins[i] > max) {\n        this.maxBin = i;\n        max = this.bins[i];\n      }\n    }\n  }\n\n  /**\n   * Return the min data value\n   * @return {number}\n   */\n  getMin(): number {\n    return this.dataMin;\n  }\n\n  /**\n   * Return the max data value\n   * @return {number}\n   */\n  getMax(): number {\n    return this.dataMax;\n  }\n\n  /* eslint-disable @typescript-eslint/naming-convention */\n\n  /**\n   * Generate a Window/level lookup table\n   * @return {Lut}\n   * @param {number} wnd in 0..1 range\n   * @param {number} lvl in 0..1 range\n   */\n  lutGenerator_windowLevel(wnd: number, lvl: number): Lut {\n    // simple linear mapping for actual range\n    const b = lvl - wnd * 0.5;\n    const e = lvl + wnd * 0.5;\n    return this.lutGenerator_minMax(b * 255, e * 255);\n  }\n\n  /**\n   * Generate a piecewise linear lookup table that ramps up from 0 to 1 over the b to e domain.\n   * If e === b, then we use a step function with f(b) = 0 and f(b + 1) = 1\n   *  |\n   * 1|               +---------+-----\n   *  |              /\n   *  |             /\n   *  |            /\n   *  |           /\n   *  |          /\n   * 0+=========+---------------+-----\n   *  0         b    e         255\n   * @return {Lut}\n   * @param {number} b\n   * @param {number} e\n   */\n  lutGenerator_minMax(b: number, e: number): Lut {\n    if (e < b) {\n      // swap\n      const tmp = e;\n      e = b;\n      b = tmp;\n    }\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH);\n    for (let x = 0; x < lut.length / 4; ++x) {\n      lut[x * 4 + 0] = 255;\n      lut[x * 4 + 1] = 255;\n      lut[x * 4 + 2] = 255;\n      if (x > e) {\n        lut[x * 4 + 3] = 255;\n      } else if (x <= b) {\n        lut[x * 4 + 3] = 0;\n      } else {\n        if (e === b) {\n          lut[x * 4 + 3] = 255;\n        } else {\n          const a = (x - b) / (e - b);\n          lut[x * 4 + 3] = lerp(0, 255, a);\n        }\n      }\n    }\n\n    // Edge case: b and e are both out of bounds\n    if (b < 0 && e < 0) {\n      return {\n        lut: lut,\n        controlPoints: [\n          { x: 0, opacity: 1, color: [255, 255, 255] },\n          { x: 255, opacity: 1, color: [255, 255, 255] },\n        ],\n      };\n    }\n    if (b >= 255 && e >= 255) {\n      return {\n        lut: lut,\n        controlPoints: [\n          { x: 0, opacity: 0, color: [255, 255, 255] },\n          { x: 255, opacity: 0, color: [255, 255, 255] },\n        ],\n      };\n    }\n\n    // Generate 2 to 4 control points for a minMax LUT, from left to right\n    const controlPoints: ControlPoint[] = [];\n\n    // Add starting point at x = 0\n    let startVal = 0;\n    if (b < 0) {\n      startVal = -b / (e - b);\n    }\n    controlPoints.push({ x: 0, opacity: startVal, color: [255, 255, 255] });\n\n    // If b > 0, add another point at (b, 0)\n    if (b > 0) {\n      controlPoints.push({ x: b, opacity: 0, color: [255, 255, 255] });\n    }\n\n    // If e < 255, Add another point at (e, 1)\n    if (e < 255) {\n      if (e === b) {\n        // Use b + 0.5 as x value instead of e to create a near-vertical ramp\n        controlPoints.push({ x: b + 0.5, opacity: 1, color: [255, 255, 255] });\n      } else {\n        controlPoints.push({ x: e, opacity: 1, color: [255, 255, 255] });\n      }\n    }\n\n    // Add ending point at x = 255\n    let endVal = 1;\n    if (e > 255) {\n      endVal = (255 - b) / (e - b);\n    }\n    controlPoints.push({ x: 255, opacity: endVal, color: [255, 255, 255] });\n\n    return {\n      lut: lut,\n      controlPoints: controlPoints,\n    };\n  }\n\n  /**\n   * Generate a straight 0-1 linear identity lookup table\n   * @return {Lut}\n   */\n  lutGenerator_fullRange(): Lut {\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH);\n\n    // simple linear mapping for actual range\n    for (let x = 0; x < lut.length / 4; ++x) {\n      lut[x * 4 + 0] = 255;\n      lut[x * 4 + 1] = 255;\n      lut[x * 4 + 2] = 255;\n      lut[x * 4 + 3] = x;\n    }\n\n    return {\n      lut: lut,\n      controlPoints: [\n        { x: 0, opacity: 0, color: [255, 255, 255] },\n        { x: 255, opacity: 1, color: [255, 255, 255] },\n      ],\n    };\n  }\n\n  /**\n   * Generate a lookup table over the min to max range of the data values\n   * @return {Lut}\n   */\n  lutGenerator_dataRange(): Lut {\n    // simple linear mapping for actual range\n    const b = this.dataMin;\n    const e = this.dataMax;\n    return this.lutGenerator_minMax(b, e);\n  }\n\n  /**\n   * Generate a lookup table with a different color per intensity value\n   * @return {Lut}\n   */\n  lutGenerator_labelColors(): Lut {\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n    // TODO specify type for control point\n    const controlPoints: ControlPoint[] = [];\n    controlPoints.push({ x: 0, opacity: 0, color: [0, 0, 0] });\n    let lastr = 0;\n    let lastg = 0;\n    let lastb = 0;\n    let lasta = 0;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n\n    // assumes exactly one bin per intensity value?\n    // skip zero!!!\n    for (let i = 1; i < this.bins.length; ++i) {\n      if (this.bins[i] > 0) {\n        const rgb = getColorByChannelIndex(i);\n\n        lut[i * 4 + 0] = rgb[0];\n        lut[i * 4 + 1] = rgb[1];\n        lut[i * 4 + 2] = rgb[2];\n        lut[i * 4 + 3] = 255;\n\n        r = rgb[0];\n        g = rgb[1];\n        b = rgb[2];\n        a = 1;\n      } else {\n        // add a zero control point?\n        r = 0;\n        g = 0;\n        b = 0;\n        a = 0;\n      }\n      // if current control point is same as last one don't add it\n      if (r !== lastr || g !== lastg || b !== lastb || a !== lasta) {\n        if (lasta === 0) {\n          controlPoints.push({ x: i - 0.5, opacity: lasta, color: [lastr, lastg, lastb] });\n        }\n        controlPoints.push({ x: i, opacity: a, color: [r, g, b] });\n        lastr = r;\n        lastg = g;\n        lastb = b;\n        lasta = a;\n      }\n    }\n\n    return {\n      lut: lut,\n      controlPoints: controlPoints,\n    };\n  }\n\n  /**\n   * Find the bin that contains the percentage of pixels below it\n   * @return {number}\n   * @param {number} pct\n   */\n  findBinOfPercentile(pct: number): number {\n    const pixcount = this.nonzeroPixelCount + this.bins[0];\n    const limit = pixcount * pct;\n\n    let i = 0;\n    let count = 0;\n    for (i = 0; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    return i;\n  }\n\n  /**\n   * Generate a lookup table based on histogram percentiles\n   * @return {Lut}\n   * @param {number} pmin\n   * @param {number} pmax\n   */\n  lutGenerator_percentiles(pmin: number, pmax: number): Lut {\n    // e.g. 0.50, 0.983 starts from 50th percentile bucket and ends at 98.3 percentile bucket.\n    const hmin = this.findBinOfPercentile(pmin);\n    const hmax = this.findBinOfPercentile(pmax);\n\n    return this.lutGenerator_minMax(hmin, hmax);\n  }\n\n  /**\n   * Generate a 10% / 90% lookup table\n   * @return {Lut}\n   */\n  lutGenerator_bestFit(): Lut {\n    const pixcount = this.nonzeroPixelCount;\n    //const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n\n    let i = 0;\n    let count = 0;\n    for (i = 1; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmin = i;\n\n    count = 0;\n    for (i = this.bins.length - 1; i >= 1; --i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmax = i;\n\n    return this.lutGenerator_minMax(hmin, hmax);\n  }\n\n  /**\n   * Generate a lookup table attempting to replicate ImageJ's \"Auto\" button\n   * @return {Lut}\n   */\n  lutGenerator_auto2(): Lut {\n    const AUTO_THRESHOLD = 5000;\n    const pixcount = this.nonzeroPixelCount;\n    //  const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n    const threshold = pixcount / AUTO_THRESHOLD;\n\n    // this will skip the \"zero\" bin which contains pixels of zero intensity.\n    let hmin = this.bins.length - 1;\n    let hmax = 1;\n    for (let i = 1; i < this.bins.length; ++i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 1; --i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmax = i;\n        break;\n      }\n    }\n\n    if (hmax < hmin) {\n      // just reset to whole range in this case.\n      return this.lutGenerator_fullRange();\n    } else {\n      return this.lutGenerator_minMax(hmin, hmax);\n    }\n  }\n\n  /**\n   * Generate a lookup table using a percentile of the most commonly occurring value\n   * @return {Lut}\n   */\n  lutGenerator_auto(): Lut {\n    // simple linear mapping cutting elements with small appearence\n    // get 10% threshold\n    const PERCENTAGE = 0.1;\n    const th = Math.floor(this.bins[this.maxBin] * PERCENTAGE);\n    let b = 0;\n    let e = this.bins.length - 1;\n    for (let x = 1; x < this.bins.length; ++x) {\n      if (this.bins[x] > th) {\n        b = x;\n        break;\n      }\n    }\n    for (let x = this.bins.length - 1; x >= 1; --x) {\n      if (this.bins[x] > th) {\n        e = x;\n        break;\n      }\n    }\n\n    return this.lutGenerator_minMax(b, e);\n  }\n\n  /**\n   * Generate an \"equalized\" lookup table\n   * @return {Lut}\n   */\n  lutGenerator_equalize(): Lut {\n    const map: number[] = [];\n    for (let i = 0; i < this.bins.length; ++i) {\n      map[i] = 0;\n    }\n\n    // summed area table?\n    map[0] = this.bins[0];\n    for (let i = 1; i < this.bins.length; ++i) {\n      map[i] = map[i - 1] + this.bins[i];\n    }\n\n    const div = map[map.length - 1] - map[0];\n    if (div > 0) {\n      const lut = new Uint8Array(LUT_ARRAY_LENGTH);\n\n      // compute lut and track control points for the piecewise linear sections\n      const lutControlPoints: ControlPoint[] = [{ x: 0, opacity: 0, color: [255, 255, 255] }];\n      lut[0] = 255;\n      lut[1] = 255;\n      lut[2] = 255;\n      lut[3] = 0;\n      let slope = 0;\n      let lastSlope = 0;\n      let opacity = 0;\n      let lastOpacity = 0;\n      for (let i = 1; i < lut.length / 4; ++i) {\n        lut[i * 4 + 0] = 255;\n        lut[i * 4 + 1] = 255;\n        lut[i * 4 + 2] = 255;\n        lastOpacity = opacity;\n        opacity = clamp(Math.round(255 * (map[i] - map[0])), 0, 255);\n        lut[i * 4 + 3] = opacity;\n\n        slope = opacity - lastOpacity;\n        // if map[i]-map[i-1] is the same as map[i+1]-map[i] then we are in a linear segment and do not need a new control point\n        if (slope != lastSlope) {\n          lutControlPoints.push({ x: i - 1, opacity: lastOpacity / 255.0, color: [255, 255, 255] });\n          lastSlope = slope;\n        }\n      }\n\n      lutControlPoints.push({ x: 255, opacity: 1, color: [255, 255, 255] });\n\n      return {\n        lut: lut,\n        controlPoints: lutControlPoints,\n      };\n    } else {\n      // just reset to whole range in this case...?\n      return this.lutGenerator_fullRange();\n    }\n  }\n\n  // @param {Object[]} controlPoints - array of {x:number 0..255, opacity:number 0..1, color:array of 3 numbers 0..255}\n  // @return {Uint8Array} array of length 256*4 representing the rgba values of the gradient\n  lutGenerator_fromControlPoints(controlPoints: ControlPoint[]): Lut {\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n\n    if (controlPoints.length === 0) {\n      return { lut: lut, controlPoints: controlPoints };\n    }\n\n    // ensure they are sorted in ascending order of x\n    controlPoints.sort((a, b) => a.x - b.x);\n\n    // special case only one control point.\n    if (controlPoints.length === 1) {\n      const rgba = controlPointToRGBA(controlPoints[0]);\n      // copy val from x to 255.\n      for (let x = controlPoints[0].x; x < 256; ++x) {\n        lut[x * 4 + 0] = rgba[0];\n        lut[x * 4 + 1] = rgba[1];\n        lut[x * 4 + 2] = rgba[2];\n        lut[x * 4 + 3] = rgba[3];\n      }\n      return { lut: lut, controlPoints: controlPoints };\n    }\n\n    let c0 = controlPoints[0];\n    let c1 = controlPoints[1];\n    let color0 = controlPointToRGBA(c0);\n    let color1 = controlPointToRGBA(c1);\n    let lastIndex = 1;\n    let a = 0;\n    // if the first control point is after 0, act like there are 0s going all the way up to it.\n    // or lerp up to the first point?\n    for (let x = c0.x; x < 256; ++x) {\n      while (x > c1.x) {\n        // advance control points\n        c0 = c1;\n        color0 = color1;\n        lastIndex++;\n        if (lastIndex >= controlPoints.length) {\n          // if the last control point is before 255, then we want to continue its value all the way to 255.\n          c1 = { x: 255, color: c1.color, opacity: c1.opacity };\n        } else {\n          c1 = controlPoints[lastIndex];\n        }\n        color1 = controlPointToRGBA(c1);\n      }\n      if (c1.x === c0.x) {\n        // use c1\n        a = 1.0;\n      } else {\n        a = (x - c0.x) / (c1.x - c0.x);\n      }\n      // lerp the colors\n      lut[x * 4 + 0] = lerp(color0[0], color1[0], a);\n      lut[x * 4 + 1] = lerp(color0[1], color1[1], a);\n      lut[x * 4 + 2] = lerp(color0[2], color1[2], a);\n      lut[x * 4 + 3] = lerp(color0[3], color1[3], a);\n    }\n    return { lut: lut, controlPoints: controlPoints };\n  }\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport { LUT_ARRAY_LENGTH };\n","import { Vector2, Vector3 } from \"three\";\n\nimport Channel from \"./Channel.js\";\nimport Histogram from \"./Histogram.js\";\nimport { getColorByChannelIndex } from \"./constants/colors.js\";\nimport { type IVolumeLoader, LoadSpec, type PerChannelCallback } from \"./loaders/IVolumeLoader.js\";\nimport { estimateLevelForAtlas } from \"./loaders/VolumeLoaderUtils.js\";\n\nexport type ImageInfo = Readonly<{\n  name: string;\n\n  /** XY size of the *original* (not downsampled) volume, in pixels */\n  originalSize: Vector3;\n  /**\n   * XY dimensions of the texture atlas used by `RayMarchedAtlasVolume` and `Atlas2DSlice`, in number of z-slice\n   * tiles (not pixels). Chosen by the loader to lay out the 3D volume in the squarest possible 2D texture atlas.\n   */\n  atlasTileDims: Vector2;\n  /** Size of the volume, in pixels */\n  volumeSize: Vector3;\n  /** Size of the currently loaded subregion, in pixels */\n  subregionSize: Vector3;\n  /** Offset of the loaded subregion into the total volume, in pixels */\n  subregionOffset: Vector3;\n  /** Size of a single *original* (not downsampled) pixel, in spatial units */\n  physicalPixelSize: Vector3;\n  /** Symbol of physical spatial unit used by `pixelSize` */\n  spatialUnit: string;\n\n  /** Number of channels in the image */\n  numChannels: number;\n  /** The names of each channel */\n  channelNames: string[];\n  /** Optional overrides to default channel colors, in 0-255 range */\n  channelColors?: [number, number, number][];\n\n  /** Number of timesteps in the time series, or 1 if the image is not a time series */\n  times: number;\n  /** Size of each timestep in temporal units */\n  timeScale: number;\n  /** Symbol of temporal unit used by `timeScale`, e.g. \"hr\" */\n  timeUnit: string;\n\n  /** Number of scale levels available for this volume */\n  numMultiscaleLevels: number;\n  /** The scale level from which this image was loaded, between `0` and `numMultiscaleLevels-1` */\n  multiscaleLevel: number;\n\n  transform: {\n    /** Translation of the volume from the center of space, in volume voxels */\n    translation: Vector3;\n    /** Rotation of the volume in Euler angles, applied in XYZ order */\n    rotation: Vector3;\n  };\n\n  /** Arbitrary additional metadata not captured by other `ImageInfo` properties */\n  userData?: Record<string, unknown>;\n}>;\n\nexport const getDefaultImageInfo = (): ImageInfo => ({\n  name: \"\",\n  originalSize: new Vector3(1, 1, 1),\n  atlasTileDims: new Vector2(1, 1),\n  volumeSize: new Vector3(1, 1, 1),\n  subregionSize: new Vector3(1, 1, 1),\n  subregionOffset: new Vector3(0, 0, 0),\n  physicalPixelSize: new Vector3(1, 1, 1),\n  spatialUnit: \"\",\n  numChannels: 0,\n  channelNames: [],\n  channelColors: [],\n  times: 1,\n  timeScale: 1,\n  timeUnit: \"\",\n  numMultiscaleLevels: 1,\n  multiscaleLevel: 0,\n  transform: {\n    translation: new Vector3(0, 0, 0),\n    rotation: new Vector3(0, 0, 0),\n  },\n});\n\ninterface VolumeDataObserver {\n  onVolumeData: (vol: Volume, batch: number[]) => void;\n  onVolumeChannelAdded: (vol: Volume, idx: number) => void;\n}\n\n/**\n * Provide dimensions of the volume data, including dimensions for texture atlas data in which the volume z slices\n * are tiled across a single large 2d image plane.\n * @typedef {Object} ImageInfo\n * @property {string} name Base name of image\n * @property {string} [version] Schema version preferably in semver format.\n * @property {Vector2} originalSize XY size of the *original* (not downsampled) volume, in pixels\n * @property {Vector2} atlasDims Number of rows and columns of z-slice tiles (not pixels) in the texture atlas\n * @property {Vector3} volumeSize Size of the volume, in pixels\n * @property {Vector3} regionSize Size of the currently loaded subregion, in pixels\n * @property {Vector3} regionOffset Offset of the loaded subregion into the total volume, in pixels\n * @property {Vector3} pixelSize Size of a single *original* (not downsampled) pixel, in spatial units\n * @property {string} spatialUnit Symbol of physical spatial unit used by `pixelSize`\n * @property {number} numChannels Number of channels\n * @property {Array.<string>} channelNames Names of each of the channels to be rendered, in order. Unique identifier expected\n * @property {Array.<Array.<number>>} [channelColors] Colors of each of the channels to be rendered, as an ordered list of [r, g, b] arrays\n * @property {number} times Number of times (default = 1)\n * @property {number} timeScale Size of each time step in `timeUnit` units\n * @property {number} timeUnit Unit symbol for `timeScale` (e.g. min)\n * @property {Object} transform translation and rotation as arrays of 3 numbers. Translation is in voxels (to be multiplied by pixel_size values). Rotation is Euler angles in radians, appled in XYZ order.\n * @property {Object} userData Arbitrary metadata not covered by above properties\n * @example const imgdata = {\n  \"name\": \"AICS-10_5_5\",\n  \"version\": \"0.0.0\",\n  originalSize: new Vector2(306, 494),\n  atlasDims: new Vector2(10, 7),\n  volumeSize: new Vector3(204, 292, 65),\n  regionSize: new Vector3(204, 292, 65),\n  regionOffset: new Vector3(0, 0, 0),\n  pixelSize: new Vector3(0.065, 0.065, 0.29),\n  spatialUnit: \"μm\",\n  \"numChannels\": 9,\n  \"channelNames\": [\"DRAQ5\", \"EGFP\", \"Hoechst 33258\", \"TL Brightfield\", \"SEG_STRUCT\", \"SEG_Memb\", \"SEG_DNA\", \"CON_Memb\", \"CON_DNA\"],\n  \"times\": 5,\n  \"timeScale\": 1,\n  \"timeUnit\": \"hr\",\n  \"transform\": {\n    \"translation\": new Vector3(5, 5, 1),\n    \"rotation\": new Vector3(0, 3.14159, 1.57),\n  },\n  };\n */\n\n/**\n * A renderable multichannel volume image with 8-bits per channel intensity values.\n * @class\n * @param {ImageInfo} imageInfo\n */\nexport default class Volume {\n  public imageInfo: ImageInfo;\n  public loadSpec: Required<LoadSpec>;\n  public loader?: IVolumeLoader;\n  // `LoadSpec` representing the minimum data required to display what's in the viewer (subregion, channels, etc.).\n  // Used to intelligently issue load requests whenever required by a state change. Modify with `updateRequiredData`.\n  public loadSpecRequired: Required<LoadSpec>;\n  public channelLoadCallback?: PerChannelCallback;\n  public imageMetadata: Record<string, unknown>;\n  public name: string;\n\n  public channels: Channel[];\n  public numChannels: number;\n  public channelNames: string[];\n  public channelColorsDefault: [number, number, number][];\n\n  public physicalScale: number;\n  public physicalPixelSize: Vector3;\n  public physicalSize: Vector3;\n  public normPhysicalSize: Vector3;\n  public normRegionSize: Vector3;\n  public normRegionOffset: Vector3;\n  public physicalUnitSymbol: string;\n  public tickMarkPhysicalLength: number;\n\n  private volumeDataObservers: VolumeDataObserver[];\n  private loaded: boolean;\n\n  constructor(\n    imageInfo: ImageInfo = getDefaultImageInfo(),\n    loadSpec: LoadSpec = new LoadSpec(),\n    loader?: IVolumeLoader\n  ) {\n    this.loaded = false;\n    this.imageInfo = imageInfo;\n    this.name = this.imageInfo.name;\n    this.loadSpec = {\n      // Fill in defaults for optional properties\n      multiscaleLevel: 0,\n      channels: Array.from({ length: this.imageInfo.numChannels }, (_val, idx) => idx),\n      ...loadSpec,\n    };\n    this.loadSpecRequired = {\n      ...this.loadSpec,\n      channels: this.loadSpec.channels.slice(),\n      subregion: this.loadSpec.subregion.clone(),\n    };\n    this.loader = loader;\n    // imageMetadata to be filled in by Volume Loaders\n    this.imageMetadata = {};\n\n    this.normRegionSize = new Vector3(1, 1, 1);\n    this.normRegionOffset = new Vector3(0, 0, 0);\n    this.physicalSize = new Vector3(1, 1, 1);\n    this.physicalScale = 1;\n    this.normPhysicalSize = new Vector3(1, 1, 1);\n    this.physicalPixelSize = this.imageInfo.physicalPixelSize;\n    this.tickMarkPhysicalLength = 1;\n    this.setVoxelSize(this.physicalPixelSize);\n\n    this.numChannels = this.imageInfo.numChannels;\n    this.channelNames = this.imageInfo.channelNames.slice();\n    this.channelColorsDefault = this.imageInfo.channelColors\n      ? this.imageInfo.channelColors.slice()\n      : this.channelNames.map((name, index) => getColorByChannelIndex(index));\n    // fill in gaps\n    if (this.channelColorsDefault.length < this.imageInfo.numChannels) {\n      for (let i = this.channelColorsDefault.length - 1; i < this.imageInfo.numChannels; ++i) {\n        this.channelColorsDefault[i] = getColorByChannelIndex(i);\n      }\n    }\n\n    this.channels = [];\n    for (let i = 0; i < this.imageInfo.numChannels; ++i) {\n      const channel = new Channel(this.channelNames[i]);\n      this.channels.push(channel);\n      // TODO pass in channel constructor...\n      channel.dims = this.imageInfo.subregionSize.toArray();\n    }\n\n    this.physicalUnitSymbol = this.imageInfo.spatialUnit;\n\n    this.volumeDataObservers = [];\n  }\n\n  private setUnloaded() {\n    this.loaded = false;\n    this.channels.forEach((channel) => {\n      channel.loaded = false;\n    });\n  }\n\n  isLoaded(): boolean {\n    return this.loaded;\n  }\n\n  updateDimensions() {\n    const { volumeSize, subregionSize, subregionOffset } = this.imageInfo;\n\n    this.setVoxelSize(this.physicalPixelSize);\n\n    this.normRegionSize = subregionSize.clone().divide(volumeSize);\n    this.normRegionOffset = subregionOffset.clone().divide(volumeSize);\n  }\n\n  /** Call on any state update that may require new data to be loaded (subregion, enabled channels, time, etc.) */\n  async updateRequiredData(required: Partial<LoadSpec>, onChannelLoaded?: PerChannelCallback): Promise<void> {\n    this.loadSpecRequired = { ...this.loadSpecRequired, ...required };\n    let noReload =\n      this.loadSpec.time === this.loadSpecRequired.time &&\n      this.loadSpec.subregion.containsBox(this.loadSpecRequired.subregion) &&\n      this.loadSpecRequired.channels.every((channel) => this.loadSpec.channels.includes(channel));\n\n    // An update to `subregion` should trigger a reload when the new subregion is not contained in the old one\n    // OR when the new subregion is smaller than the old one by enough that we can load a higher scale level.\n    if (noReload && !this.loadSpec.subregion.equals(this.loadSpecRequired.subregion)) {\n      const currentScale = this.imageInfo.multiscaleLevel;\n      // `LoadSpec.multiscaleLevel`, if specified, forces a cap on the scale level we can load.\n      const minLevel = this.loadSpec.multiscaleLevel ?? 0;\n      // Loaders should cache loaded dimensions so that this call blocks no more than once per valid `LoadSpec`.\n      const dims = await this.loader?.loadDims(this.loadSpecRequired);\n      if (dims) {\n        const loadableLevel = estimateLevelForAtlas(dims.map(({ shape }) => [shape[2], shape[3], shape[4]]));\n        noReload = currentScale <= Math.max(loadableLevel, minLevel);\n      }\n    }\n\n    // if newly required data is not currently contained in this volume...\n    if (!noReload) {\n      // ...clone `loadSpecRequired` into `loadSpec` and load\n      this.setUnloaded();\n      this.loadSpec = {\n        ...this.loadSpecRequired,\n        subregion: this.loadSpecRequired.subregion.clone(),\n        // preserve multiscale option from original `LoadSpec`, if any\n        multiscaleLevel: this.loadSpec.multiscaleLevel,\n      };\n      this.loader?.loadVolumeData(this, undefined, onChannelLoaded);\n    }\n  }\n\n  // we calculate the physical size of the volume (voxels*pixel_size)\n  // and then normalize to the max physical dimension\n  setVoxelSize(size: Vector3): void {\n    // only set the data if it is > 0.  zero is not an allowed value.\n    size.x = size.x > 0 ? size.x : 1.0;\n    size.y = size.y > 0 ? size.y : 1.0;\n    size.z = size.z > 0 ? size.z : 1.0;\n    this.physicalPixelSize = size;\n\n    this.physicalSize = this.imageInfo.originalSize.clone().multiply(this.physicalPixelSize);\n    // Volume is scaled such that its largest physical dimension is 1 world unit - save that dimension for conversions\n    this.physicalScale = Math.max(this.physicalSize.x, this.physicalSize.y, this.physicalSize.z);\n    // Compute the volume's max extent - scaled to max dimension.\n    this.normPhysicalSize = this.physicalSize.clone().divideScalar(this.physicalScale);\n    // While we're here, pick a power of 10 that divides into our max dimension a reasonable number of times\n    // and save it to be the length of tick marks in 3d.\n    this.tickMarkPhysicalLength = 10 ** Math.floor(Math.log10(this.physicalScale / 2));\n  }\n\n  setUnitSymbol(symbol: string): void {\n    this.physicalUnitSymbol = symbol;\n  }\n\n  /** Computes the center of the volume subset */\n  getContentCenter(): Vector3 {\n    // center point: (normRegionSize / 2 + normRegionOffset - 0.5) * normPhysicalSize;\n    return this.normRegionSize\n      .clone()\n      .divideScalar(2)\n      .add(this.normRegionOffset)\n      .subScalar(0.5)\n      .multiply(this.normPhysicalSize);\n  }\n\n  cleanup(): void {\n    // no op\n  }\n\n  getChannel(channelIndex: number): Channel {\n    return this.channels[channelIndex];\n  }\n\n  onChannelLoaded(batch: number[]): void {\n    // check to see if all channels are now loaded, and fire an event(?)\n    if (this.loadSpec.channels.every((channelIndex) => this.channels[channelIndex].loaded)) {\n      this.loaded = true;\n    }\n    batch.forEach((channelIndex) => this.channelLoadCallback?.(this, channelIndex));\n    this.volumeDataObservers.forEach((observer) => observer.onVolumeData(this, batch));\n  }\n\n  /**\n   * Assign volume data via a 2d array containing the z slices as tiles across it.  Assumes that the incoming data is consistent with the image's pre-existing imageInfo tile metadata.\n   * @param {number} channelIndex\n   * @param {Uint8Array} atlasdata\n   * @param {number} atlaswidth\n   * @param {number} atlasheight\n   */\n  setChannelDataFromAtlas(channelIndex: number, atlasdata: Uint8Array, atlaswidth: number, atlasheight: number): void {\n    this.channels[channelIndex].setBits(atlasdata, atlaswidth, atlasheight);\n    const { x, y, z } = this.imageInfo.subregionSize;\n    this.channels[channelIndex].unpackVolumeFromAtlas(x, y, z);\n    this.onChannelLoaded([channelIndex]);\n  }\n\n  // ASSUMES that this.channelData.options is already set and incoming data is consistent with it\n  /**\n   * Assign volume data as a 3d array ordered x,y,z. The xy size must be equal to tilewidth*tileheight from the imageInfo used to construct this Volume.  Assumes that the incoming data is consistent with the image's pre-existing imageInfo tile metadata.\n   * @param {number} channelIndex\n   * @param {Uint8Array} volumeData\n   */\n  setChannelDataFromVolume(channelIndex: number, volumeData: Uint8Array): void {\n    const { subregionSize, atlasTileDims } = this.imageInfo;\n    this.channels[channelIndex].setFromVolumeData(\n      volumeData,\n      subregionSize.x,\n      subregionSize.y,\n      subregionSize.z,\n      atlasTileDims.x * subregionSize.x,\n      atlasTileDims.y * subregionSize.y\n    );\n    this.onChannelLoaded([channelIndex]);\n  }\n\n  // TODO: decide if this should update imageInfo or not. For now, leave imageInfo alone as the \"original\" data\n  /**\n   * Add a new channel ready to receive data from one of the setChannelDataFrom* calls.\n   * Name and color will be defaulted if not provided. For now, leave imageInfo alone as the \"original\" data\n   * @param {string} name\n   * @param {Array.<number>} color [r,g,b]\n   */\n  appendEmptyChannel(name: string, color?: [number, number, number]): number {\n    const idx = this.imageInfo.numChannels;\n    const chname = name || \"channel_\" + idx;\n    const chcolor = color || getColorByChannelIndex(idx);\n    this.numChannels += 1;\n    this.channelNames.push(chname);\n    this.channelColorsDefault.push(chcolor);\n\n    this.channels.push(new Channel(chname));\n\n    for (let i = 0; i < this.volumeDataObservers.length; ++i) {\n      this.volumeDataObservers[i].onVolumeChannelAdded(this, idx);\n    }\n\n    return idx;\n  }\n\n  /**\n   * Get a value from the volume data\n   * @return {number} the intensity value from the given channel at the given xyz location\n   * @param {number} c The channel index\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  getIntensity(c: number, x: number, y: number, z: number): number {\n    return this.channels[c].getIntensity(x, y, z);\n  }\n\n  /**\n   * Get the 256-bin histogram for the given channel\n   * @return {Histogram} the histogram\n   * @param {number} c The channel index\n   */\n  getHistogram(c: number): Histogram {\n    return this.channels[c].getHistogram();\n  }\n\n  /**\n   * Set the lut for the given channel\n   * @param {number} c The channel index\n   * @param {Array.<number>} lut The lut as a 256 element array\n   */\n  setLut(c: number, lut: Uint8Array): void {\n    this.channels[c].setLut(lut);\n  }\n\n  /**\n   * Set the color palette for the given channel\n   * @param {number} c The channel index\n   * @param {Array.<number>} palette The colors as a 256 element array * RGBA\n   */\n  setColorPalette(c: number, palette: Uint8Array): void {\n    this.channels[c].setColorPalette(palette);\n  }\n\n  /**\n   * Set the color palette alpha multiplier for the given channel.\n   * This will blend between the ordinary color lut and this colorPalette lut.\n   * @param {number} c The channel index\n   * @param {number} alpha The alpha value as a number from 0 to 1\n   */\n  setColorPaletteAlpha(c: number, alpha: number): void {\n    this.channels[c].setColorPaletteAlpha(alpha);\n  }\n\n  /**\n   * Return the intrinsic rotation associated with this volume (radians)\n   * @return {Array.<number>} the xyz Euler angles (radians)\n   */\n  getRotation(): [number, number, number] {\n    // default axis order is XYZ\n    return this.imageInfo.transform.rotation.toArray();\n  }\n\n  /**\n   * Return the intrinsic translation (pivot center delta) associated with this volume, in normalized volume units\n   * @return {Array.<number>} the xyz translation in normalized volume units\n   */\n  getTranslation(): [number, number, number] {\n    return this.voxelsToWorldSpace(this.imageInfo.transform.translation.toArray());\n  }\n\n  /**\n   * Return a translation in normalized volume units, given a translation in image voxels\n   * @return {Array.<number>} the xyz translation in normalized volume units\n   */\n  voxelsToWorldSpace(xyz: [number, number, number]): [number, number, number] {\n    // ASSUME: translation is in original image voxels.\n    // account for pixel_size and normalized scaling in the threejs volume representation we're using\n    const m = 1.0 / Math.max(this.physicalSize.x, Math.max(this.physicalSize.y, this.physicalSize.z));\n    return new Vector3().fromArray(xyz).multiply(this.physicalPixelSize).multiplyScalar(m).toArray();\n  }\n\n  addVolumeDataObserver(o: VolumeDataObserver): void {\n    this.volumeDataObservers.push(o);\n  }\n\n  removeVolumeDataObserver(o: VolumeDataObserver): void {\n    if (o) {\n      const i = this.volumeDataObservers.indexOf(o);\n      if (i !== -1) {\n        this.volumeDataObservers.splice(i, 1);\n      }\n    }\n  }\n\n  removeAllVolumeDataObservers(): void {\n    this.volumeDataObservers = [];\n  }\n}\n","type MaybeCacheEntry = CacheEntry | null;\ntype CacheEntry = {\n  /** The data contained in this entry */\n  data: ArrayBuffer;\n  /** The previous entry in the LRU list (more recently used) */\n  prev: MaybeCacheEntry;\n  /** The next entry in the LRU list (less recently used) */\n  next: MaybeCacheEntry;\n  /** The key which indexes this entry */\n  key: string;\n};\n\n/** Default: 250MB. Should be large enough to be useful but safe for most any computer that can run the app */\nconst CACHE_MAX_SIZE_DEFAULT = 250_000_000;\n\nexport default class VolumeCache {\n  private entries: Map<string, CacheEntry>;\n\n  public readonly maxSize: number;\n  private currentSize: number;\n\n  // Ends of a linked list of entries, to track LRU and evict efficiently\n  private first: MaybeCacheEntry;\n  private last: MaybeCacheEntry;\n  // TODO implement some way to manage used vs unused (prefetched) entries so\n  // that prefetched entries which are never used don't get highest priority!\n\n  constructor(maxSize = CACHE_MAX_SIZE_DEFAULT) {\n    this.entries = new Map();\n    this.maxSize = maxSize;\n    this.currentSize = 0;\n\n    this.first = null;\n    this.last = null;\n  }\n\n  // Hide these behind getters so they're definitely never set from the outside\n  /** The size of all data arrays currently stored in this cache, in bytes. */\n  public get size() {\n    return this.currentSize;\n  }\n\n  /** The number of entries currently stored in this cache. */\n  public get numberOfEntries() {\n    return this.entries.size;\n  }\n\n  /**\n   * Removes an entry from a store but NOT the LRU list.\n   * Only call from a method with the word \"evict\" in it!\n   */\n  private removeEntryFromStore(entry: CacheEntry): void {\n    this.entries.delete(entry.key);\n    this.currentSize -= entry.data.byteLength;\n  }\n\n  /**\n   * Removes an entry from the LRU list but NOT its store.\n   * Entry must be replaced in list or removed from store, or it will never be evicted!\n   */\n  private removeEntryFromList(entry: CacheEntry): void {\n    const { prev, next } = entry;\n\n    if (prev) {\n      prev.next = next;\n    } else {\n      this.first = next;\n    }\n\n    if (next) {\n      next.prev = prev;\n    } else {\n      this.last = prev;\n    }\n  }\n\n  /** Adds an entry which is *not currently in the list* to the front of the list. */\n  private addEntryAsFirst(entry: CacheEntry): void {\n    if (this.first) {\n      this.first.prev = entry;\n    } else {\n      this.last = entry;\n    }\n    entry.next = this.first;\n    entry.prev = null;\n    this.first = entry;\n  }\n\n  /** Moves an entry which is *currently in the list* to the front of the list. */\n  private moveEntryToFirst(entry: CacheEntry): void {\n    if (entry === this.first) return;\n    this.removeEntryFromList(entry);\n    this.addEntryAsFirst(entry);\n  }\n\n  /** Evicts the least recently used entry from the cache. */\n  private evictLast(): void {\n    if (!this.last) {\n      console.error(\"VolumeCache: attempt to evict last entry from cache when no last entry is set\");\n      return;\n    }\n\n    this.removeEntryFromStore(this.last);\n\n    if (this.last.prev) {\n      this.last.prev.next = null;\n    }\n    this.last = this.last.prev;\n  }\n\n  /** Evicts a specific entry from the cache. */\n  private evict(entry: CacheEntry): void {\n    this.removeEntryFromStore(entry);\n    this.removeEntryFromList(entry);\n  }\n\n  /**\n   * Adds a new entry to the cache.\n   * @returns {boolean} a boolean indicating whether the insertion succeeded.\n   */\n  public insert(key: string, data: ArrayBuffer): boolean {\n    if (data.byteLength > this.maxSize) {\n      console.error(\"VolumeCache: attempt to insert a single entry larger than the cache\");\n      return false;\n    }\n\n    // Check if entry is already in cache\n    // This will move the entry to the front of the LRU list, if present\n    const getResult = this.getEntry(key);\n    if (getResult !== undefined) {\n      getResult.data = data;\n      return true;\n    }\n\n    // Add new entry to cache\n    const newEntry: CacheEntry = { data, prev: null, next: null, key };\n    this.addEntryAsFirst(newEntry);\n    this.entries.set(key, newEntry);\n    this.currentSize += data.byteLength;\n\n    // Evict until size is within limit\n    while (this.currentSize > this.maxSize) {\n      this.evictLast();\n    }\n    return true;\n  }\n\n  /** Internal implementation of `get`. Returns all entry metadata, not just the raw data. */\n  private getEntry(key: string): CacheEntry | undefined {\n    const result = this.entries.get(key);\n    if (result) {\n      this.moveEntryToFirst(result);\n    }\n    return result;\n  }\n\n  /** Attempts to get a single entry from the cache. */\n  public get(key: string): ArrayBuffer | undefined {\n    return this.getEntry(key)?.data;\n  }\n\n  /** Clears all cache entries whose keys begin with the specified prefix. */\n  public clearWithPrefix(prefix: string): void {\n    for (const [key, entry] of this.entries.entries()) {\n      if (key.startsWith(prefix)) {\n        this.evict(entry);\n      }\n    }\n  }\n\n  /** Clears all data from the cache. */\n  public clear(): void {\n    while (this.last) {\n      this.evictLast();\n    }\n  }\n}\n","export const defaultColors: [number, number, number][] = [\n  [255, 0, 255],\n  [255, 255, 255],\n  [0, 255, 255],\n];\n\ninterface HSVColor {\n  h: number;\n  s: number;\n  v: number;\n}\n// 0 <= (h, s, v) <= 1\n// returns 0 <= (r, g, b) <= 255 rounded to nearest integer\n// you can also pass in just one arg as an object of {h, s, v} props.\nfunction HSVtoRGB(h: number | HSVColor, s: number, v: number): [number, number, number] {\n  let r, g, b;\n  let hh = 0;\n  if (arguments.length === 1) {\n    const hsv = h as HSVColor;\n    (s = hsv.s), (v = hsv.v), (hh = hsv.h);\n  } else {\n    hh = h as number;\n  }\n  const i = Math.floor(hh * 6);\n  const f = hh * 6 - i;\n  const p = v * (1 - s);\n  const q = v * (1 - f * s);\n  const t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n    case 0:\n      (r = v), (g = t), (b = p);\n      break;\n    case 1:\n      (r = q), (g = v), (b = p);\n      break;\n    case 2:\n      (r = p), (g = v), (b = t);\n      break;\n    case 3:\n      (r = p), (g = q), (b = v);\n      break;\n    case 4:\n      (r = t), (g = p), (b = v);\n      break;\n    case 5:\n      (r = v), (g = p), (b = q);\n      break;\n  }\n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n\n// 1993 Park-Miller LCG\nfunction LCG(s) {\n  return function () {\n    s = Math.imul(48271, s) | 0 % 2147483647;\n    return (s & 2147483647) / 2147483648;\n  };\n}\n// Use it like so:\nconst myrand = LCG(123);\n\n// if index exceeds defaultColors start choosing random ones\n// returns [r,g,b] 0-255 range\nexport const getColorByChannelIndex = (index: number): [number, number, number] => {\n  if (!defaultColors[index]) {\n    defaultColors[index] = HSVtoRGB(myrand(), myrand() * 0.5 + 0.5, myrand() * 0.5 + 0.5);\n  }\n  return defaultColors[index];\n};\n","import { Box3, Vector3 } from \"three\";\n\nimport Volume, { ImageInfo } from \"../Volume.js\";\nimport { buildDefaultMetadata } from \"./VolumeLoaderUtils.js\";\nimport { PrefetchDirection } from \"./zarr_utils/types.js\";\n\nexport class LoadSpec {\n  time = 0;\n  multiscaleLevel?: number;\n  /** Subregion of volume to load. If not specified, the entire volume is loaded. Specify as floats between 0-1. */\n  subregion = new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1));\n  channels?: number[];\n}\n\nexport function loadSpecToString(spec: LoadSpec): string {\n  const { min, max } = spec.subregion;\n  return `${spec.multiscaleLevel}:${spec.time}:x(${min.x},${max.x}):y(${min.y},${max.y}):z(${min.z},${max.z})`;\n}\n\nexport class VolumeDims {\n  // shape: [t, c, z, y, x]\n  shape: number[] = [0, 0, 0, 0, 0];\n  // spacing: [t, c, z, y, x]; generally expect 1 for non-spatial dimensions\n  spacing: number[] = [1, 1, 1, 1, 1];\n  spaceUnit = \"μm\";\n  timeUnit = \"s\";\n  // TODO make this an enum?\n  dataType = \"uint8\";\n}\n\nexport type LoadedVolumeInfo = {\n  imageInfo: ImageInfo;\n  loadSpec: LoadSpec;\n};\n\n/**\n * @callback PerChannelCallback\n * @param {string} imageurl\n * @param {Volume} volume\n * @param {number} channelindex\n */\nexport type PerChannelCallback = (volume: Volume, channelIndex: number) => void;\n\n// allow lists of channel indices and data arrays to be passed to the callback\nexport type RawChannelDataCallback = (channelIndex: number[], data: Uint8Array[], atlasDims?: [number, number]) => void;\n\n/**\n * Loads volume data from a source specified by a `LoadSpec`.\n *\n * Loaders may keep state for reuse between volume creation and volume loading, and should be kept alive until volume\n * loading is complete. (See `createVolume`)\n */\nexport interface IVolumeLoader {\n  /** Use VolumeDims to further refine a `LoadSpec` for use in `createVolume` */\n  loadDims(loadSpec: LoadSpec): Promise<VolumeDims[]>;\n\n  /**\n   * Create an empty `Volume` from a `LoadSpec`, which must be passed to `loadVolumeData` to begin loading.\n   * Optionally pass a callback to respond whenever new channel data is loaded into the volume.\n   */\n  createVolume(loadSpec: LoadSpec, onChannelLoaded?: PerChannelCallback): Promise<Volume>;\n\n  /**\n   * Begin loading a volume's data, as specified in its `LoadSpec`.\n   * Pass a callback to respond when this request loads a new channel. This callback will execute after the\n   * one assigned in `createVolume`, if any.\n   */\n  // TODO make this return a promise that resolves when loading is done?\n  // TODO this is not cancellable in the sense that any async requests initiated here are not stored\n  // in a way that they can be interrupted.\n  // TODO explicitly passing a `LoadSpec` is now rarely useful. Remove?\n  loadVolumeData(volume: Volume, loadSpec?: LoadSpec, onChannelLoaded?: PerChannelCallback): void;\n\n  /** Change which directions to prioritize when prefetching. Currently only implemented on `OMEZarrLoader`. */\n  setPrefetchPriority(directions: PrefetchDirection[]): void;\n\n  /**\n   * By default channel data can arrive out of order and at different times.\n   * This can cause the rendering to update in a way that is not visually appealing.\n   * In particular, during time series playback or Z slice playback, we would like\n   * to see all channels update at the same time.\n   * @param sync Set true to force all requested channels to load at the same time\n   */\n  syncMultichannelLoading(sync: boolean): void;\n}\n\n/** Abstract class which allows loaders to accept and return types that are easier to transfer to/from a worker. */\nexport abstract class ThreadableVolumeLoader implements IVolumeLoader {\n  /** Unchanged from `IVolumeLoader`. See that interface for details. */\n  abstract loadDims(loadSpec: LoadSpec): Promise<VolumeDims[]>;\n\n  /**\n   * Creates an `ImageInfo` object from a `LoadSpec`, which may be passed to the `Volume` constructor to create an\n   * empty volume that can accept data loaded with the given `LoadSpec`.\n   *\n   * Also returns a new `LoadSpec` that may have been modified from the input `LoadSpec` to reflect the constraints or\n   * abilities of the loader. This new `LoadSpec` should be used when constructing the `Volume`, _not_ the original.\n   */\n  abstract createImageInfo(loadSpec: LoadSpec): Promise<LoadedVolumeInfo>;\n\n  /**\n   * Begins loading per-channel data for the volume specified by `imageInfo` and `loadSpec`.\n   *\n   * Returns a promise that resolves to reflect any modifications to `imageInfo` and/or `loadSpec` that need to be made\n   * based on this load. Actual loaded channel data is passed to `onData` as it is loaded. Depending on the format,\n   * the returned array may be in simple 3d dimension order or reflect a 2d atlas. If the latter, the dimensions of the\n   * atlas are passed as the third argument to `onData`.\n   */\n  abstract loadRawChannelData(\n    imageInfo: ImageInfo,\n    loadSpec: LoadSpec,\n    onData: RawChannelDataCallback\n  ): Promise<Partial<LoadedVolumeInfo>>;\n\n  setPrefetchPriority(_directions: PrefetchDirection[]): void {\n    // no-op by default\n  }\n\n  syncMultichannelLoading(_sync: boolean): void {\n    // default behavior is async, to update channels as they arrive, depending on each\n    // loader's implementation details.\n  }\n\n  async createVolume(loadSpec: LoadSpec, onChannelLoaded?: PerChannelCallback): Promise<Volume> {\n    const { imageInfo, loadSpec: adjustedLoadSpec } = await this.createImageInfo(loadSpec);\n    const vol = new Volume(imageInfo, adjustedLoadSpec, this);\n    vol.channelLoadCallback = onChannelLoaded;\n    vol.imageMetadata = buildDefaultMetadata(imageInfo);\n    return vol;\n  }\n\n  async loadVolumeData(\n    volume: Volume,\n    loadSpecOverride?: LoadSpec,\n    onChannelLoaded?: PerChannelCallback\n  ): Promise<void> {\n    const onChannelData: RawChannelDataCallback = (channelIndices, dataArrays, atlasDims) => {\n      for (let i = 0; i < channelIndices.length; i++) {\n        const channelIndex = channelIndices[i];\n        const data = dataArrays[i];\n        if (atlasDims) {\n          volume.setChannelDataFromAtlas(channelIndex, data, atlasDims[0], atlasDims[1]);\n        } else {\n          volume.setChannelDataFromVolume(channelIndex, data);\n        }\n        onChannelLoaded?.(volume, channelIndex);\n      }\n    };\n\n    const spec = { ...loadSpecOverride, ...volume.loadSpec };\n    const { imageInfo, loadSpec } = await this.loadRawChannelData(volume.imageInfo, spec, onChannelData);\n\n    if (imageInfo) {\n      volume.imageInfo = imageInfo;\n      volume.updateDimensions();\n    }\n    volume.loadSpec = { ...loadSpec, ...spec };\n  }\n}\n","import { Box3, Vector2, Vector3 } from \"three\";\n\nimport {\n  ThreadableVolumeLoader,\n  type LoadSpec,\n  type RawChannelDataCallback,\n  VolumeDims,\n  type LoadedVolumeInfo,\n} from \"./IVolumeLoader.js\";\nimport type { ImageInfo } from \"../Volume.js\";\nimport VolumeCache from \"../VolumeCache.js\";\n\ninterface PackedChannelsImage {\n  name: string;\n  channels: number[];\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\ntype JsonImageInfo = {\n  name: string;\n  version?: string;\n  images: PackedChannelsImage[];\n\n  /** X size of the *original* (not downsampled) volume, in pixels */\n  width: number;\n  /** Y size of the *original* (not downsampled) volume, in pixels */\n  height: number;\n  /** Number of rows of z-slice tiles (not pixels) in the texture atlas */\n  rows: number;\n  /** Number of columns of z-slice tiles (not pixels) in the texture atlas */\n  cols: number;\n  /** Width of a single atlas tile in pixels */\n  tile_width: number;\n  /** Height of a single atlas tile in pixels */\n  tile_height: number;\n  /** Width of the texture atlas in pixels; equivalent to `tile_width * cols` */\n  atlas_width: number;\n  /** Height of the texture atlas in pixels; equivalent to `tile_height * rows` */\n  atlas_height: number;\n  /** Number of tiles in the texture atlas (or number of z-slices in the volume segment) */\n  tiles: number;\n  /** Physical x size of a single *original* (not downsampled) pixel */\n  pixel_size_x: number;\n  /** Physical y size of a single *original* (not downsampled) pixel */\n  pixel_size_y: number;\n  /** Physical z size of a single pixel */\n  pixel_size_z: number;\n  /** Symbol of physical unit used by `pixel_size_(x|y|z)` fields */\n  pixel_size_unit?: string;\n\n  channels: number;\n  channel_names: string[];\n  channel_colors?: [number, number, number][];\n\n  times?: number;\n  time_scale?: number;\n  time_unit?: string;\n\n  // TODO should be optional?\n  transform: {\n    translation: [number, number, number];\n    rotation: [number, number, number];\n  };\n  userData?: Record<string, unknown>;\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n\nconst convertImageInfo = (json: JsonImageInfo): ImageInfo => ({\n  name: json.name,\n\n  originalSize: new Vector3(json.width, json.height, json.tiles),\n  atlasTileDims: new Vector2(json.cols, json.rows),\n  volumeSize: new Vector3(json.tile_width, json.tile_height, json.tiles),\n  subregionSize: new Vector3(json.tile_width, json.tile_height, json.tiles),\n  subregionOffset: new Vector3(0, 0, 0),\n  physicalPixelSize: new Vector3(json.pixel_size_x, json.pixel_size_y, json.pixel_size_z),\n  spatialUnit: json.pixel_size_unit || \"μm\",\n\n  numChannels: json.channels,\n  channelNames: json.channel_names,\n  channelColors: json.channel_colors,\n\n  times: json.times || 1,\n  timeScale: json.time_scale || 1,\n  timeUnit: json.time_unit || \"s\",\n\n  numMultiscaleLevels: 1,\n  multiscaleLevel: 0,\n\n  transform: {\n    translation: json.transform?.translation\n      ? new Vector3().fromArray(json.transform.translation)\n      : new Vector3(0, 0, 0),\n    rotation: json.transform?.rotation ? new Vector3().fromArray(json.transform.rotation) : new Vector3(0, 0, 0),\n  },\n\n  userData: json.userData,\n});\n\nclass JsonImageInfoLoader extends ThreadableVolumeLoader {\n  urls: string[];\n  jsonInfo: (JsonImageInfo | undefined)[];\n\n  cache?: VolumeCache;\n\n  constructor(urls: string | string[], cache?: VolumeCache) {\n    super();\n\n    if (Array.isArray(urls)) {\n      this.urls = urls;\n    } else {\n      this.urls = [urls];\n    }\n\n    this.jsonInfo = new Array(this.urls.length);\n    this.cache = cache;\n  }\n\n  private async getJsonImageInfo(time: number): Promise<JsonImageInfo> {\n    const cachedInfo = this.jsonInfo[time];\n    if (cachedInfo) {\n      return cachedInfo;\n    }\n\n    const response = await fetch(this.urls[time]);\n    const imageInfo = (await response.json()) as JsonImageInfo;\n\n    imageInfo.pixel_size_unit = imageInfo.pixel_size_unit || \"μm\";\n    imageInfo.times = imageInfo.times || this.urls.length;\n    this.jsonInfo[time] = imageInfo;\n    return imageInfo;\n  }\n\n  async loadDims(loadSpec: LoadSpec): Promise<VolumeDims[]> {\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n\n    const d = new VolumeDims();\n    d.shape = [jsonInfo.times || 1, jsonInfo.channels, jsonInfo.tiles, jsonInfo.tile_height, jsonInfo.tile_width];\n    d.spacing = [1, 1, jsonInfo.pixel_size_z, jsonInfo.pixel_size_y, jsonInfo.pixel_size_x];\n    d.spaceUnit = jsonInfo.pixel_size_unit || \"μm\";\n    d.dataType = \"uint8\";\n    return [d];\n  }\n\n  async createImageInfo(loadSpec: LoadSpec): Promise<LoadedVolumeInfo> {\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n    return { imageInfo: convertImageInfo(jsonInfo), loadSpec };\n  }\n\n  async loadRawChannelData(\n    imageInfo: ImageInfo,\n    loadSpec: LoadSpec,\n    onData: RawChannelDataCallback\n  ): Promise<{ loadSpec?: LoadSpec }> {\n    // if you need to adjust image paths prior to download,\n    // now is the time to do it.\n    // Try to figure out the urlPrefix from the LoadSpec.\n    // For this format we assume the image data is in the same directory as the json file.\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n\n    let images = jsonInfo?.images;\n    if (!images) {\n      return {};\n    }\n\n    const requestedChannels = loadSpec.channels;\n    if (requestedChannels) {\n      // If only some channels are requested, load only images which contain at least one requested channel\n      images = images.filter(({ channels }) => channels.some((ch) => ch in requestedChannels));\n    }\n\n    // This regex removes everything after the last slash, so the url had better be simple.\n    const urlPrefix = this.urls[loadSpec.time].replace(/[^/]*$/, \"\");\n    images = images.map((element) => ({ ...element, name: urlPrefix + element.name }));\n\n    const w = imageInfo.atlasTileDims.x * imageInfo.volumeSize.x;\n    const h = imageInfo.atlasTileDims.y * imageInfo.volumeSize.y;\n    const wrappedOnData = (ch: number[], data: Uint8Array[]) => onData(ch, data, [w, h]);\n    JsonImageInfoLoader.loadVolumeAtlasData(images, wrappedOnData, this.cache);\n\n    const adjustedLoadSpec = {\n      ...loadSpec,\n      // `subregion` and `multiscaleLevel` are unused by this loader\n      subregion: new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1)),\n      multiscaleLevel: 0,\n      // include all channels in any loaded images\n      channels: images.flatMap(({ channels }) => channels),\n    };\n    return { loadSpec: adjustedLoadSpec };\n  }\n\n  /**\n   * load per-channel volume data from a batch of image files containing the volume slices tiled across the images\n   * @param {Array.<{name:string, channels:Array.<number>}>} imageArray\n   * @param {RawChannelDataCallback} onData Per-channel callback. Called when each channel's atlased volume data is loaded\n   * @param {VolumeCache} cache\n   * @example loadVolumeAtlasData([{\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_0.png\",\n   *     \"channels\": [0, 1, 2]\n   * }, {\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_1.png\",\n   *     \"channels\": [3, 4, 5]\n   * }, {\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_2.png\",\n   *     \"channels\": [6, 7, 8]\n   * }], mycallback);\n   */\n  static loadVolumeAtlasData(\n    imageArray: PackedChannelsImage[],\n    onData: RawChannelDataCallback,\n    cache?: VolumeCache\n  ): void {\n    imageArray.forEach(async (image) => {\n      // Because the data is fetched such that one fetch returns a whole batch,\n      // if any in batch is cached then they all should be. So if any in batch is NOT cached,\n      // then we will have to do a batch request. This logic works both ways because it's all or nothing.\n      let cacheHit = true;\n      for (let j = 0; j < Math.min(image.channels.length, 4); ++j) {\n        const chindex = image.channels[j];\n        const cacheResult = cache?.get(`${image.name}/${chindex}`);\n        if (cacheResult) {\n          onData([chindex], [new Uint8Array(cacheResult)]);\n        } else {\n          cacheHit = false;\n          // we can stop checking because we know we are going to have to fetch the whole batch\n          break;\n        }\n      }\n\n      // if all channels were in cache then we can move on to the next\n      // image (batch) without requesting\n      if (cacheHit) {\n        return;\n      }\n\n      const response = await fetch(image.name, { mode: \"cors\" });\n      const blob = await response.blob();\n      const bitmap = await createImageBitmap(blob);\n\n      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n      const ctx = canvas.getContext(\"2d\") as OffscreenCanvasRenderingContext2D | null;\n      if (!ctx) {\n        console.log(\"Error creating canvas 2d context for \" + image.name);\n        return;\n      }\n      ctx.globalCompositeOperation = \"copy\";\n      ctx.globalAlpha = 1.0;\n      ctx.drawImage(bitmap, 0, 0);\n      const iData = ctx.getImageData(0, 0, bitmap.width, bitmap.height);\n\n      const channelsBits: Uint8Array[] = [];\n      const length = bitmap.width * bitmap.height;\n\n      // allocate channels in batch\n      for (let ch = 0; ch < Math.min(image.channels.length, 4); ++ch) {\n        channelsBits.push(new Uint8Array(length));\n      }\n\n      // extract the data\n      for (let j = 0; j < Math.min(image.channels.length, 4); ++j) {\n        for (let px = 0; px < length; px++) {\n          channelsBits[j][px] = iData.data[px * 4 + j];\n        }\n      }\n\n      // done with `iData` and `canvas` now.\n\n      for (let ch = 0; ch < Math.min(image.channels.length, 4); ++ch) {\n        const chindex = image.channels[ch];\n        cache?.insert(`${image.name}/${chindex}`, channelsBits[ch]);\n        // NOTE: the atlas dimensions passed in here are currently unused by `JSONImageInfoLoader`\n        onData([chindex], [channelsBits[ch]], [bitmap.width, bitmap.height]);\n      }\n    });\n  }\n}\n\nexport { JsonImageInfoLoader };\n","import { Box3, Vector3 } from \"three\";\n\nimport * as zarr from \"@zarrita/core\";\nimport { get as zarrGet, slice, Slice } from \"@zarrita/indexing\";\nimport { AbsolutePath } from \"@zarrita/storage\";\n// Importing `FetchStore` from its home subpackage (@zarrita/storage) causes errors.\n// Getting it from the top-level package means we don't get its type. This is also a bug, but it's more acceptable.\nimport { FetchStore } from \"zarrita\";\n\nimport { ImageInfo } from \"../Volume.js\";\nimport VolumeCache from \"../VolumeCache.js\";\nimport SubscribableRequestQueue from \"../utils/SubscribableRequestQueue.js\";\nimport {\n  ThreadableVolumeLoader,\n  LoadSpec,\n  type RawChannelDataCallback,\n  VolumeDims,\n  type LoadedVolumeInfo,\n} from \"./IVolumeLoader.js\";\nimport {\n  composeSubregion,\n  computePackedAtlasDims,\n  convertSubregionToPixels,\n  unitNameToSymbol,\n} from \"./VolumeLoaderUtils.js\";\nimport ChunkPrefetchIterator from \"./zarr_utils/ChunkPrefetchIterator.js\";\nimport WrappedStore from \"./zarr_utils/WrappedStore.js\";\nimport {\n  getDimensionCount,\n  getScale,\n  matchSourceScaleLevels,\n  orderByDimension,\n  orderByTCZYX,\n  pickLevelToLoad,\n  remapAxesToTCZYX,\n} from \"./zarr_utils/utils.js\";\nimport type {\n  OMEZarrMetadata,\n  SubscriberId,\n  TCZYX,\n  PrefetchDirection,\n  ZarrSource,\n  NumericZarrArray,\n} from \"./zarr_utils/types.js\";\n\nconst CHUNK_REQUEST_CANCEL_REASON = \"chunk request cancelled\";\n\nfunction convertChannel(channelData: zarr.TypedArray<zarr.NumberDataType>): Uint8Array {\n  if (channelData instanceof Uint8Array) {\n    return channelData as Uint8Array;\n  }\n\n  const u8 = new Uint8Array(channelData.length);\n\n  // get min and max\n  let min = channelData[0];\n  let max = channelData[0];\n  for (let i = 0; i < channelData.length; i++) {\n    const val = channelData[i];\n    if (val < min) {\n      min = val;\n    }\n    if (val > max) {\n      max = val;\n    }\n  }\n\n  // normalize and convert to u8\n  const range = max - min;\n  for (let i = 0; i < channelData.length; i++) {\n    u8[i] = ((channelData[i] - min) / range) * 255;\n  }\n\n  return u8;\n}\n\nexport type ZarrLoaderFetchOptions = {\n  /** The max. number of requests the loader can issue at a time. Ignored if the constructor also receives a queue. */\n  concurrencyLimit?: number;\n  /**\n   * The max. number of *prefetch* requests the loader can issue at a time. Set lower than `concurrencyLimit` to ensure\n   * that prefetching leaves room in the queue for actual loads. Ignored if the constructor also receives a queue.\n   */\n  prefetchConcurrencyLimit?: number;\n  /**\n   * The max. number of chunks to prefetch outward in either direction. E.g. if a load requests chunks with z coords 3\n   * and 4 and `maxPrefetchDistance` in z is 2, the loader will prefetch similar chunks with z coords 1, 2, 5, and 6\n   * (or until it hits `maxPrefetchChunks`). Ordered TZYX.\n   */\n  maxPrefetchDistance: [number, number, number, number];\n  /** The max. number of total chunks that can be prefetched after any load. */\n  maxPrefetchChunks: number;\n  /** The initial directions to prioritize when prefetching */\n  priorityDirections?: PrefetchDirection[];\n};\n\ntype ZarrChunkFetchInfo = {\n  sourceIdx: number;\n  key: string;\n};\n\nconst DEFAULT_FETCH_OPTIONS = {\n  maxPrefetchDistance: [5, 5, 5, 5] as [number, number, number, number],\n  maxPrefetchChunks: 30,\n};\n\nclass OMEZarrLoader extends ThreadableVolumeLoader {\n  /** The ID of the subscriber responsible for \"actual loads\" (non-prefetch requests) */\n  private loadSubscriber: SubscriberId | undefined;\n  /** The ID of the subscriber responsible for prefetches, so that requests can be cancelled and reissued */\n  private prefetchSubscriber: SubscriberId | undefined;\n\n  // TODO: this property should definitely be owned by `Volume` if this loader is ever used by multiple volumes.\n  //   This may cause errors or incorrect results otherwise!\n  private maxExtent?: Box3;\n\n  private syncChannels = false;\n\n  private constructor(\n    /**\n     * Array of records, each containing the objects and metadata we need to load from one source of multiscale zarr\n     * data. See documentation on `ZarrSource` for more.\n     */\n    private sources: ZarrSource[],\n    /** Handle to a `SubscribableRequestQueue` for smart concurrency management and request cancelling/reissuing. */\n    private requestQueue: SubscribableRequestQueue,\n    /** Options to configure (pre)fetching behavior. */\n    private fetchOptions: ZarrLoaderFetchOptions = DEFAULT_FETCH_OPTIONS,\n    /** Direction(s) to prioritize when prefetching. Stored separate from `fetchOptions` since it may be mutated. */\n    private priorityDirections: PrefetchDirection[] = []\n  ) {\n    super();\n  }\n\n  /**\n   * Creates a new `OMEZarrLoader`.\n   *\n   * @param urls The URL(s) of the OME-Zarr data to load. If `urls` is an array, the loader will attempt to find scale\n   *  levels with exactly the same size in every source. If matching level(s) are available, the loader will produce a\n   *  volume containing all channels from every provided zarr in the order they appear in `urls`. If no matching sets\n   *  of scale levels are available, creation fails.\n   * @param scenes The scene(s) to load from each URL. If `urls` is an array, `scenes` may either be an array of values\n   *  corresponding to each URL, or a single value to apply to all URLs. Default 0.\n   * @param cache A cache to use for storing fetched data. If not provided, a new cache will be created.\n   * @param queue A queue to use for managing requests. If not provided, a new queue will be created.\n   * @param fetchOptions Options to configure (pre)fetching behavior.\n   */\n  static async createLoader(\n    urls: string | string[],\n    scenes: number | number[] = 0,\n    cache?: VolumeCache,\n    queue?: SubscribableRequestQueue,\n    fetchOptions?: ZarrLoaderFetchOptions\n  ): Promise<OMEZarrLoader> {\n    // Setup queue and store, get basic metadata\n    if (!queue) {\n      queue = new SubscribableRequestQueue(fetchOptions?.concurrencyLimit, fetchOptions?.prefetchConcurrencyLimit);\n    }\n    const urlsArr = Array.isArray(urls) ? urls : [urls];\n    const scenesArr = Array.isArray(scenes) ? scenes : [scenes];\n\n    // Create one `ZarrSource` per URL\n    const sourceProms = urlsArr.map(async (url, i) => {\n      const store = new WrappedStore<RequestInit>(new FetchStore(url), cache, queue);\n      const root = zarr.root(store);\n      const group = await zarr.open(root, { kind: \"group\" });\n      const { multiscales, omero } = group.attrs as OMEZarrMetadata;\n\n      // Pick scene (multiscale)\n      let scene = scenesArr[Math.min(i, scenesArr.length - 1)];\n      if (scene > multiscales.length) {\n        console.warn(`WARNING: OMEZarrLoader: scene ${scene} is invalid. Using scene 0.`);\n        scene = 0;\n      }\n      const multiscaleMetadata = multiscales[scene];\n\n      // Open all scale levels of multiscale\n      const lvlProms = multiscaleMetadata.datasets.map(({ path }) => zarr.open(root.resolve(path), { kind: \"array\" }));\n      const scaleLevels = (await Promise.all(lvlProms)) as NumericZarrArray[];\n      const axesTCZYX = remapAxesToTCZYX(multiscaleMetadata.axes);\n\n      return {\n        scaleLevels,\n        multiscaleMetadata,\n        omeroMetadata: omero,\n        axesTCZYX,\n        channelOffset: 0,\n      } as ZarrSource;\n    });\n    const sources = await Promise.all(sourceProms);\n\n    // Set `channelOffset`s so we can match channel indices to sources\n    let channelCount = 0;\n    for (const s of sources) {\n      s.channelOffset = channelCount;\n      channelCount += s.omeroMetadata.channels.length;\n    }\n    // Ensure the sizes of all sources' scale levels are matched up. See this function's docs for more.\n    matchSourceScaleLevels(sources);\n    // TODO: if `matchSourceScaleLevels` returned successfully, every one of these sources' `multiscaleMetadata` is the\n    // same in every field we care about, so we only ever use the first source's `multiscaleMetadata` after this point.\n    // Should we only store one `OMEMultiscale` record total, rather than one per source?\n    const priorityDirs = fetchOptions?.priorityDirections ? fetchOptions.priorityDirections.slice() : undefined;\n    return new OMEZarrLoader(sources, queue, fetchOptions, priorityDirs);\n  }\n\n  private getUnitSymbols(): [string, string] {\n    const source = this.sources[0];\n    // Assume all spatial axes in all sources have the same units - we have no means of storing per-axis unit symbols\n    const xi = source.axesTCZYX[4];\n    const spaceUnitName = source.multiscaleMetadata.axes[xi].unit;\n    const spaceUnitSymbol = unitNameToSymbol(spaceUnitName) || spaceUnitName || \"\";\n\n    const ti = source.axesTCZYX[0];\n    const timeUnitName = ti > -1 ? source.multiscaleMetadata.axes[ti].unit : undefined;\n    const timeUnitSymbol = unitNameToSymbol(timeUnitName) || timeUnitName || \"\";\n\n    return [spaceUnitSymbol, timeUnitSymbol];\n  }\n\n  private getLevelShapesZYX(): [number, number, number][] {\n    const source = this.sources[0];\n    const [z, y, x] = source.axesTCZYX.slice(-3);\n    return source.scaleLevels.map(({ shape }) => [z === -1 ? 1 : shape[z], shape[y], shape[x]]);\n  }\n\n  private getScale(level: number): TCZYX<number> {\n    return getScale(this.sources[0].multiscaleMetadata.datasets[level], this.sources[0].axesTCZYX);\n  }\n\n  private orderByDimension<T>(valsTCZYX: TCZYX<T>, sourceIdx = 0): T[] {\n    return orderByDimension(valsTCZYX, this.sources[sourceIdx].axesTCZYX);\n  }\n\n  private orderByTCZYX<T>(valsDimension: T[], defaultValue: T, sourceIdx = 0): TCZYX<T> {\n    return orderByTCZYX(valsDimension, this.sources[sourceIdx].axesTCZYX, defaultValue);\n  }\n\n  /**\n   * Converts a volume channel index to the index of its zarr source and its channel index within that zarr.\n   * e.g., if the loader has 2 sources, the first with 3 channels and the second with 2, then `matchChannelToSource(4)`\n   * returns `[1, 1]` (the second channel of the second source).\n   */\n  private matchChannelToSource(absoluteChannelIndex: number): { sourceIndex: number; channelIndexInSource: number } {\n    const lastSrcIdx = this.sources.length - 1;\n    const lastSrc = this.sources[lastSrcIdx];\n    const lastSrcNumChannels = lastSrc.scaleLevels[0].shape[lastSrc.axesTCZYX[1]];\n\n    if (absoluteChannelIndex > lastSrc.channelOffset + lastSrcNumChannels) {\n      throw new Error(\"Channel index out of range\");\n    }\n\n    const firstGreaterIdx = this.sources.findIndex((src) => src.channelOffset > absoluteChannelIndex);\n    const sourceIndex = firstGreaterIdx === -1 ? lastSrcIdx : firstGreaterIdx - 1;\n    const channelIndexInSource = absoluteChannelIndex - this.sources[sourceIndex].channelOffset;\n    return { sourceIndex, channelIndexInSource };\n  }\n\n  /**\n   * Change which directions to prioritize when prefetching. All chunks will be prefetched in these directions before\n   * any chunks are prefetched in any other directions.\n   */\n  setPrefetchPriority(directions: PrefetchDirection[]): void {\n    this.priorityDirections = directions;\n  }\n\n  syncMultichannelLoading(sync: boolean): void {\n    this.syncChannels = sync;\n  }\n\n  loadDims(loadSpec: LoadSpec): Promise<VolumeDims[]> {\n    const [spaceUnit, timeUnit] = this.getUnitSymbols();\n    // Compute subregion size so we can factor that in\n    const maxExtent = this.maxExtent ?? new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1));\n    const subregion = composeSubregion(loadSpec.subregion, maxExtent);\n    const regionSize = subregion.getSize(new Vector3());\n    const regionArr = [1, 1, regionSize.z, regionSize.y, regionSize.x];\n\n    const result = this.sources[0].scaleLevels.map((level, i) => {\n      const scale = this.getScale(i);\n      const dims = new VolumeDims();\n\n      dims.spaceUnit = spaceUnit;\n      dims.timeUnit = timeUnit;\n      dims.shape = this.orderByTCZYX(level.shape, 1).map((val, idx) => Math.ceil(val * regionArr[idx]));\n      dims.spacing = this.orderByTCZYX(scale, 1);\n\n      return dims;\n    });\n\n    return Promise.resolve(result);\n  }\n\n  createImageInfo(loadSpec: LoadSpec): Promise<LoadedVolumeInfo> {\n    // We ensured most info (dims, chunks, etc.) matched between sources earlier, so we can just use the first source.\n    const source0 = this.sources[0];\n    const [t, , z, y, x] = source0.axesTCZYX;\n    const hasT = t > -1;\n    const hasZ = z > -1;\n\n    const shape0 = source0.scaleLevels[0].shape;\n    const levelToLoad = pickLevelToLoad(loadSpec, this.getLevelShapesZYX());\n    const shapeLv = source0.scaleLevels[levelToLoad].shape;\n\n    const [spatialUnit, timeUnit] = this.getUnitSymbols();\n\n    // Now we care about other sources: # of channels is the `channelOffset` of the last source plus its # of channels\n    const sourceLast = this.sources[this.sources.length - 1];\n    const cLast = sourceLast.axesTCZYX[1];\n    const lastHasC = cLast > -1;\n    const numChannels = sourceLast.channelOffset + (lastHasC ? sourceLast.scaleLevels[levelToLoad].shape[cLast] : 1);\n    const times = hasT ? shapeLv[t] : 1;\n\n    if (!this.maxExtent) {\n      this.maxExtent = loadSpec.subregion.clone();\n    }\n    const pxDims0 = convertSubregionToPixels(\n      loadSpec.subregion,\n      new Vector3(shape0[x], shape0[y], hasZ ? shape0[z] : 1)\n    );\n    const pxSize0 = pxDims0.getSize(new Vector3());\n    const pxDimsLv = convertSubregionToPixels(\n      loadSpec.subregion,\n      new Vector3(shapeLv[x], shapeLv[y], hasZ ? shapeLv[z] : 1)\n    );\n    const pxSizeLv = pxDimsLv.getSize(new Vector3());\n\n    const atlasTileDims = computePackedAtlasDims(pxSizeLv.z, pxSizeLv.x, pxSizeLv.y);\n\n    // Channel names is the other place where we have to check every source\n    // Track which channel names we've seen so far, so that we can rename them to avoid name collisions\n    const channelNamesMap = new Map<string, number>();\n    const channelNames = this.sources.flatMap((src) =>\n      src.omeroMetadata.channels.map((ch) => {\n        const numMatchingChannels = channelNamesMap.get(ch.label);\n\n        if (numMatchingChannels !== undefined) {\n          // If e.g. we've seen channel \"Membrane\" once before, rename this one to \"Membrane (1)\"\n          channelNamesMap.set(ch.label, numMatchingChannels + 1);\n          return `${ch.label} (${numMatchingChannels})`;\n        } else {\n          channelNamesMap.set(ch.label, 1);\n          return ch.label;\n        }\n      })\n    );\n\n    const scale5d = this.getScale(levelToLoad);\n    const timeScale = hasT ? scale5d[t] : 1;\n\n    const imgdata: ImageInfo = {\n      name: source0.omeroMetadata.name,\n\n      originalSize: pxSize0,\n      atlasTileDims,\n      volumeSize: pxSizeLv,\n      subregionSize: pxSizeLv.clone(),\n      subregionOffset: new Vector3(0, 0, 0),\n      physicalPixelSize: new Vector3(scale5d[x], scale5d[y], hasZ ? scale5d[z] : Math.min(scale5d[x], scale5d[y])),\n      spatialUnit,\n\n      numChannels,\n      channelNames,\n      times,\n      timeScale,\n      timeUnit,\n      numMultiscaleLevels: source0.scaleLevels.length,\n      multiscaleLevel: levelToLoad,\n\n      transform: {\n        translation: new Vector3(0, 0, 0),\n        rotation: new Vector3(0, 0, 0),\n      },\n    };\n\n    // The `LoadSpec` passed in at this stage should represent the subset which this loader loads, not that\n    // which the volume contains. The volume contains the full extent of the subset recognized by this loader.\n    const fullExtentLoadSpec: LoadSpec = {\n      ...loadSpec,\n      subregion: new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1)),\n    };\n\n    return Promise.resolve({ imageInfo: imgdata, loadSpec: fullExtentLoadSpec });\n  }\n\n  private async prefetchChunk(\n    scaleLevel: NumericZarrArray,\n    coords: TCZYX<number>,\n    subscriber: SubscriberId\n  ): Promise<void> {\n    const { store, path } = scaleLevel;\n    const separator = path.endsWith(\"/\") ? \"\" : \"/\";\n    const key = path + separator + this.orderByDimension(coords).join(\"/\");\n    try {\n      // Calling `get` and doing nothing with the result still triggers a cache check, fetch, and insertion\n      await store.get(key as AbsolutePath, { subscriber, isPrefetch: true });\n    } catch (e) {\n      if (e !== CHUNK_REQUEST_CANCEL_REASON) {\n        throw e;\n      }\n    }\n  }\n\n  /** Reads a list of chunk keys requested by a `loadVolumeData` call and sets up appropriate prefetch requests. */\n  private beginPrefetch(keys: ZarrChunkFetchInfo[], scaleLevel: number): void {\n    // Convert keys to arrays of coords\n    const chunkCoords = keys.map(({ sourceIdx, key }) => {\n      const numDims = getDimensionCount(this.sources[sourceIdx].axesTCZYX);\n      const coordsInDimensionOrder = key\n        .trim()\n        .split(\"/\")\n        .slice(-numDims)\n        .filter((s) => s !== \"\")\n        .map((s) => parseInt(s, 10));\n      const sourceCoords = this.orderByTCZYX(coordsInDimensionOrder, 0, sourceIdx);\n      // Convert source channel index to absolute channel index for `ChunkPrefetchIterator`'s benefit\n      // (we match chunk coordinates output from `ChunkPrefetchIterator` back to sources below)\n      sourceCoords[1] += this.sources[sourceIdx].channelOffset;\n      return sourceCoords;\n    });\n\n    // Get number of chunks per dimension in `scaleLevel`\n    const source0Shape = this.sources[0].scaleLevels[scaleLevel];\n    const chunkDimsUnordered = source0Shape.shape.map((dim, idx) => Math.ceil(dim / source0Shape.chunks[idx]));\n    const chunkDims = this.orderByTCZYX(chunkDimsUnordered, 1);\n\n    const subscriber = this.requestQueue.addSubscriber();\n    // `ChunkPrefetchIterator` yields chunk coordinates in order of roughly how likely they are to be loaded next\n    const chunkDimsTZYX: [number, number, number, number] = [chunkDims[0], chunkDims[2], chunkDims[3], chunkDims[4]];\n    const prefetchIterator = new ChunkPrefetchIterator(\n      chunkCoords,\n      this.fetchOptions.maxPrefetchDistance,\n      chunkDimsTZYX,\n      this.priorityDirections\n    );\n\n    let prefetchCount = 0;\n    for (const chunk of prefetchIterator) {\n      if (prefetchCount >= this.fetchOptions.maxPrefetchChunks) {\n        break;\n      }\n      // Match absolute channel coordinate back to source index and channel index\n      const { sourceIndex, channelIndexInSource } = this.matchChannelToSource(chunk[1]);\n      const sourceScaleLevel = this.sources[sourceIndex].scaleLevels[scaleLevel];\n      chunk[1] = channelIndexInSource;\n      this.prefetchChunk(sourceScaleLevel, chunk, subscriber);\n      prefetchCount++;\n    }\n\n    // Clear out old prefetch requests (requests which also cover this new prefetch will be preserved)\n    if (this.prefetchSubscriber !== undefined) {\n      this.requestQueue.removeSubscriber(this.prefetchSubscriber, CHUNK_REQUEST_CANCEL_REASON);\n    }\n    this.prefetchSubscriber = subscriber;\n  }\n\n  private updateImageInfoForLoad(imageInfo: ImageInfo, loadSpec: LoadSpec): ImageInfo {\n    // Apply `this.maxExtent` to subregion, if it exists\n    const maxExtent = this.maxExtent ?? new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1));\n    const subregion = composeSubregion(loadSpec.subregion, maxExtent);\n\n    // Pick the level to load based on the subregion size\n    const multiscaleLevel = pickLevelToLoad({ ...loadSpec, subregion }, this.getLevelShapesZYX());\n    const array0Shape = this.sources[0].scaleLevels[multiscaleLevel].shape;\n\n    // Convert subregion to volume voxels\n    const [z, y, x] = this.sources[0].axesTCZYX.slice(2);\n    const regionPx = convertSubregionToPixels(\n      subregion,\n      new Vector3(array0Shape[x], array0Shape[y], z === -1 ? 1 : array0Shape[z])\n    );\n\n    // Derive other image info properties from subregion and level to load\n    const subregionSize = regionPx.getSize(new Vector3());\n    const atlasTileDims = computePackedAtlasDims(subregionSize.z, subregionSize.x, subregionSize.y);\n    const volumeExtent = convertSubregionToPixels(\n      maxExtent,\n      new Vector3(array0Shape[x], array0Shape[y], z === -1 ? 1 : array0Shape[z])\n    );\n    const volumeSize = volumeExtent.getSize(new Vector3());\n\n    return {\n      ...imageInfo,\n      atlasTileDims,\n      volumeSize,\n      subregionSize,\n      subregionOffset: regionPx.min,\n      multiscaleLevel,\n    };\n  }\n\n  loadRawChannelData(\n    imageInfo: ImageInfo,\n    loadSpec: LoadSpec,\n    onData: RawChannelDataCallback\n  ): Promise<{ imageInfo: ImageInfo }> {\n    // This seemingly useless line keeps a stable local copy of `syncChannels` which the async closures below capture\n    // so that changes to `this.syncChannels` don't affect the behavior of loads in progress.\n    const syncChannels = this.syncChannels;\n\n    const updatedImageInfo = this.updateImageInfoForLoad(imageInfo, loadSpec);\n    const { numChannels, multiscaleLevel } = updatedImageInfo;\n    const channelIndexes = loadSpec.channels ?? Array.from({ length: numChannels }, (_, i) => i);\n\n    const subscriber = this.requestQueue.addSubscriber();\n\n    // Prefetch housekeeping: we want to save keys involved in this load to prefetch later\n    const keys: ZarrChunkFetchInfo[] = [];\n    const reportKeyBase = (sourceIdx: number, key: string, sub: SubscriberId) => {\n      if (sub === subscriber) {\n        keys.push({ sourceIdx, key });\n      }\n    };\n\n    const resultChannelIndices: number[] = [];\n    const resultChannelData: Uint8Array[] = [];\n\n    const channelPromises = channelIndexes.map(async (ch) => {\n      // Build slice spec\n      const min = updatedImageInfo.subregionOffset;\n      const max = min.clone().add(updatedImageInfo.subregionSize);\n      const { sourceIndex: sourceIdx, channelIndexInSource: sourceCh } = this.matchChannelToSource(ch);\n      const unorderedSpec = [loadSpec.time, sourceCh, slice(min.z, max.z), slice(min.y, max.y), slice(min.x, max.x)];\n\n      const level = this.sources[sourceIdx].scaleLevels[multiscaleLevel];\n      const sliceSpec = this.orderByDimension(unorderedSpec as TCZYX<number | Slice>, sourceIdx);\n      const reportKey = (key: string, sub: SubscriberId) => reportKeyBase(sourceIdx, key, sub);\n\n      try {\n        const result = await zarrGet(level, sliceSpec, { opts: { subscriber, reportKey } });\n        const u8 = convertChannel(result.data);\n        if (syncChannels) {\n          resultChannelData.push(u8);\n          resultChannelIndices.push(ch);\n        } else {\n          onData([ch], [u8]);\n        }\n      } catch (e) {\n        // TODO: verify that cancelling requests in progress doesn't leak memory\n        if (e !== CHUNK_REQUEST_CANCEL_REASON) {\n          console.log(e);\n          throw e;\n        }\n      }\n    });\n\n    // Cancel any in-flight requests from previous loads that aren't useful to this one\n    if (this.loadSubscriber !== undefined) {\n      this.requestQueue.removeSubscriber(this.loadSubscriber, CHUNK_REQUEST_CANCEL_REASON);\n    }\n    this.loadSubscriber = subscriber;\n\n    this.beginPrefetch(keys, multiscaleLevel);\n\n    Promise.all(channelPromises).then(() => {\n      if (syncChannels) {\n        onData(resultChannelIndices, resultChannelData);\n      }\n      this.requestQueue.removeSubscriber(subscriber, CHUNK_REQUEST_CANCEL_REASON);\n    });\n    return Promise.resolve({ imageInfo: updatedImageInfo });\n  }\n}\n\nexport { OMEZarrLoader };\n","import { fromUrl } from \"geotiff\";\nimport { Vector3 } from \"three\";\n\nimport {\n  ThreadableVolumeLoader,\n  LoadSpec,\n  type RawChannelDataCallback,\n  VolumeDims,\n  type LoadedVolumeInfo,\n} from \"./IVolumeLoader.js\";\nimport { computePackedAtlasDims } from \"./VolumeLoaderUtils.js\";\nimport type { ImageInfo } from \"../Volume.js\";\n\nfunction prepareXML(xml: string): string {\n  // trim trailing unicode zeros?\n  // eslint-disable-next-line no-control-regex\n  const expr = /[\\u0000]$/g;\n  return xml.trim().replace(expr, \"\").trim();\n}\n\nfunction getOME(xml: string): Element {\n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(xml, \"text/xml\");\n  const omeEl = xmlDoc.getElementsByTagName(\"OME\")[0];\n  return omeEl;\n}\n\nclass OMEDims {\n  sizex = 0;\n  sizey = 0;\n  sizez = 0;\n  sizec = 0;\n  sizet = 0;\n  unit = \"\";\n  pixeltype = \"\";\n  dimensionorder = \"\";\n  pixelsizex = 0;\n  pixelsizey = 0;\n  pixelsizez = 0;\n  channelnames: string[] = [];\n}\n\nfunction getOMEDims(imageEl: Element): OMEDims {\n  const dims = new OMEDims();\n\n  const pixelsEl = imageEl.getElementsByTagName(\"Pixels\")[0];\n  dims.sizex = Number(pixelsEl.getAttribute(\"SizeX\"));\n  dims.sizey = Number(pixelsEl.getAttribute(\"SizeY\"));\n  dims.sizez = Number(pixelsEl.getAttribute(\"SizeZ\"));\n  dims.sizec = Number(pixelsEl.getAttribute(\"SizeC\"));\n  dims.sizet = Number(pixelsEl.getAttribute(\"SizeT\"));\n  dims.unit = pixelsEl.getAttribute(\"PhysicalSizeXUnit\") || \"\";\n  dims.pixeltype = pixelsEl.getAttribute(\"Type\") || \"\";\n  dims.dimensionorder = pixelsEl.getAttribute(\"DimensionOrder\") || \"XYZCT\";\n  dims.pixelsizex = Number(pixelsEl.getAttribute(\"PhysicalSizeX\"));\n  dims.pixelsizey = Number(pixelsEl.getAttribute(\"PhysicalSizeY\"));\n  dims.pixelsizez = Number(pixelsEl.getAttribute(\"PhysicalSizeZ\"));\n  const channelsEls = pixelsEl.getElementsByTagName(\"Channel\");\n  for (let i = 0; i < channelsEls.length; ++i) {\n    const name = channelsEls[i].getAttribute(\"Name\");\n    const id = channelsEls[i].getAttribute(\"ID\");\n    dims.channelnames.push(name ? name : id ? id : \"Channel\" + i);\n  }\n\n  return dims;\n}\n\nconst getBytesPerSample = (type: string): number => (type === \"uint8\" ? 1 : type === \"uint16\" ? 2 : 4);\n\n// Despite the class `TiffLoader` extends, this loader is not threadable, since geotiff internally uses features that\n// aren't available on workers. It uses its own specialized workers anyways.\nclass TiffLoader extends ThreadableVolumeLoader {\n  url: string;\n  dims?: OMEDims;\n\n  constructor(url: string) {\n    super();\n    this.url = url;\n  }\n\n  private async loadOmeDims(): Promise<OMEDims> {\n    if (!this.dims) {\n      const tiff = await fromUrl(this.url, { allowFullFile: true });\n      // DO NOT DO THIS, ITS SLOW\n      // const imagecount = await tiff.getImageCount();\n      // read the FIRST image\n      const image = await tiff.getImage();\n\n      const tiffimgdesc = prepareXML(image.getFileDirectory().ImageDescription);\n      const omeEl = getOME(tiffimgdesc);\n\n      const image0El = omeEl.getElementsByTagName(\"Image\")[0];\n      this.dims = getOMEDims(image0El);\n    }\n    return this.dims;\n  }\n\n  async loadDims(_loadSpec: LoadSpec): Promise<VolumeDims[]> {\n    const dims = await this.loadOmeDims();\n\n    const d = new VolumeDims();\n    d.shape = [dims.sizet, dims.sizec, dims.sizez, dims.sizey, dims.sizex];\n    d.spacing = [1, 1, dims.pixelsizez, dims.pixelsizey, dims.pixelsizex];\n    d.spaceUnit = dims.unit ? dims.unit : \"micron\";\n    d.dataType = dims.pixeltype ? dims.pixeltype : \"uint8\";\n    return [d];\n  }\n\n  async createImageInfo(_loadSpec: LoadSpec): Promise<LoadedVolumeInfo> {\n    const dims = await this.loadOmeDims();\n    // compare with sizex, sizey\n    //const width = image.getWidth();\n    //const height = image.getHeight();\n\n    // TODO allow user setting of this downsampling info?\n    // TODO allow ROI selection: range of x,y,z,c for a given t\n    const atlasDims = computePackedAtlasDims(dims.sizez, dims.sizex, dims.sizey);\n    // fit tiles to max of 2048x2048?\n    const targetSize = 2048;\n    const tilesizex = Math.floor(targetSize / atlasDims.x);\n    const tilesizey = Math.floor(targetSize / atlasDims.y);\n\n    // load tiff and check metadata\n\n    const imgdata: ImageInfo = {\n      name: \"TEST\",\n\n      originalSize: new Vector3(dims.sizex, dims.sizey, dims.sizez),\n      atlasTileDims: atlasDims,\n      volumeSize: new Vector3(tilesizex, tilesizey, dims.sizez),\n      subregionSize: new Vector3(tilesizex, tilesizey, dims.sizez),\n      subregionOffset: new Vector3(0, 0, 0),\n      physicalPixelSize: new Vector3(dims.pixelsizex, dims.pixelsizey, dims.pixelsizez),\n      spatialUnit: dims.unit || \"\",\n\n      numChannels: dims.sizec,\n      channelNames: dims.channelnames,\n\n      times: dims.sizet,\n      timeScale: 1,\n      timeUnit: \"\",\n\n      numMultiscaleLevels: 1,\n      multiscaleLevel: 0,\n\n      transform: {\n        translation: new Vector3(0, 0, 0),\n        rotation: new Vector3(0, 0, 0),\n      },\n    };\n\n    // This loader uses no fields from `LoadSpec`. Initialize volume with defaults.\n    return { imageInfo: imgdata, loadSpec: new LoadSpec() };\n  }\n\n  async loadRawChannelData(\n    imageInfo: ImageInfo,\n    _loadSpec: LoadSpec,\n    onData: RawChannelDataCallback\n  ): Promise<Record<string, never>> {\n    const dims = await this.loadOmeDims();\n\n    // do each channel on a worker?\n    for (let channel = 0; channel < imageInfo.numChannels; ++channel) {\n      const params = {\n        channel: channel,\n        // these are target xy sizes for the in-memory volume data\n        // they may or may not be the same size as original xy sizes\n        tilesizex: imageInfo.volumeSize.x,\n        tilesizey: imageInfo.volumeSize.y,\n        sizec: imageInfo.numChannels,\n        sizez: imageInfo.volumeSize.z,\n        dimensionOrder: dims.dimensionorder,\n        bytesPerSample: getBytesPerSample(dims.pixeltype),\n        url: this.url,\n      };\n      const worker = new Worker(new URL(\"../workers/FetchTiffWorker\", import.meta.url));\n      worker.onmessage = (e) => {\n        const u8 = e.data.data;\n        const channel = e.data.channel;\n        onData(channel, u8);\n        worker.terminate();\n      };\n      worker.onerror = (e) => {\n        alert(\"Error: Line \" + e.lineno + \" in \" + e.filename + \": \" + e.message);\n      };\n      worker.postMessage(params);\n    }\n\n    return {};\n  }\n}\n\nexport { TiffLoader };\n","import { Box3, Vector2, Vector3 } from \"three\";\n\nimport { ImageInfo } from \"../Volume.js\";\n\nconst MAX_ATLAS_EDGE = 4096;\n\n// Map from units to their symbols\nconst UNIT_SYMBOLS = {\n  angstrom: \"Å\",\n  day: \"d\",\n  foot: \"ft\",\n  hour: \"h\",\n  inch: \"in\",\n  meter: \"m\",\n  mile: \"mi\",\n  minute: \"min\",\n  parsec: \"pc\",\n  second: \"s\",\n  yard: \"yd\",\n};\n\n// Units which may take SI prefixes (e.g. micro-, tera-)\nconst SI_UNITS: (keyof typeof UNIT_SYMBOLS)[] = [\"meter\", \"second\"];\n\n// SI prefixes which abbreviate in nonstandard ways\nconst SI_PREFIX_ABBVS = {\n  micro: \"μ\",\n  deca: \"da\",\n};\n\n/** Converts a full spatial or temporal unit name supported by OME-Zarr to its unit symbol */\n// (see https://ngff.openmicroscopy.org/latest/#axes-md)\nexport function unitNameToSymbol(unitName?: string): string | null {\n  if (unitName === undefined) {\n    return null;\n  }\n\n  if (UNIT_SYMBOLS[unitName]) {\n    return UNIT_SYMBOLS[unitName];\n  }\n\n  const prefixedSIUnit = SI_UNITS.find((siUnit) => unitName.endsWith(siUnit));\n  if (prefixedSIUnit) {\n    const prefix = unitName.substring(0, unitName.length - prefixedSIUnit.length);\n\n    if (SI_PREFIX_ABBVS[prefix]) {\n      // \"special\" SI prefix\n      return SI_PREFIX_ABBVS[prefix] + UNIT_SYMBOLS[prefixedSIUnit];\n    }\n\n    // almost all SI prefixes are abbreviated by first letter, capitalized if prefix ends with \"a\"\n    const capitalize = prefix.endsWith(\"a\");\n    const prefixAbbr = capitalize ? prefix[0].toUpperCase() : prefix[0];\n    return prefixAbbr + UNIT_SYMBOLS[prefixedSIUnit];\n  }\n\n  return null;\n}\n\n// We want to find the most \"square\" packing of z tw by th tiles.\n// Compute number of rows and columns.\nexport function computePackedAtlasDims(z: number, tw: number, th: number): Vector2 {\n  let nextrows = 1;\n  let nextcols = z;\n  let ratio = (nextcols * tw) / (nextrows * th);\n  let nrows = nextrows;\n  let ncols = nextcols;\n  while (ratio > 1) {\n    nrows = nextrows;\n    ncols = nextcols;\n    nextcols -= 1;\n    nextrows = Math.ceil(z / nextcols);\n    ratio = (nextcols * tw) / (nextrows * th);\n  }\n  return new Vector2(nrows, ncols);\n}\n\n/** Picks the largest scale level that can fit into a texture atlas */\nexport function estimateLevelForAtlas(spatialDimsZYX: [number, number, number][], maxAtlasEdge = MAX_ATLAS_EDGE) {\n  if (spatialDimsZYX.length <= 1) {\n    return 0;\n  }\n\n  // update levelToLoad after we get size info about multiscales\n  let levelToLoad = spatialDimsZYX.length - 1;\n  for (let i = 0; i < spatialDimsZYX.length; ++i) {\n    // estimate atlas size:\n    const x = spatialDimsZYX[i][2];\n    const y = spatialDimsZYX[i][1];\n    const z = spatialDimsZYX[i][0];\n    const xtiles = Math.floor(maxAtlasEdge / x);\n    const ytiles = Math.floor(maxAtlasEdge / y);\n\n    if (xtiles * ytiles >= z) {\n      levelToLoad = i;\n      break;\n    }\n  }\n  return levelToLoad;\n}\n\n/** Given the size of a volume in pixels, convert a `Box3` in the 0-1 range to pixels */\nexport function convertSubregionToPixels(region: Box3, size: Vector3): Box3 {\n  const min = region.min.clone().multiply(size).floor();\n  const max = region.max.clone().multiply(size).ceil();\n\n  // ensure it's always valid to specify the same number at both ends and get a single slice\n  if (min.x === max.x && min.x < size.x) {\n    max.x += 1;\n  }\n  if (min.y === max.y && min.y < size.y) {\n    max.y += 1;\n  }\n  if (min.z === max.z && min.z < size.z) {\n    max.z += 1;\n  }\n\n  return new Box3(min, max);\n}\n\n/**\n * Return the subset of `container` specified by `region`, assuming that `region` contains fractional values (between 0\n * and 1). i.e. if `container`'s range on the X axis is 0-4 and `region`'s is 0.25-0.5, the result will have range 1-2.\n */\nexport function composeSubregion(region: Box3, container: Box3): Box3 {\n  const size = container.getSize(new Vector3());\n  const min = region.min.clone().multiply(size).add(container.min);\n  const max = region.max.clone().multiply(size).add(container.min);\n  return new Box3(min, max);\n}\n\nfunction isEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// currently everything needed can come from the imageInfo\n// but in the future each IVolumeLoader could have a completely separate implementation.\nexport function buildDefaultMetadata(imageInfo: ImageInfo): Record<string, unknown> {\n  const physicalSize = imageInfo.volumeSize.clone().multiply(imageInfo.physicalPixelSize);\n  const metadata = {};\n  metadata[\"Dimensions\"] = { ...imageInfo.subregionSize };\n  metadata[\"Original dimensions\"] = { ...imageInfo.originalSize };\n  metadata[\"Physical size\"] = {\n    x: physicalSize.x + imageInfo.spatialUnit,\n    y: physicalSize.y + imageInfo.spatialUnit,\n    z: physicalSize.z + imageInfo.spatialUnit,\n  };\n  metadata[\"Physical size per pixel\"] = {\n    x: imageInfo.physicalPixelSize.x + imageInfo.spatialUnit,\n    y: imageInfo.physicalPixelSize.y + imageInfo.spatialUnit,\n    z: imageInfo.physicalPixelSize.z + imageInfo.spatialUnit,\n  };\n  metadata[\"Channels\"] = imageInfo.numChannels;\n  metadata[\"Time series frames\"] = imageInfo.times || 1;\n  // don't add User data if it's empty\n  if (imageInfo.userData && !isEmpty(imageInfo.userData)) {\n    metadata[\"User data\"] = imageInfo.userData;\n  }\n  return metadata;\n}\n","import { ThreadableVolumeLoader } from \"./IVolumeLoader.js\";\nimport { OMEZarrLoader, type ZarrLoaderFetchOptions } from \"./OmeZarrLoader.js\";\nimport { JsonImageInfoLoader } from \"./JsonImageInfoLoader.js\";\nimport { TiffLoader } from \"./TiffLoader.js\";\nimport VolumeCache from \"../VolumeCache.js\";\nimport SubscribableRequestQueue from \"../utils/SubscribableRequestQueue.js\";\n\nexport { PrefetchDirection } from \"./zarr_utils/types.js\";\n\nexport const enum VolumeFileFormat {\n  ZARR = \"zarr\",\n  JSON = \"json\",\n  TIFF = \"tiff\",\n}\n\nexport type CreateLoaderOptions = {\n  fileType?: VolumeFileFormat;\n  cache?: VolumeCache;\n  queue?: SubscribableRequestQueue;\n  scene?: number;\n  fetchOptions?: ZarrLoaderFetchOptions;\n};\n\nexport function pathToFileType(path: string): VolumeFileFormat {\n  if (path.endsWith(\".json\")) {\n    return VolumeFileFormat.JSON;\n  } else if (path.endsWith(\".tif\") || path.endsWith(\".tiff\")) {\n    return VolumeFileFormat.TIFF;\n  }\n  return VolumeFileFormat.ZARR;\n}\n\nexport async function createVolumeLoader(\n  path: string | string[],\n  options?: CreateLoaderOptions\n): Promise<ThreadableVolumeLoader> {\n  const pathString = Array.isArray(path) ? path[0] : path;\n  const fileType = options?.fileType || pathToFileType(pathString);\n\n  switch (fileType) {\n    case VolumeFileFormat.ZARR:\n      return await OMEZarrLoader.createLoader(\n        path,\n        options?.scene,\n        options?.cache,\n        options?.queue,\n        options?.fetchOptions\n      );\n    case VolumeFileFormat.JSON:\n      return new JsonImageInfoLoader(path, options?.cache);\n    case VolumeFileFormat.TIFF:\n      return new TiffLoader(pathString);\n  }\n}\n","import { PrefetchDirection, TCZYX } from \"./types\";\n\ntype TZYX = [number, number, number, number];\n\ntype PrefetchDirectionState = {\n  direction: PrefetchDirection;\n  chunks: TCZYX<number>[];\n  start: number;\n  end: number;\n};\n\nconst directionToIndex = (dir: PrefetchDirection): number => {\n  const absDir = dir >> 1; // shave off sign bit to get index in TZYX\n  return absDir + Number(absDir !== 0); // convert TZYX -> TCZYX by skipping c (index 1)\n};\n\nfunction updateMinMax(val: number, minmax: [number, number]): void {\n  if (val < minmax[0]) {\n    minmax[0] = val;\n  }\n\n  if (val > minmax[1]) {\n    minmax[1] = val;\n  }\n}\n\n/**\n * Since the user is most likely to want nearby data (in space or time) first, we should prefetch those chunks first.\n *\n * Given a list of just-loaded chunks and some bounds, `ChunkPrefetchIterator` iterates evenly outwards in T/Z/Y/X.\n */\n// NOTE: Assumes `chunks` form a rectangular prism! Will create gaps otherwise! (in practice they always should)\nexport default class ChunkPrefetchIterator {\n  directionStates: PrefetchDirectionState[];\n  priorityDirectionStates: PrefetchDirectionState[];\n\n  constructor(\n    chunks: TCZYX<number>[],\n    tzyxMaxPrefetchOffset: TZYX,\n    tzyxNumChunks: TZYX,\n    priorityDirections?: PrefetchDirection[]\n  ) {\n    // Get min and max chunk coordinates for T/Z/Y/X\n    const extrema: [number, number][] = [\n      [Infinity, -Infinity],\n      [Infinity, -Infinity],\n      [Infinity, -Infinity],\n      [Infinity, -Infinity],\n    ];\n\n    for (const chunk of chunks) {\n      updateMinMax(chunk[0], extrema[0]);\n      updateMinMax(chunk[2], extrema[1]);\n      updateMinMax(chunk[3], extrema[2]);\n      updateMinMax(chunk[4], extrema[3]);\n    }\n\n    // Create `PrefetchDirectionState`s for each direction\n    this.directionStates = [];\n    this.priorityDirectionStates = [];\n\n    for (const [direction, start] of extrema.flat().entries()) {\n      const dimension = direction >> 1;\n      let end: number;\n      if (direction & 1) {\n        // Positive direction - end is either the max coordinate in the fetched set plus the max offset in this\n        // dimension, or the max chunk coordinate in this dimension, whichever comes first\n        end = Math.min(start + tzyxMaxPrefetchOffset[dimension], tzyxNumChunks[dimension] - 1);\n      } else {\n        // Negative direction - end is either the min coordinate in the fetched set minus the max offset in this\n        // dimension, or 0, whichever comes first\n        end = Math.max(start - tzyxMaxPrefetchOffset[dimension], 0);\n      }\n      const directionState = { direction, start, end, chunks: [] };\n\n      if (priorityDirections && priorityDirections.includes(direction)) {\n        this.priorityDirectionStates.push(directionState);\n      } else {\n        this.directionStates.push(directionState);\n      }\n    }\n\n    // Fill each `PrefetchDirectionState` with chunks at the border of the fetched set\n    for (const chunk of chunks) {\n      for (const dir of this.directionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n      for (const dir of this.priorityDirectionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n    }\n  }\n\n  private static *iterateDirections(directions: PrefetchDirectionState[]): Generator<TCZYX<number>> {\n    let offset = 1;\n\n    while (directions.length > 0) {\n      // Remove directions in which we have hit a boundary\n      directions = directions.filter((dir) => {\n        if (dir.direction & 1) {\n          return dir.start + offset <= dir.end;\n        } else {\n          return dir.start - offset >= dir.end;\n        }\n      });\n\n      // Yield chunks one chunk farther out in every remaining direction\n      for (const dir of directions) {\n        for (const chunk of dir.chunks) {\n          const newChunk = chunk.slice() as TCZYX<number>;\n          newChunk[directionToIndex(dir.direction)] += offset * (dir.direction & 1 ? 1 : -1);\n          yield newChunk;\n        }\n      }\n\n      offset += 1;\n    }\n  }\n\n  *[Symbol.iterator](): Iterator<TCZYX<number>> {\n    // Yield all chunks in priority direction(s) first, if any\n    if (this.priorityDirectionStates.length > 0) {\n      for (const chunk of ChunkPrefetchIterator.iterateDirections(this.priorityDirectionStates)) {\n        yield chunk;\n      }\n    }\n\n    // Then yield all chunks in other directions\n    for (const chunk of ChunkPrefetchIterator.iterateDirections(this.directionStates)) {\n      yield chunk;\n    }\n  }\n}\n","import { FetchStore } from \"zarrita\";\nimport { AbsolutePath, AsyncMutable, Readable } from \"@zarrita/storage\";\n\nimport SubscribableRequestQueue from \"../../utils/SubscribableRequestQueue\";\nimport VolumeCache from \"../../VolumeCache\";\n\nimport { SubscriberId } from \"./types\";\n\ntype WrappedStoreOpts<Opts> = {\n  options?: Opts;\n  subscriber: SubscriberId;\n  reportKey?: (key: string, subscriber: SubscriberId) => void;\n  isPrefetch?: boolean;\n};\n\n/**\n * `Readable` is zarrita's minimal abstraction for any source of data.\n * `WrappedStore` wraps another `Readable` and adds (optional) connections to `VolumeCache` and `RequestQueue`.\n */\nclass WrappedStore<Opts, S extends Readable<Opts> = Readable<Opts>> implements AsyncMutable<WrappedStoreOpts<Opts>> {\n  constructor(private baseStore: S, private cache?: VolumeCache, private queue?: SubscribableRequestQueue) {}\n  // Dummy implementation to make this class easier to use in tests\n  set(_key: AbsolutePath, _value: Uint8Array): Promise<void> {\n    return Promise.resolve();\n  }\n\n  private async getAndCache(key: AbsolutePath, cacheKey: string, opts?: Opts): Promise<Uint8Array | undefined> {\n    const result = await this.baseStore.get(key, opts);\n    if (this.cache && result) {\n      this.cache.insert(cacheKey, result);\n    }\n    return result;\n  }\n\n  async get(key: AbsolutePath, opts?: WrappedStoreOpts<Opts> | undefined): Promise<Uint8Array | undefined> {\n    const ZARR_EXTS = [\".zarray\", \".zgroup\", \".zattrs\", \"zarr.json\"];\n    if (!this.cache || ZARR_EXTS.some((s) => key.endsWith(s))) {\n      return this.baseStore.get(key, opts?.options);\n    }\n    if (opts?.reportKey) {\n      opts.reportKey(key, opts.subscriber);\n    }\n\n    let keyPrefix = (this.baseStore as FetchStore).url ?? \"\";\n    if (keyPrefix !== \"\" && !(keyPrefix instanceof URL) && !keyPrefix.endsWith(\"/\")) {\n      keyPrefix += \"/\";\n    }\n\n    const fullKey = keyPrefix + key.slice(1);\n\n    // Check the cache\n    const cacheResult = this.cache.get(fullKey);\n    if (cacheResult) {\n      return new Uint8Array(cacheResult);\n    }\n\n    // Not in cache; load the chunk and cache it\n    if (this.queue && opts) {\n      return this.queue.addRequest(\n        fullKey,\n        opts.subscriber,\n        () => this.getAndCache(key, fullKey, opts?.options),\n        opts.isPrefetch\n      );\n    } else {\n      // Should we ever hit this code?  We should always have a request queue.\n      return this.getAndCache(key, fullKey, opts?.options);\n    }\n  }\n}\n\nexport default WrappedStore;\n","import * as zarr from \"@zarrita/core\";\n\nimport type WrappedStore from \"./WrappedStore.js\";\nimport type SubscribableRequestQueue from \"../../utils/SubscribableRequestQueue.js\";\n\nexport type TCZYX<T> = [T, T, T, T, T];\nexport type SubscriberId = ReturnType<SubscribableRequestQueue[\"addSubscriber\"]>;\n\n/**\n * Directions in which to move outward from the loaded set of chunks while prefetching.\n *\n * Ordered in pairs of opposite directions both because that's a sensible order in which to prefetch for our purposes,\n * and because it lets us treat the least significant bit as the sign. So `direction >> 1` gives the index of the\n * direction in TZYX-ordered arrays, and `direction & 1` gives the sign of the direction (e.g. positive vs negative Z).\n */\nexport const enum PrefetchDirection {\n  T_MINUS = 0,\n  T_PLUS = 1,\n\n  Z_MINUS = 2,\n  Z_PLUS = 3,\n\n  Y_MINUS = 4,\n  Y_PLUS = 5,\n\n  X_MINUS = 6,\n  X_PLUS = 7,\n}\n\nexport type OMECoordinateTransformation =\n  | {\n      type: \"identity\";\n    }\n  | {\n      type: \"translation\";\n      translation: number[];\n    }\n  | {\n      type: \"scale\";\n      scale: number[];\n    }\n  | {\n      type: \"translation\" | \"scale\";\n      path: string;\n    };\n\nexport type OMEAxis = {\n  name: string;\n  type?: string;\n  unit?: string;\n};\n\nexport type OMEDataset = {\n  path: string;\n  coordinateTransformations?: OMECoordinateTransformation[];\n};\n\n// https://ngff.openmicroscopy.org/latest/#multiscale-md\nexport type OMEMultiscale = {\n  version?: string;\n  name?: string;\n  axes: OMEAxis[];\n  datasets: OMEDataset[];\n  coordinateTransformations?: OMECoordinateTransformation[];\n  type?: string;\n  metadata?: Record<string, unknown>;\n};\n\n// https://ngff.openmicroscopy.org/latest/#omero-md\nexport type OmeroTransitionalMetadata = {\n  id: number;\n  name: string;\n  version: string;\n  channels: {\n    active: boolean;\n    coefficient: number;\n    color: string;\n    family: string;\n    inverted: boolean;\n    label: string;\n    window: {\n      end: number;\n      max: number;\n      min: number;\n      start: number;\n    };\n  }[];\n};\n\nexport type OMEZarrMetadata = {\n  multiscales: OMEMultiscale[];\n  omero: OmeroTransitionalMetadata;\n};\n\nexport type NumericZarrArray = zarr.Array<zarr.NumberDataType, WrappedStore<RequestInit>>;\n\n/** A record with everything we need to access and use a single remote source of multiscale OME-Zarr data. */\nexport type ZarrSource = {\n  /** Representations of each scale level in this zarr. We pick one and pass it to zarrita to load data. */\n  scaleLevels: NumericZarrArray[];\n  /**\n   * Zarr dimensions may be ordered in many ways or missing altogether (e.g. TCXYZ, TYX). `axesTCZYX` represents\n   * dimension order as a mapping from dimensions to their indices in dimension-ordered arrays for this source.\n   */\n  axesTCZYX: TCZYX<number>;\n  /** OME-specified metadata record with most useful info on the current image, e.g. sizes, axis order, etc. */\n  multiscaleMetadata: OMEMultiscale;\n  /** OME-specified \"transitional\" metadata record which we mostly ignore, but which gives channel & volume names. */\n  omeroMetadata: OmeroTransitionalMetadata;\n  /** Which channels in the volume come out of this source - i.e. source channel 0 is volume channel `channelOffset` */\n  channelOffset: number;\n};\n","import { Vector3 } from \"three\";\nimport { LoadSpec } from \"../IVolumeLoader.js\";\nimport { estimateLevelForAtlas } from \"../VolumeLoaderUtils.js\";\nimport {\n  NumericZarrArray,\n  OMEAxis,\n  OMECoordinateTransformation,\n  OMEDataset,\n  OMEMultiscale,\n  TCZYX,\n  ZarrSource,\n} from \"./types.js\";\n\n/** Turns `axesTCZYX` into the number of dimensions in the array */\nexport const getDimensionCount = ([t, c, z]: TCZYX<number>) => 2 + Number(t > -1) + Number(c > -1) + Number(z > -1);\n\nexport function remapAxesToTCZYX(axes: OMEAxis[]): TCZYX<number> {\n  const axesTCZYX: TCZYX<number> = [-1, -1, -1, -1, -1];\n  const axisNames = [\"t\", \"c\", \"z\", \"y\", \"x\"];\n\n  axes.forEach((axis, idx) => {\n    const axisIdx = axisNames.indexOf(axis.name);\n    if (axisIdx > -1) {\n      axesTCZYX[axisIdx] = idx;\n    } else {\n      console.error(\"ERROR: UNRECOGNIZED AXIS in zarr: \" + axis.name);\n    }\n  });\n\n  // it is possible that Z might not exist but we require X and Y at least.\n  if (axesTCZYX[3] === -1 || axesTCZYX[4] === -1) {\n    console.error(\"ERROR: zarr loader expects a y and an x axis.\");\n  }\n\n  return axesTCZYX;\n}\n\n/**\n * Picks the best scale level to load based on scale level dimensions, a max atlas size, and a `LoadSpec`.\n * This works like `estimateLevelForAtlas` but factors in `LoadSpec`'s `subregion` property (shrinks the size of the\n * data, maybe enough to allow loading a higher level) and its `multiscaleLevel` property (sets a max scale level).\n */\nexport function pickLevelToLoad(loadSpec: LoadSpec, spatialDimsZYX: [number, number, number][]): number {\n  const size = loadSpec.subregion.getSize(new Vector3());\n  const dims = spatialDimsZYX.map(([z, y, x]): [number, number, number] => [\n    Math.max(z * size.z, 1),\n    Math.max(y * size.y, 1),\n    Math.max(x * size.x, 1),\n  ]);\n\n  const optimalLevel = estimateLevelForAtlas(dims);\n  return Math.max(optimalLevel, loadSpec.multiscaleLevel ?? 0);\n}\n\n/** Reorder an array of values [T, C, Z, Y, X] to the given dimension order */\nexport function orderByDimension<T>(valsTCZYX: TCZYX<T>, orderTCZYX: TCZYX<number>): T[] {\n  const specLen = getDimensionCount(orderTCZYX);\n  const result: T[] = Array(specLen);\n\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= specLen) {\n        throw new Error(\"Unexpected axis index\");\n      }\n      result[val] = valsTCZYX[idx];\n    }\n  });\n\n  return result;\n}\n\n/** Reorder an array of values in the given dimension order to [T, C, Z, Y, X] */\nexport function orderByTCZYX<T>(valsDimension: T[], orderTCZYX: TCZYX<number>, defaultValue: T): TCZYX<T> {\n  const result: TCZYX<T> = [defaultValue, defaultValue, defaultValue, defaultValue, defaultValue];\n\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= valsDimension.length) {\n        throw new Error(\"Unexpected axis index\");\n      }\n      result[idx] = valsDimension[val];\n    }\n  });\n\n  return result;\n}\n\n/** Select the scale transform from an OME metadata object with coordinate transforms, and return it in TCZYX order */\nexport function getScale(dataset: OMEDataset | OMEMultiscale, orderTCZYX: TCZYX<number>): TCZYX<number> {\n  const transforms = dataset.coordinateTransformations;\n\n  if (transforms === undefined) {\n    console.error(\"ERROR: no coordinate transformations for scale level\");\n    return [1, 1, 1, 1, 1];\n  }\n\n  // this assumes we'll never encounter the \"path\" variant\n  const isScaleTransform = (t: OMECoordinateTransformation): t is { type: \"scale\"; scale: number[] } =>\n    t.type === \"scale\";\n\n  // there can be any number of coordinateTransformations\n  // but there must be only one of type \"scale\".\n  const scaleTransform = transforms.find(isScaleTransform);\n  if (!scaleTransform) {\n    console.error(`ERROR: no coordinate transformation of type \"scale\" for scale level`);\n    return [1, 1, 1, 1, 1];\n  }\n\n  const scale = scaleTransform.scale.slice();\n  return orderByTCZYX(scale, orderTCZYX, 1);\n}\n\n/**\n * Defines a partial order of zarr arrays based on their size. Specifically:\n * - If array size x, y, z are all equal, the arrays are equal\n * - otherwise, if all xyz of `a` are less than or equal to those of `b`, `a` is less than `b` (and vice versa)\n * - if some xyz is less and some is greater, the arrays are uncomparable\n */\nfunction compareZarrArraySize(\n  aArr: NumericZarrArray,\n  aTCZYX: TCZYX<number>,\n  bArr: NumericZarrArray,\n  bTCZYX: TCZYX<number>\n): number | undefined {\n  const aZ = aTCZYX[2] > -1 ? aArr.shape[aTCZYX[2]] : 1;\n  const bZ = bTCZYX[2] > -1 ? bArr.shape[bTCZYX[2]] : 1;\n  const diffZ = aZ - bZ;\n  const diffY = aArr.shape[aTCZYX[3]] - bArr.shape[bTCZYX[3]];\n  const diffX = aArr.shape[aTCZYX[4]] - bArr.shape[bTCZYX[4]];\n\n  if (diffZ === 0 && diffY === 0 && diffX === 0) {\n    return 0;\n  } else if (diffZ <= 0 && diffY <= 0 && diffX <= 0) {\n    return -1;\n  } else if (diffZ >= 0 && diffY >= 0 && diffX >= 0) {\n    return 1;\n  } else {\n    return undefined;\n  }\n}\n\nconst EPSILON = 0.0000001;\nconst aboutEquals = (a: number, b: number): boolean => Math.abs(a - b) < EPSILON;\n\nfunction scaleTransformsAreEqual(aSrc: ZarrSource, aLevel: number, bSrc: ZarrSource, bLevel: number): boolean {\n  const aScale = getScale(aSrc.multiscaleMetadata.datasets[aLevel], aSrc.axesTCZYX);\n  const bScale = getScale(bSrc.multiscaleMetadata.datasets[bLevel], bSrc.axesTCZYX);\n  return aboutEquals(aScale[2], bScale[2]) && aboutEquals(aScale[3], bScale[3]) && aboutEquals(aScale[4], bScale[4]);\n}\n\n/**\n * Ensures that all scale levels in `sources` are matched up by size. More precisely: enforces that, for any scale\n * level `i`, the size of zarr array `s[i]` is equal for every source `s`. We accomplish this by removing any arrays\n * (and their associated OME dataset metadata) which don't match up in all sources.\n *\n * Note that this function modifies the input `sources` array rather than returning a new value.\n *\n * Assumes all sources have scale levels ordered by size from largest to smallest. (This should always be true for\n * compliant OME-Zarr data.)\n */\nexport function matchSourceScaleLevels(sources: ZarrSource[]): void {\n  if (sources.length < 2) {\n    return;\n  }\n\n  // Save matching scale levels and metadata here\n  const matchedLevels: NumericZarrArray[][] = Array.from({ length: sources.length }, () => []);\n  const matchedMetas: OMEDataset[][] = Array.from({ length: sources.length }, () => []);\n\n  // Start as many index counters as we have sources\n  const scaleIndexes: number[] = new Array(sources.length).fill(0);\n  while (scaleIndexes.every((val, idx) => val < sources[idx].scaleLevels.length)) {\n    // First pass: find the smallest source / determine if all sources are equal\n    let allEqual = true;\n    let smallestIdx = 0;\n    let smallestSrc = sources[0];\n    let smallestArr = smallestSrc.scaleLevels[scaleIndexes[0]];\n    for (let currentIdx = 1; currentIdx < sources.length; currentIdx++) {\n      const currentSrc = sources[currentIdx];\n      const currentArr = currentSrc.scaleLevels[scaleIndexes[currentIdx]];\n\n      const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n      if (!ordering) {\n        // Arrays are equal, or they are uncomparable\n        if (ordering === undefined) {\n          throw new Error(\"Incompatible zarr arrays: pixel dimensions are mismatched\");\n        }\n        // Now we know the arrays are equal, but they may still be invalid to match up because...\n        // ...they have different scale transformations\n        if (!scaleTransformsAreEqual(smallestSrc, scaleIndexes[smallestIdx], currentSrc, scaleIndexes[currentIdx])) {\n          throw new Error(\"Incompatible zarr arrays: scale levels of equal size have different scale transformations\");\n        }\n        // ...they have different numbers of timesteps\n        const largestT = smallestSrc.axesTCZYX[0] > -1 ? smallestArr.shape[smallestSrc.axesTCZYX[0]] : 1;\n        const currentT = currentSrc.axesTCZYX[0] > -1 ? currentArr.shape[currentSrc.axesTCZYX[0]] : 1;\n        if (largestT !== currentT) {\n          throw new Error(\"Incompatible zarr arrays: different numbers of timesteps\");\n        }\n        // ...they have different chunk sizes (TODO update prefetching so this restriction can be removed)\n        if (!smallestArr.chunks.every((val, idx) => val === currentArr.chunks[idx])) {\n          throw new Error(\"Incompatible zarr arrays: chunk shapes are mismatched\");\n        }\n      } else {\n        allEqual = false;\n        if (ordering > 0) {\n          smallestIdx = currentIdx;\n          smallestSrc = currentSrc;\n          smallestArr = currentArr;\n        }\n      }\n    }\n\n    if (allEqual) {\n      // We've found a matching set of scale levels! Save it and increment all indexes\n      for (let i = 0; i < scaleIndexes.length; i++) {\n        const currentSrc = sources[i];\n        const matchedScaleLevel = scaleIndexes[i];\n        matchedLevels[i].push(currentSrc.scaleLevels[matchedScaleLevel]);\n        matchedMetas[i].push(currentSrc.multiscaleMetadata.datasets[matchedScaleLevel]);\n        scaleIndexes[i] += 1;\n      }\n    } else {\n      // Increment the indexes of the sources which are larger than the smallest\n      for (const [idx, srcIdx] of scaleIndexes.entries()) {\n        const currentSrc = sources[idx];\n        const currentArr = currentSrc.scaleLevels[srcIdx];\n        const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n        if (ordering !== 0) {\n          scaleIndexes[idx] += 1;\n        }\n      }\n    }\n  }\n\n  if (sources[0].scaleLevels.length === 0) {\n    throw new Error(\"Incompatible zarr arrays: no sets of scale levels found that matched in all sources\");\n  }\n\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].scaleLevels = matchedLevels[i];\n    sources[i].multiscaleMetadata.datasets = matchedMetas[i];\n  }\n}\n","/** Object format used when passing multiple requests to RequestQueue at once. */\nexport type Request<V> = {\n  key: string;\n  requestAction: () => Promise<V>;\n};\n\nexport const DEFAULT_REQUEST_CANCEL_REASON = \"request cancelled\";\n\n/**\n * Internal object interface used by RequestQueue to store request metadata and callbacks.\n */\ninterface RequestItem<V> {\n  /** Key used to index this queue item. */\n  key: string;\n  /** Action to be run. */\n  action: () => Promise<V>;\n  /** Reference to the promise object that will be resolved when the action is complete. */\n  promise: Promise<V>;\n  /** Callback used to resolve the promise. */\n  resolve: (value?: V | PromiseLike<V> | undefined) => void;\n  /** Callback used to reject the promise. */\n  reject: (reason?: unknown) => void;\n  /** Optional, used to track timeouts if the item will be added to the queue later. */\n  timeoutId?: ReturnType<typeof setTimeout>;\n}\n\n/**\n * Manages a queue of asynchronous requests with unique string keys, which can be added to or cancelled.\n * If redundant requests with the same key are issued, the request action will only be run once per key\n * while the original request is still in the queue.\n */\nexport default class RequestQueue {\n  /**\n   * The maximum number of requests that can be handled concurrently.\n   * Once reached, additional requests will be queued up to run once a running request completes.\n   */\n  private maxActiveRequests: number;\n\n  /**\n   * The maximum number of requests that can be handled concurrently if only low-priority requests are waiting. Set\n   * lower than `concurrencyLimit` to always leave space for high-priority requests. Cannot be set higher than\n   * `concurrencyLimit`.\n   */\n  private maxLowPriorityRequests: number;\n\n  /** A queue of requests that are ready to be executed, in order of request time. */\n  private queue: string[];\n\n  /** A queue of low-priority tasks that are ready to be executed. `queue` must be empty before any of these tasks run. */\n  private queueLowPriority: string[];\n\n  /** Stores all requests, even those that are currently active. */\n  private allRequests: Map<string, RequestItem<unknown>>;\n\n  /** Stores requests whose actions are currently being run. */\n  private activeRequests: Set<string>;\n\n  /**\n   * Creates a new RequestQueue.\n   * @param maxActiveRequests The maximum number of requests that will be handled concurrently. This is 10 by default.\n   * @param maxLowPriorityRequests The maximum number of low-priority requests that will be handled concurrently. Equal\n   *    to `maxActiveRequests` by default, but may be set lower to always leave space for new high-priority requests.\n   */\n  constructor(maxActiveRequests = 10, maxLowPriorityRequests = 5) {\n    this.allRequests = new Map();\n    this.activeRequests = new Set();\n    this.queue = [];\n    this.queueLowPriority = [];\n    this.maxActiveRequests = maxActiveRequests;\n    this.maxLowPriorityRequests = Math.min(maxActiveRequests, maxLowPriorityRequests);\n  }\n\n  /**\n   * Stores request metadata to the internal map of all pending requests.\n   * @param key string identifier of the request.\n   * @param requestAction callable function action of the request.\n   * @returns a reference to the new, registered RequestItem.\n   */\n  private registerRequest<T>(key: string, requestAction: () => Promise<T>): RequestItem<T> {\n    // Create a new promise and store the resolve and reject callbacks for later.\n    // This lets us perform the actual action at a later point, when the request is at the\n    // front of the processing queue.\n    let promiseResolve, promiseReject;\n    const promise = new Promise<T>((resolve, reject) => {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n    // Store the request data.\n    const requestItem = {\n      key: key,\n      action: requestAction,\n      resolve: promiseResolve,\n      reject: promiseReject,\n      promise,\n    };\n    this.allRequests.set(key, requestItem);\n    return requestItem;\n  }\n\n  /**\n   * Moves a registered request into the processing queue, clearing any timeouts on the request.\n   * @param key string identifier of the request.\n   * @param lowPriority Whether this request should be added with low priority. False by default.\n   */\n  private addRequestToQueue(key: string, lowPriority?: boolean): void {\n    // Check that this request is not cancelled.\n    if (this.allRequests.has(key)) {\n      // Clear the request timeout, if it has one, since it is being added to the queue.\n      const requestItem = this.allRequests.get(key);\n      if (requestItem && requestItem.timeoutId) {\n        clearTimeout(requestItem.timeoutId);\n        requestItem.timeoutId = undefined;\n      }\n      if (!this.queue.includes(key) && !this.queueLowPriority.includes(key)) {\n        // Add to queue and check if the request can be processed right away.\n        if (lowPriority) {\n          this.queueLowPriority.push(key);\n        } else {\n          this.queue.push(key);\n        }\n        this.dequeue();\n      }\n    }\n  }\n\n  /**\n   * Adds a request with a unique key to the queue, if it doesn't already exist.\n   * @param key The key used to track the request.\n   * @param requestAction Function that will be called to complete the request. The function\n   *  will be run only once per unique key while the request exists, and may be deferred by the\n   *  queue at any time.\n   * @param lowPriority Whether this request should be added with low priority. False by default.\n   * @param delayMs Minimum delay, in milliseconds, before this request should be executed.\n   *\n   * NOTE: Cancelling a request while the action is running WILL NOT stop the action. If this behavior is desired,\n   * actions must be responsible for checking the RequestQueue, determining if the request is still valid (e.g.\n   * using `.hasRequest()`), and stopping or returning early.\n   *\n   * @returns A promise that will resolve on completion of the request, or reject if the request is cancelled.\n   *  If multiple requests are issued with the same key, a promise for the first request will be returned\n   *  until the request is resolved or cancelled.\n   *  Note that the return type of the promise will match that of the first request's instance.\n   */\n  public addRequest<T>(key: string, requestAction: () => Promise<T>, lowPriority = false, delayMs = 0): Promise<T> {\n    if (!this.allRequests.has(key)) {\n      // New request!\n      const requestItem = this.registerRequest(key, requestAction);\n      // If a delay is set, wait to add this to the queue.\n      if (delayMs > 0) {\n        const timeoutId = setTimeout(() => this.addRequestToQueue(key, lowPriority), delayMs);\n        // Save timeout information to request metadata\n        requestItem.timeoutId = timeoutId;\n      } else {\n        // No delay, add immediately\n        this.addRequestToQueue(key, lowPriority);\n      }\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1 && !lowPriority) {\n        // This request is registered and queued, but is now being requested with high priority.\n        // Promote it to high priority.\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n        this.addRequestToQueue(key);\n      } else if (delayMs <= 0) {\n        // This request is registered, but is now being requested without a delay.\n        // Move into queue immediately if it's not already added, and clear any timeouts it may have.\n        this.addRequestToQueue(key, lowPriority);\n      }\n    }\n\n    const promise = this.allRequests.get(key)?.promise;\n    if (!promise) {\n      throw new Error(\"Found no promise to return when getting stored request data.\");\n    }\n    return promise as Promise<T>;\n  }\n\n  /**\n   * Adds multiple requests to the queue, with an optional delay between each.\n   * @param requests An array of RequestItems, which include a key and a request action.\n   * @param lowPriority Whether these requests should be added with low priority. False by default.\n   * @param delayMs An optional minimum delay in milliseconds to be added between each request.\n   *  For example, a delay of 10 ms will cause the second request to be added to the processing queue\n   *  after 10 ms, the third to added after 20 ms, and so on. Set to 10 ms by default.\n   * @returns An array of promises corresponding to the provided requests. (i.e., the `i`th value\n   * of the returned array will be a Promise for the resolution of `requests[i]`). If a request\n   *  with a matching key is already pending, returns the promise for the initial request.\n   */\n  public addRequests<T>(requests: Request<T>[], lowPriority = false, delayMs = 10): Promise<unknown>[] {\n    const promises: Promise<unknown>[] = [];\n    for (let i = 0; i < requests.length; i++) {\n      const item = requests[i];\n      const promise = this.addRequest(item.key, item.requestAction, lowPriority, delayMs * i);\n      promises.push(promise);\n    }\n    return promises;\n  }\n\n  /**\n   * Attempts to remove and run the next queued request item, if resources are available.\n   * @returns true if a request was started, or false if there are too many\n   * requests already active.\n   */\n  private async dequeue(): Promise<void> {\n    const numRequests = this.activeRequests.size;\n    if (\n      numRequests >= this.maxActiveRequests ||\n      (this.queue.length === 0 && (numRequests >= this.maxLowPriorityRequests || this.queueLowPriority.length === 0))\n    ) {\n      return;\n    }\n\n    const requestKey = this.queue.shift() ?? this.queueLowPriority.shift();\n    if (!requestKey) {\n      return;\n    }\n    if (this.activeRequests.has(requestKey)) {\n      // This request is already active, try the next one instead. (this shouldn't happen)\n      this.dequeue();\n      return;\n    }\n\n    const requestItem = this.allRequests.get(requestKey);\n    if (!requestItem) {\n      return;\n    }\n\n    const key = requestItem.key;\n    // Mark that this request is active\n    this.activeRequests.add(key);\n\n    await requestItem.action().then(requestItem.resolve, requestItem.reject);\n    this.activeRequests.delete(key);\n    this.allRequests.delete(key);\n    this.dequeue();\n  }\n\n  /**\n   * Removes any request matching the provided key from the queue and rejects its promise.\n   * @param key The key that should be matched against.\n   * @param cancelReason A message or object that will be used as the promise rejection.\n   */\n  public cancelRequest(key: string, cancelReason: unknown = DEFAULT_REQUEST_CANCEL_REASON): void {\n    if (!this.allRequests.has(key)) {\n      return;\n    }\n    const requestItem = this.allRequests.get(key);\n    if (requestItem) {\n      if (requestItem.timeoutId) {\n        // Cancel requests that have not been queued yet.\n        clearTimeout(requestItem.timeoutId);\n      }\n      // Reject the request, then clear from the queue and known requests.\n      requestItem.reject(cancelReason);\n    }\n    const queueIndex = this.queue.indexOf(key);\n    if (queueIndex > -1) {\n      this.queue.splice(queueIndex, 1);\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1) {\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n      }\n    }\n    this.allRequests.delete(key);\n    this.activeRequests.delete(key);\n  }\n\n  /**\n   * Rejects all request promises and clears the queue.\n   * @param cancelReason A message or object that will be used as the promise rejection.\n   */\n  public cancelAllRequests(cancelReason: unknown = DEFAULT_REQUEST_CANCEL_REASON): void {\n    // Clear the queue so we don't do extra work while filtering it\n    this.queue = [];\n    this.queueLowPriority = [];\n    for (const key of this.allRequests.keys()) {\n      this.cancelRequest(key, cancelReason);\n    }\n  }\n\n  /**\n   * Returns whether a request with the given key exists in the RequestQueue and is not cancelled.\n   * @param key the key to search for.\n   * @returns true if the request is in the RequestQueue.\n   */\n  public hasRequest(key: string): boolean {\n    return this.allRequests.has(key);\n  }\n\n  /**\n   * Returns whether the request with the given key is currently running (not waiting in the queue).\n   * @param key the key to search for.\n   * @returns true if the request is actively running.\n   */\n  public requestRunning(key: string): boolean {\n    return this.activeRequests.has(key);\n  }\n}\n","import RequestQueue from \"./RequestQueue.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Resolver = (value?: any) => void;\ntype Rejecter = (reason?: unknown) => void;\n\ntype RequestSubscription = {\n  subscriberId: number;\n  resolve: Resolver;\n  reject: Rejecter;\n};\n\n/**\n * An extension of `RequestQueue` that adds a concept of \"subscribers,\" which may share references to a single request\n * or cancel their subscription without disrupting the request for other subscribers.\n */\nexport default class SubscribableRequestQueue {\n  private queue: RequestQueue;\n\n  /** The next unused subscriber ID. Increments whenever a subscriber is added. */\n  private nextSubscriberId: number;\n  /**\n   * Map of subscribers keyed by ID. Subscribers store a map to all their subscriptions by request key.\n   * Subscribers are only useful as handles to cancel subscriptions early, so we only need to store rejecters here.\n   */\n  private subscribers: Map<number, Map<string, Rejecter>>;\n  /** Map from \"inner\" request (managed by `queue`) to \"outer\" promises generated per-subscriber. */\n  private requests: Map<string, RequestSubscription[]>;\n\n  /**\n   * Since `SubscribableRequestQueue` wraps `RequestQueue`, its constructor may either take the same arguments as the\n   * `RequestQueue` constructor and create a new `RequestQueue`, or it may take an existing `RequestQueue` to wrap.\n   */\n  constructor(maxActiveRequests?: number, maxLowPriorityRequests?: number);\n  constructor(inner: RequestQueue);\n  constructor(maxActiveRequests?: number | RequestQueue, maxLowPriorityRequests?: number) {\n    if (typeof maxActiveRequests === \"number\" || maxActiveRequests === undefined) {\n      this.queue = new RequestQueue(maxActiveRequests, maxLowPriorityRequests);\n    } else {\n      this.queue = maxActiveRequests;\n    }\n    this.nextSubscriberId = 0;\n    this.subscribers = new Map();\n    this.requests = new Map();\n  }\n\n  /** Resolves all subscriptions to request `key` with `value` */\n  private resolveAll<T>(key: string, value: T): void {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const { resolve, subscriberId } of requests) {\n        resolve(value);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Rejects all subscriptions to request `key` with `reason` */\n  private rejectAll(key: string, reason: unknown): void {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const { reject, subscriberId } of requests) {\n        reject(reason);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Adds a new request subscriber. Returns a unique ID to identify this subscriber. */\n  addSubscriber(): number {\n    const subscriberId = this.nextSubscriberId;\n    this.nextSubscriberId++;\n    this.subscribers.set(subscriberId, new Map());\n    return subscriberId;\n  }\n\n  /**\n   * Queues a new request, or adds a subscription if the request is already queued/running.\n   *\n   * If `subscriberId` is already subscribed to the request, this rejects the existing promise and returns a new one.\n   */\n  addRequest<T>(\n    key: string,\n    subscriberId: number,\n    requestAction: () => Promise<T>,\n    lowPriority?: boolean,\n    delayMs?: number\n  ): Promise<T> {\n    // Create single underlying request if it does not yet exist\n    this.queue\n      .addRequest(key, requestAction, lowPriority, delayMs)\n      .then((value) => this.resolveAll(key, value))\n      .catch((reason) => this.rejectAll(key, reason));\n\n    if (!this.requests.has(key)) {\n      this.requests.set(key, []);\n    }\n\n    // Validate subscriber\n    if (subscriberId >= this.nextSubscriberId || subscriberId < 0) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has not been registered`);\n    }\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has been removed`);\n    }\n    const existingRequest = subscriber.get(key);\n    if (existingRequest) {\n      this.rejectSubscription(key, existingRequest, \"SubscribableRequestQueue: request re-queued while running\");\n    }\n\n    // Create promise and add to list of requests\n    return new Promise<T>((resolve, reject) => {\n      this.requests.get(key)?.push({ resolve, reject, subscriberId });\n      this.subscribers.get(subscriberId)?.set(key, reject);\n    });\n  }\n\n  /**\n   * Rejects a subscription and removes it from the list of subscriptions for a request, then cancels the underlying\n   * request if it is no longer subscribed and is not running already.\n   */\n  private rejectSubscription(key: string, reject: Rejecter, cancelReason?: unknown): void {\n    // Reject the outer \"subscription\" promise\n    reject(cancelReason);\n\n    // Get the list of subscriptions for this request\n    const subscriptions = this.requests.get(key);\n    if (!subscriptions) {\n      // This should never happen\n      return;\n    }\n    // Remove this request subscription by ref equality to `reject`\n    const idx = subscriptions.findIndex((sub) => sub.reject === reject);\n    if (idx >= 0) {\n      subscriptions.splice(idx, 1);\n    }\n\n    // Remove the underlying request if there are no more subscribers and the request is not already running\n    if (subscriptions.length < 1 && !this.queue.requestRunning(key)) {\n      this.queue.cancelRequest(key, cancelReason);\n      this.requests.delete(key);\n    }\n  }\n\n  /** Cancels a request subscription, and cancels the underlying request if it is no longer subscribed or running. */\n  cancelRequest(key: string, subscriberId: number, cancelReason?: unknown): boolean {\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      return false;\n    }\n\n    const reject = subscriber.get(key);\n    if (!reject) {\n      return false;\n    }\n\n    this.rejectSubscription(key, reject, cancelReason);\n    subscriber.delete(key);\n    return true;\n  }\n\n  /** Removes a subscriber and cancels its remaining subscriptions. */\n  removeSubscriber(subscriberId: number, cancelReason?: unknown): void {\n    const subscriptions = this.subscribers.get(subscriberId);\n    if (subscriptions) {\n      for (const [key, reject] of subscriptions.entries()) {\n        this.rejectSubscription(key, reject, cancelReason);\n      }\n      this.subscribers.delete(subscriberId);\n    }\n  }\n\n  /** Returns whether a request with the given `key` is running or waiting in the queue */\n  hasRequest(key: string): boolean {\n    return this.queue.hasRequest(key);\n  }\n\n  /** Returns whether a request with the given `key` is running */\n  requestRunning(key: string): boolean {\n    return this.queue.requestRunning(key);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` exists */\n  hasSubscriber(subscriberId: number): boolean {\n    return this.subscribers.has(subscriberId);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` is subscribed to the request with the given `key` */\n  isSubscribed(subscriberId: number, key: string): boolean {\n    return this.subscribers.get(subscriberId)?.has(key) ?? false;\n  }\n}\n","import VolumeCache from \"../VolumeCache.js\";\nimport { VolumeFileFormat, createVolumeLoader, pathToFileType } from \"../loaders/index.js\";\nimport { ThreadableVolumeLoader } from \"../loaders/IVolumeLoader.js\";\nimport RequestQueue from \"../utils/RequestQueue.js\";\nimport SubscribableRequestQueue from \"../utils/SubscribableRequestQueue.js\";\nimport type { WorkerRequest, WorkerRequestPayload, WorkerResponse, WorkerResponsePayload } from \"./types.js\";\nimport { WorkerMsgType, WorkerResponseResult } from \"./types.js\";\nimport { rebuildImageInfo, rebuildLoadSpec } from \"./util.js\";\n\nlet cache: VolumeCache | undefined = undefined;\nlet queue: RequestQueue | undefined = undefined;\nlet subscribableQueue: SubscribableRequestQueue | undefined = undefined;\nlet loader: ThreadableVolumeLoader | undefined = undefined;\nlet initialized = false;\nlet copyOnLoad = false;\n\ntype MessageHandler<T extends WorkerMsgType> = (payload: WorkerRequestPayload<T>) => Promise<WorkerResponsePayload<T>>;\n\nconst messageHandlers: { [T in WorkerMsgType]: MessageHandler<T> } = {\n  [WorkerMsgType.INIT]: ({ maxCacheSize, maxActiveRequests, maxLowPriorityRequests }) => {\n    if (!initialized) {\n      cache = new VolumeCache(maxCacheSize);\n      queue = new RequestQueue(maxActiveRequests, maxLowPriorityRequests);\n      subscribableQueue = new SubscribableRequestQueue(queue);\n      initialized = true;\n    }\n    return Promise.resolve();\n  },\n\n  [WorkerMsgType.CREATE_LOADER]: async ({ path, options }) => {\n    const pathString = Array.isArray(path) ? path[0] : path;\n    const fileType = options?.fileType || pathToFileType(pathString);\n    copyOnLoad = fileType === VolumeFileFormat.JSON;\n    loader = await createVolumeLoader(path, { ...options, cache, queue: subscribableQueue });\n    return loader !== undefined;\n  },\n\n  [WorkerMsgType.CREATE_VOLUME]: async (loadSpec) => {\n    if (loader === undefined) {\n      throw new Error(\"No loader created\");\n    }\n\n    return await loader.createImageInfo(rebuildLoadSpec(loadSpec));\n  },\n\n  [WorkerMsgType.LOAD_DIMS]: async (loadSpec) => {\n    if (loader === undefined) {\n      throw new Error(\"No loader created\");\n    }\n    return await loader.loadDims(rebuildLoadSpec(loadSpec));\n  },\n\n  [WorkerMsgType.LOAD_VOLUME_DATA]: async ({ imageInfo, loadSpec, loaderId, loadId }) => {\n    if (loader === undefined) {\n      throw new Error(\"No loader created\");\n    }\n\n    return await loader.loadRawChannelData(\n      rebuildImageInfo(imageInfo),\n      rebuildLoadSpec(loadSpec),\n      (channelIndex, data, atlasDims) => {\n        const message: WorkerResponse<WorkerMsgType> = {\n          responseResult: WorkerResponseResult.EVENT,\n          loaderId,\n          loadId,\n          channelIndex,\n          data,\n          atlasDims,\n        };\n        const dataTransfers = data.map((d) => d.buffer);\n        (self as unknown as Worker).postMessage(message, copyOnLoad ? [] : dataTransfers);\n      }\n    );\n  },\n\n  [WorkerMsgType.SET_PREFETCH_PRIORITY_DIRECTIONS]: (directions) => {\n    // Silently does nothing if the loader isn't an `OMEZarrLoader`\n    loader?.setPrefetchPriority(directions);\n    return Promise.resolve();\n  },\n\n  [WorkerMsgType.SYNCHRONIZE_MULTICHANNEL_LOADING]: (syncChannels) => {\n    loader?.syncMultichannelLoading(syncChannels);\n    return Promise.resolve();\n  },\n};\n\nself.onmessage = async <T extends WorkerMsgType>({ data }: MessageEvent<WorkerRequest<T>>) => {\n  const { msgId, type, payload } = data;\n  let message: WorkerResponse<T>;\n\n  try {\n    const response = await messageHandlers[type](payload);\n    message = { responseResult: WorkerResponseResult.SUCCESS, msgId, type, payload: response };\n  } catch (e) {\n    message = { responseResult: WorkerResponseResult.ERROR, msgId, type, payload: (e as Error).message };\n  }\n  self.postMessage(message);\n};\n","import type { ImageInfo } from \"../Volume.js\";\nimport type { CreateLoaderOptions, PrefetchDirection } from \"../loaders/index.js\";\nimport type { LoadSpec, LoadedVolumeInfo, VolumeDims } from \"../loaders/IVolumeLoader.js\";\n\n/** The types of requests that can be made to the worker. Mostly corresponds to methods on `IVolumeLoader`. */\nexport const enum WorkerMsgType {\n  INIT,\n  CREATE_LOADER,\n  CREATE_VOLUME,\n  LOAD_DIMS,\n  LOAD_VOLUME_DATA,\n  SET_PREFETCH_PRIORITY_DIRECTIONS,\n  SYNCHRONIZE_MULTICHANNEL_LOADING,\n}\n\n/** The kind of response a worker can return - `SUCCESS`, `ERROR`, or `EVENT`. */\nexport const enum WorkerResponseResult {\n  SUCCESS,\n  ERROR,\n  EVENT,\n}\n\n/** All messages to/from a worker carry a `msgId`, a `type`, and a `payload` (whose type is determined by `type`). */\ntype WorkerMsgBase<T extends WorkerMsgType, P> = {\n  msgId: number;\n  type: T;\n  payload: P;\n};\n\n/** Maps each `WorkerMsgType` to the type of the payload of requests of that type. */\nexport type WorkerRequestPayload<T extends WorkerMsgType> = {\n  [WorkerMsgType.INIT]: {\n    maxCacheSize?: number;\n    maxActiveRequests?: number;\n    maxLowPriorityRequests?: number;\n  };\n  [WorkerMsgType.CREATE_LOADER]: {\n    path: string | string[];\n    options?: CreateLoaderOptions;\n  };\n  [WorkerMsgType.CREATE_VOLUME]: LoadSpec;\n  [WorkerMsgType.LOAD_DIMS]: LoadSpec;\n  [WorkerMsgType.LOAD_VOLUME_DATA]: {\n    imageInfo: ImageInfo;\n    loadSpec: LoadSpec;\n    loaderId: number;\n    loadId: number;\n  };\n  [WorkerMsgType.SET_PREFETCH_PRIORITY_DIRECTIONS]: PrefetchDirection[];\n  [WorkerMsgType.SYNCHRONIZE_MULTICHANNEL_LOADING]: boolean;\n}[T];\n\n/** Maps each `WorkerMsgType` to the type of the payload of responses of that type. */\nexport type WorkerResponsePayload<T extends WorkerMsgType> = {\n  [WorkerMsgType.INIT]: void;\n  [WorkerMsgType.CREATE_LOADER]: boolean;\n  [WorkerMsgType.CREATE_VOLUME]: LoadedVolumeInfo;\n  [WorkerMsgType.LOAD_DIMS]: VolumeDims[];\n  [WorkerMsgType.LOAD_VOLUME_DATA]: Partial<LoadedVolumeInfo>;\n  [WorkerMsgType.SET_PREFETCH_PRIORITY_DIRECTIONS]: void;\n  [WorkerMsgType.SYNCHRONIZE_MULTICHANNEL_LOADING]: void;\n}[T];\n\n/** Currently the only event a loader can produce is a `ChannelLoadEvent` when a batch of channels loads. */\nexport type ChannelLoadEvent = {\n  loaderId: number;\n  loadId: number;\n  channelIndex: number[];\n  data: Uint8Array[];\n  atlasDims?: [number, number];\n};\n\n/** All valid types of worker requests, with some `WorkerMsgType` and a matching payload type. */\nexport type WorkerRequest<T extends WorkerMsgType> = WorkerMsgBase<T, WorkerRequestPayload<T>>;\n/** All valid types of worker responses: `SUCCESS` with a matching payload, `ERROR` with a message, or an `EVENT`. */\nexport type WorkerResponse<T extends WorkerMsgType> =\n  | ({ responseResult: WorkerResponseResult.SUCCESS } & WorkerMsgBase<T, WorkerResponsePayload<T>>)\n  | ({ responseResult: WorkerResponseResult.ERROR } & WorkerMsgBase<T, string>)\n  | ({ responseResult: WorkerResponseResult.EVENT } & ChannelLoadEvent);\n","import { Box3, Vector2, Vector3 } from \"three\";\nimport { LoadSpec } from \"../loaders/IVolumeLoader\";\nimport { ImageInfo } from \"../Volume\";\n\n/** Recreates a `LoadSpec` that has just been sent to/from a worker to restore three.js object prototypes */\nexport function rebuildLoadSpec(spec: LoadSpec): LoadSpec {\n  return {\n    ...spec,\n    subregion: new Box3(new Vector3().copy(spec.subregion.min), new Vector3().copy(spec.subregion.max)),\n  };\n}\n\n/** Recreates an `ImageInfo` that has just been sent to/from a worker to restore three.js object prototypes */\nexport function rebuildImageInfo(imageInfo: ImageInfo): ImageInfo {\n  return {\n    ...imageInfo,\n    originalSize: new Vector3().copy(imageInfo.originalSize),\n    atlasTileDims: new Vector2().copy(imageInfo.atlasTileDims),\n    volumeSize: new Vector3().copy(imageInfo.volumeSize),\n    subregionSize: new Vector3().copy(imageInfo.subregionSize),\n    subregionOffset: new Vector3().copy(imageInfo.subregionOffset),\n    physicalPixelSize: new Vector3().copy(imageInfo.physicalPixelSize),\n    transform: {\n      translation: new Vector3().copy(imageInfo.transform.translation),\n      rotation: new Vector3().copy(imageInfo.transform.rotation),\n    },\n  };\n}\n","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_babel_runtime_regenerator_index_js-node_modules_babel_runtime_helpers_es-31f4f7\",\"vendors-node_modules_babel_runtime_helpers_esm_classCallCheck_js-node_modules_babel_runtime_h-afcf4f\"], () => (__webpack_require__(\"./src/workers/VolumeLoadWorker.ts\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".volume-viewer-ui.bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"src_workers_VolumeLoadWorker_ts\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunk_aics_volume_viewer\"] = self[\"webpackChunk_aics_volume_viewer\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(\"vendors-node_modules_babel_runtime_regenerator_index_js-node_modules_babel_runtime_helpers_es-31f4f7\"),\n\t\t__webpack_require__.e(\"vendors-node_modules_babel_runtime_helpers_esm_classCallCheck_js-node_modules_babel_runtime_h-afcf4f\")\n\t]).then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":["DataTexture","RedFormat","UnsignedByteType","RGBAFormat","LinearFilter","NearestFilter","Histogram","LUT_ARRAY_LENGTH","Channel","name","_classCallCheck","loaded","imgData","data","Uint8ClampedArray","width","height","dataTexture","Uint8Array","lutTexture","minFilter","magFilter","generateMipmaps","volumeData","histogram","dims","lut","fill","colorPalette","colorPaletteAlpha","_createClass","key","value","combineLuts","rgbColor","out","ret","rgb","set","i","image","needsUpdate","getHistogram","getIntensity","x","y","z","getIntensityFromAtlas","numXtiles","tilex","tiley","Math","floor","offset","rebuildDataTexture","w","h","dispose","format","type","setBits","bitsArray","buffer","lutGenerator_auto2","unpackVolumeFromAtlas","volimgdata","atlasrow","tileoffset","tilerowoffset","j","k","setFromVolumeData","vx","vy","vz","ax","ay","packToAtlas","console","log","setLut","setColorPalette","palette","setColorPaletteAlpha","alpha","lutGenerator_windowLevel","wnd","lvl","lutGenerator_fullRange","lutGenerator_dataRange","lutGenerator_bestFit","lutGenerator_auto","lutGenerator_equalize","lutGenerator_percentiles","lo","hi","default","getColorByChannelIndex","clamp","val","cmin","cmax","min","max","controlPointToRGBA","controlPoint","color","opacity","lerp","xmin","xmax","a","LUT_ENTRIES","bins","Uint32Array","dataMin","dataMax","maxBin","length","nonzeroPixelCount","getMin","getMax","b","e","lutGenerator_minMax","tmp","controlPoints","startVal","push","endVal","lutGenerator_labelColors","lastr","lastg","lastb","lasta","r","g","findBinOfPercentile","pct","pixcount","limit","count","pmin","pmax","hmin","hmax","AUTO_THRESHOLD","threshold","PERCENTAGE","th","map","div","lutControlPoints","slope","lastSlope","lastOpacity","round","lutGenerator_fromControlPoints","sort","rgba","c0","c1","color0","color1","lastIndex","Vector2","Vector3","LoadSpec","estimateLevelForAtlas","getDefaultImageInfo","originalSize","atlasTileDims","volumeSize","subregionSize","subregionOffset","physicalPixelSize","spatialUnit","numChannels","channelNames","channelColors","times","timeScale","timeUnit","numMultiscaleLevels","multiscaleLevel","transform","translation","rotation","Volume","imageInfo","arguments","undefined","loadSpec","loader","_objectSpread","channels","Array","from","_val","idx","loadSpecRequired","slice","subregion","clone","imageMetadata","normRegionSize","normRegionOffset","physicalSize","physicalScale","normPhysicalSize","tickMarkPhysicalLength","setVoxelSize","channelColorsDefault","index","channel","toArray","physicalUnitSymbol","volumeDataObservers","setUnloaded","forEach","isLoaded","updateDimensions","_this$imageInfo","divide","_updateRequiredData","_asyncToGenerator","_regeneratorRuntime","mark","_callee","required","onChannelLoaded","_this","noReload","_this$loadSpec$multis","_this$loader","currentScale","minLevel","loadableLevel","_this$loader2","wrap","_callee$","_context","prev","next","time","containsBox","every","includes","equals","loadDims","sent","_ref","shape","loadVolumeData","stop","updateRequiredData","_x","_x2","apply","size","multiply","divideScalar","pow","log10","setUnitSymbol","symbol","getContentCenter","add","subScalar","cleanup","getChannel","channelIndex","batch","_this2","_this2$channelLoadCal","channelLoadCallback","call","observer","onVolumeData","setChannelDataFromAtlas","atlasdata","atlaswidth","atlasheight","_this$imageInfo$subre","setChannelDataFromVolume","_this$imageInfo2","appendEmptyChannel","chname","chcolor","onVolumeChannelAdded","c","getRotation","getTranslation","voxelsToWorldSpace","xyz","m","fromArray","multiplyScalar","addVolumeDataObserver","o","removeVolumeDataObserver","indexOf","splice","removeAllVolumeDataObservers","CACHE_MAX_SIZE_DEFAULT","VolumeCache","maxSize","entries","Map","currentSize","first","last","get","removeEntryFromStore","entry","byteLength","removeEntryFromList","addEntryAsFirst","moveEntryToFirst","evictLast","error","evict","insert","getResult","getEntry","newEntry","result","_this$getEntry","clearWithPrefix","prefix","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","startsWith","err","f","clear","defaultColors","HSVtoRGB","v","hh","hsv","p","q","t","LCG","imul","myrand","Box3","buildDefaultMetadata","_defineProperty","loadSpecToString","spec","_spec$subregion","concat","VolumeDims","ThreadableVolumeLoader","setPrefetchPriority","_directions","syncMultichannelLoading","_sync","_createVolume","_yield$this$createIma","adjustedLoadSpec","vol","createImageInfo","abrupt","createVolume","_loadVolumeData","_callee2","volume","loadSpecOverride","onChannelData","_yield$this$loadRawCh","_callee2$","_context2","channelIndices","dataArrays","atlasDims","loadRawChannelData","_x3","_x4","_x5","convertImageInfo","json","_json$transform","_json$transform2","tiles","cols","rows","tile_width","tile_height","pixel_size_x","pixel_size_y","pixel_size_z","pixel_size_unit","channel_names","channel_colors","time_scale","time_unit","userData","JsonImageInfoLoader","_ThreadableVolumeLoad","_inherits","urls","cache","_callSuper","isArray","jsonInfo","_getJsonImageInfo","cachedInfo","response","fetch","getJsonImageInfo","_loadDims","d","spacing","spaceUnit","dataType","_createImageInfo","_callee3","_callee3$","_context3","_loadRawChannelData","_callee4","onData","images","requestedChannels","urlPrefix","wrappedOnData","_callee4$","_context4","filter","some","ch","replace","element","loadVolumeAtlasData","flatMap","_ref2","_x6","imageArray","_ref3","_callee5","cacheHit","chindex","cacheResult","blob","bitmap","canvas","ctx","iData","channelsBits","_j","px","_ch","_chindex","_callee5$","_context5","mode","createImageBitmap","OffscreenCanvas","getContext","globalCompositeOperation","globalAlpha","drawImage","getImageData","_x7","zarr","zarrGet","FetchStore","SubscribableRequestQueue","composeSubregion","computePackedAtlasDims","convertSubregionToPixels","unitNameToSymbol","ChunkPrefetchIterator","WrappedStore","getDimensionCount","getScale","matchSourceScaleLevels","orderByDimension","orderByTCZYX","pickLevelToLoad","remapAxesToTCZYX","CHUNK_REQUEST_CANCEL_REASON","convertChannel","channelData","u8","range","DEFAULT_FETCH_OPTIONS","maxPrefetchDistance","maxPrefetchChunks","OMEZarrLoader","sources","requestQueue","fetchOptions","priorityDirections","_assertThisInitialized","getUnitSymbols","source","xi","axesTCZYX","spaceUnitName","multiscaleMetadata","axes","unit","spaceUnitSymbol","ti","timeUnitName","timeUnitSymbol","getLevelShapesZYX","_source$axesTCZYX$sli","_source$axesTCZYX$sli2","scaleLevels","level","datasets","valsTCZYX","sourceIdx","valsDimension","defaultValue","matchChannelToSource","absoluteChannelIndex","lastSrcIdx","lastSrc","lastSrcNumChannels","channelOffset","Error","firstGreaterIdx","findIndex","src","sourceIndex","channelIndexInSource","directions","sync","syncChannels","_this$maxExtent","_this$getUnitSymbols","_this$getUnitSymbols2","maxExtent","regionSize","getSize","regionArr","scale","ceil","Promise","resolve","source0","_source0$axesTCZYX","hasT","hasZ","shape0","levelToLoad","shapeLv","_this$getUnitSymbols3","_this$getUnitSymbols4","sourceLast","cLast","lastHasC","pxDims0","pxSize0","pxDimsLv","pxSizeLv","channelNamesMap","omeroMetadata","numMatchingChannels","label","scale5d","imgdata","fullExtentLoadSpec","_prefetchChunk","scaleLevel","coords","subscriber","store","path","separator","endsWith","join","isPrefetch","t0","prefetchChunk","beginPrefetch","keys","_this3","chunkCoords","numDims","coordsInDimensionOrder","trim","split","parseInt","sourceCoords","source0Shape","chunkDimsUnordered","dim","chunks","chunkDims","addSubscriber","chunkDimsTZYX","prefetchIterator","prefetchCount","chunk","_this$matchChannelToS","sourceScaleLevel","prefetchSubscriber","removeSubscriber","updateImageInfoForLoad","_this$maxExtent2","array0Shape","_this$sources$0$axesT","_this$sources$0$axesT2","regionPx","volumeExtent","_loadSpec$channels","_this4","updatedImageInfo","channelIndexes","_","reportKeyBase","sub","resultChannelIndices","resultChannelData","channelPromises","_this4$matchChannelTo","sourceCh","unorderedSpec","sliceSpec","reportKey","opts","loadSubscriber","all","then","_createLoader","scenes","queue","urlsArr","scenesArr","sourceProms","channelCount","_iterator2","_step2","priorityDirs","_args4","concurrencyLimit","prefetchConcurrencyLimit","_ref4","url","root","group","_ref5","multiscales","omero","scene","lvlProms","open","kind","attrs","warn","_ref6","createLoader","fromUrl","prepareXML","xml","expr","getOME","parser","DOMParser","xmlDoc","parseFromString","omeEl","getElementsByTagName","OMEDims","getOMEDims","imageEl","pixelsEl","sizex","Number","getAttribute","sizey","sizez","sizec","sizet","pixeltype","dimensionorder","pixelsizex","pixelsizey","pixelsizez","channelsEls","id","channelnames","getBytesPerSample","TiffLoader","_loadOmeDims","tiff","tiffimgdesc","image0El","allowFullFile","getImage","getFileDirectory","ImageDescription","loadOmeDims","_loadSpec","targetSize","tilesizex","tilesizey","_loop","params","worker","_loop$","dimensionOrder","bytesPerSample","Worker","URL","import","meta","onmessage","terminate","onerror","alert","lineno","filename","message","postMessage","delegateYield","MAX_ATLAS_EDGE","UNIT_SYMBOLS","angstrom","day","foot","hour","inch","meter","mile","minute","parsec","second","yard","SI_UNITS","SI_PREFIX_ABBVS","micro","deca","unitName","prefixedSIUnit","find","siUnit","substring","capitalize","prefixAbbr","toUpperCase","tw","nextrows","nextcols","ratio","nrows","ncols","spatialDimsZYX","maxAtlasEdge","xtiles","ytiles","region","container","isEmpty","obj","Object","prototype","hasOwnProperty","metadata","PrefetchDirection","VolumeFileFormat","pathToFileType","JSON","TIFF","ZARR","createVolumeLoader","_createVolumeLoader","options","pathString","fileType","directionToIndex","dir","absDir","updateMinMax","minmax","_Symbol$iterator","tzyxMaxPrefetchOffset","tzyxNumChunks","extrema","Infinity","directionStates","priorityDirectionStates","flat","_step2$value","direction","start","dimension","end","directionState","_iterator3","_step3","_iterator4","_step4","_iterator5","_step5","_iterator6","_step6","_iterator7","_step7","_chunk2","value$","iterateDirections","finish","t1","_iterator8","_step8","_iterator9","_step9","newChunk","iterateDirections$","Symbol","iterator","baseStore","_key","_value","_getAndCache","cacheKey","getAndCache","_get","_url","ZARR_EXTS","keyPrefix","fullKey","addRequest","axisNames","axis","axisIdx","_loadSpec$multiscaleL","optimalLevel","orderTCZYX","specLen","dataset","transforms","coordinateTransformations","isScaleTransform","scaleTransform","compareZarrArraySize","aArr","aTCZYX","bArr","bTCZYX","aZ","bZ","diffZ","diffY","diffX","EPSILON","aboutEquals","abs","scaleTransformsAreEqual","aSrc","aLevel","bSrc","bLevel","aScale","bScale","matchedLevels","matchedMetas","scaleIndexes","allEqual","smallestIdx","smallestSrc","smallestArr","currentSrc","currentIdx","currentArr","ordering","largestT","currentT","matchedScaleLevel","srcIdx","DEFAULT_REQUEST_CANCEL_REASON","RequestQueue","maxActiveRequests","maxLowPriorityRequests","allRequests","activeRequests","Set","queueLowPriority","registerRequest","requestAction","promiseResolve","promiseReject","promise","reject","requestItem","action","addRequestToQueue","lowPriority","has","timeoutId","clearTimeout","dequeue","_this$allRequests$get","delayMs","setTimeout","lowPriorityIndex","addRequests","requests","promises","item","_dequeue","_this$queue$shift","numRequests","requestKey","shift","cancelRequest","cancelReason","queueIndex","cancelAllRequests","hasRequest","requestRunning","nextSubscriberId","subscribers","resolveAll","_this$subscribers$get","subscriberId","rejectAll","reason","_this$subscribers$get2","existingRequest","rejectSubscription","_this$requests$get","_this$subscribers$get3","subscriptions","_step3$value","hasSubscriber","isSubscribed","_this$subscribers$get4","_this$subscribers$get5","WorkerMsgType","WorkerResponseResult","rebuildImageInfo","rebuildLoadSpec","subscribableQueue","initialized","copyOnLoad","messageHandlers","INIT","maxCacheSize","CREATE_LOADER","CREATE_VOLUME","LOAD_DIMS","LOAD_VOLUME_DATA","_ref7","loaderId","loadId","responseResult","EVENT","dataTransfers","self","SET_PREFETCH_PRIORITY_DIRECTIONS","_loader","SYNCHRONIZE_MULTICHANNEL_LOADING","_loader2","_ref9","_ref8","msgId","payload","SUCCESS","ERROR","copy"],"sourceRoot":""}