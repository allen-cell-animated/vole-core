{"version":3,"file":"src_workers_VolumeLoadWorker_ts.volume-viewer-ui.bundle.js","mappings":";;;;;;;;;;;;;;;;;;AAmBe;AACwB;AACU;AACuB;AAWxE;AACe,MAAMoB,OAAO,CAAC;EAgB3BC,WAAWA,CAACC,IAAY,EAAE;IACxB,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,IAAI,CAACC,KAAK,GAAG,OAAO;IACpB,IAAI,CAACC,OAAO,GAAG;MAAEC,IAAI,EAAE,IAAIC,UAAU,CAAC,CAAC;MAAEC,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAE,CAAC;IAC9D,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,MAAM,GAAG,GAAG;;IAEjB;IACA,IAAI,CAACC,WAAW,GAAG,IAAIhC,8CAAW,CAAC,IAAI2B,UAAU,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC1D,IAAI,CAACM,UAAU,GAAG,IAAIjC,8CAAW,CAAC,IAAI2B,UAAU,CAACT,qDAAgB,CAAC,EAAE,GAAG,EAAE,CAAC,EAAEP,6CAAU,EAAEP,mDAAgB,CAAC;IACzG,IAAI,CAAC6B,UAAU,CAACC,SAAS,GAAG,IAAI,CAACD,UAAU,CAACE,SAAS,GAAGvB,+CAAY;IACpE,IAAI,CAACqB,UAAU,CAACG,eAAe,GAAG,KAAK;IAEvC,IAAI,CAACC,UAAU,GAAG,IAAIV,UAAU,CAAC,CAAC;IAClC,IAAI,CAACL,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACgB,SAAS,GAAG,IAAItB,qDAAS,CAAC,IAAIW,UAAU,CAAC,CAAC,CAAC;IAChD,IAAI,CAACY,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAErB;IACA,IAAI,CAACC,GAAG,GAAG,IAAIvB,wCAAG,CAAC,CAAC,CAACwB,gBAAgB,CAAC,CAAC,EAAE,GAAG,CAAC;;IAE7C;IACA,IAAI,CAACC,YAAY,GAAG,IAAIf,UAAU,CAACT,qDAAgB,CAAC,CAACyB,IAAI,CAAC,CAAC,CAAC;IAC5D;IACA,IAAI,CAACC,iBAAiB,GAAG,GAAG;EAC9B;;EAEA;EACOC,WAAWA,CAACC,QAA2C,EAAEC,GAAgB,EAAc;IAC5F,MAAMC,GAAG,GAAGD,GAAG,GAAGA,GAAG,GAAG,IAAIpB,UAAU,CAACT,qDAAgB,CAAC;IACxD,IAAI,CAAC4B,QAAQ,EAAE;MACb,OAAOE,GAAG;IACZ;IACA,MAAMC,GAAG,GAAG,CAACH,QAAQ,CAAC,CAAC,CAAC,GAAG,KAAK,EAAEA,QAAQ,CAAC,CAAC,CAAC,GAAG,KAAK,EAAEA,QAAQ,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;IAC3E;IACA;IACA,IAAI,IAAI,CAACF,iBAAiB,KAAK,GAAG,EAAE;MAClCI,GAAG,CAACE,GAAG,CAAC,IAAI,CAACR,YAAY,CAAC;IAC5B,CAAC,MAAM,IAAI,IAAI,CAACE,iBAAiB,KAAK,GAAG,EAAE;MACzCI,GAAG,CAACE,GAAG,CAAC,IAAI,CAACV,GAAG,CAACA,GAAG,CAAC;MACrB,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjC,qDAAgB,GAAG,CAAC,EAAE,EAAEiC,CAAC,EAAE;QAC7CH,GAAG,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIF,GAAG,CAAC,CAAC,CAAC;QACxBD,GAAG,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIF,GAAG,CAAC,CAAC,CAAC;QACxBD,GAAG,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIF,GAAG,CAAC,CAAC,CAAC;MAC1B;IACF,CAAC,MAAM;MACL,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjC,qDAAgB,GAAG,CAAC,EAAE,EAAEiC,CAAC,EAAE;QAC7CH,GAAG,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GACZ,IAAI,CAACT,YAAY,CAACS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACP,iBAAiB,GACrD,IAAI,CAACJ,GAAG,CAACA,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,IAAI,CAACP,iBAAiB,CAAC,GAAGK,GAAG,CAAC,CAAC,CAAC;QACnED,GAAG,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GACZ,IAAI,CAACT,YAAY,CAACS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACP,iBAAiB,GACrD,IAAI,CAACJ,GAAG,CAACA,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,IAAI,CAACP,iBAAiB,CAAC,GAAGK,GAAG,CAAC,CAAC,CAAC;QACnED,GAAG,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GACZ,IAAI,CAACT,YAAY,CAACS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACP,iBAAiB,GACrD,IAAI,CAACJ,GAAG,CAACA,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,IAAI,CAACP,iBAAiB,CAAC,GAAGK,GAAG,CAAC,CAAC,CAAC;QACnED,GAAG,CAACG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GACZ,IAAI,CAACT,YAAY,CAACS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACP,iBAAiB,GACrD,IAAI,CAACJ,GAAG,CAACA,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,IAAI,CAACP,iBAAiB,CAAC;MAC5D;IACF;IAEA,IAAI,CAACX,UAAU,CAACmB,KAAK,CAAC1B,IAAI,CAACwB,GAAG,CAACF,GAAG,CAAC;IACnC,IAAI,CAACf,UAAU,CAACoB,WAAW,GAAG,IAAI;IAElC,OAAOL,GAAG;EACZ;EAEOM,eAAeA,CAACC,GAAW,EAAEC,GAAW,EAAQ;IACrD;IACA;IACA;IACA;IACA,IAAI,EAAE,IAAI,CAAC1B,MAAM,KAAK,CAAC,IAAI,IAAI,CAACC,MAAM,KAAK,CAAC,CAAC,IAAI,EAAEwB,GAAG,KAAK,CAAC,IAAIC,GAAG,KAAK,CAAC,CAAC,EAAE;MAC1E,IAAI,CAAChB,GAAG,CAACiB,YAAY,CAAC,IAAI,CAAC3B,MAAM,EAAE,IAAI,CAACC,MAAM,EAAEwB,GAAG,EAAEC,GAAG,CAAC;MACzD,IAAI,CAAC1B,MAAM,GAAGyB,GAAG;MACjB,IAAI,CAACxB,MAAM,GAAGyB,GAAG;IACnB;EACF;EAEOE,YAAYA,CAAA,EAAc;IAC/B,OAAO,IAAI,CAACpB,SAAS;EACvB;EAEOqB,YAAYA,CAACC,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAU;IAC3D,OAAO,IAAI,CAACzB,UAAU,CAACuB,CAAC,GAAGC,CAAC,GAAG,IAAI,CAACtB,IAAI,CAAC,CAAC,CAAC,GAAGuB,CAAC,IAAI,IAAI,CAACvB,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;EAClF;EAEOwB,YAAYA,CAACC,GAAW,EAAU;IACvC,OAAO,CAACA,GAAG,GAAG,IAAI,CAAClC,MAAM,KAAK,IAAI,CAACC,MAAM,GAAG,IAAI,CAACD,MAAM,CAAC;EAC1D;;EAEA;EACOmC,qBAAqBA,CAACL,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAU;IACpE,MAAMI,SAAS,GAAG,IAAI,CAACzC,OAAO,CAACG,KAAK,GAAG,IAAI,CAACW,IAAI,CAAC,CAAC,CAAC;IACnD,MAAM4B,KAAK,GAAGL,CAAC,GAAGI,SAAS;IAC3B,MAAME,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACR,CAAC,GAAGI,SAAS,CAAC;IACvC,MAAMK,MAAM,GAAGJ,KAAK,GAAG,IAAI,CAAC5B,IAAI,CAAC,CAAC,CAAC,GAAGqB,CAAC,GAAG,CAACQ,KAAK,GAAG,IAAI,CAAC7B,IAAI,CAAC,CAAC,CAAC,GAAGsB,CAAC,IAAI,IAAI,CAACpC,OAAO,CAACG,KAAK;IACzF,OAAO,IAAI,CAACH,OAAO,CAACC,IAAI,CAAC6C,MAAM,CAAC;EAClC;EAEQC,kBAAkBA,CAAC9C,IAA4B,EAAE+C,CAAS,EAAEC,CAAS,EAAQ;IACnF,IAAI,IAAI,CAAC1C,WAAW,EAAE;MACpB,IAAI,CAACA,WAAW,CAAC2C,OAAO,CAAC,CAAC;IAC5B;IACA,IAAIC,MAAM,GAAG3E,kDAAe;IAC5B,IAAI4E,QAAQ,GAAGzE,mDAAgB;IAC/B,IAAI0E,cAA8B,GAAG,WAAW;IAChD,QAAQ,IAAI,CAACtD,KAAK;MAChB,KAAK,OAAO;QACVqD,QAAQ,GAAGzE,mDAAgB;QAC3BwE,MAAM,GAAGzE,mDAAgB;QACzB2E,cAAc,GAAG,MAAM;QACvB;MACF,KAAK,MAAM;QACTD,QAAQ,GAAGxE,2CAAQ;QACnBuE,MAAM,GAAGzE,mDAAgB;QACzB2E,cAAc,GAAG,KAAK;QACtB;MACF,KAAK,QAAQ;QACXD,QAAQ,GAAGnE,oDAAiB;QAC5BkE,MAAM,GAAGzE,mDAAgB;QACzB2E,cAAc,GAAG,OAAO;QACxB;MACF,KAAK,OAAO;QACVD,QAAQ,GAAGpE,4CAAS;QACpBmE,MAAM,GAAGzE,mDAAgB;QACzB2E,cAAc,GAAG,MAAM;QACvB;MACF,KAAK,QAAQ;QACXD,QAAQ,GAAGrE,kDAAe;QAC1BoE,MAAM,GAAGzE,mDAAgB;QACzB2E,cAAc,GAAG,OAAO;QACxB;MACF,KAAK,OAAO;QACVD,QAAQ,GAAGtE,0CAAO;QAClBqE,MAAM,GAAGzE,mDAAgB;QACzB2E,cAAc,GAAG,MAAM;QACvB;MACF,KAAK,SAAS;QACZD,QAAQ,GAAGvE,4CAAS;QACpBsE,MAAM,GAAG1E,4CAAS;QAClB4E,cAAc,GAAG,MAAM;QACvB;MACF;QACEC,OAAO,CAACC,IAAI,CAAC,oCAAoC,EAAE,IAAI,CAACxD,KAAK,CAAC;QAC9D;IACJ;IAEA,IAAI,CAACQ,WAAW,GAAG,IAAIhC,8CAAW,CAChC0B,IAAI,EACJ+C,CAAC,EACDC,CAAC,EACDE,MAAM,EACNC,QAAQ,EACR/D,4CAAS,EACTC,sDAAmB,EACnBA,sDAAmB,EACnBF,gDAAa,EACbA,gDACF,CAAC;IACD,IAAI,CAACmB,WAAW,CAAC8C,cAAc,GAAGA,cAAc;IAChD,IAAI,CAAC9C,WAAW,CAACqB,WAAW,GAAG,IAAI;EACrC;;EAEA;EACA;EACO4B,YAAYA,CACjBC,SAAiC,EACjCT,CAAS,EACTC,CAAS,EACTlD,KAAiB,EACjBM,MAAc,EACdC,MAAc,EACdoD,aAAsB,EAChB;IACN,IAAI,CAAC3D,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,OAAO,GAAG;MAAEC,IAAI,EAAEwD,SAAS;MAAEtD,KAAK,EAAE6C,CAAC;MAAE5C,MAAM,EAAE6C;IAAE,CAAC;IAEvD,IAAI,CAACF,kBAAkB,CAAC,IAAI,CAAC/C,OAAO,CAACC,IAAI,EAAE+C,CAAC,EAAEC,CAAC,CAAC;IAEhD,IAAI,CAACnD,MAAM,GAAG,IAAI;IAClB,IAAI,CAACe,SAAS,GAAG,IAAItB,qDAAS,CAACkE,SAAS,CAAC;;IAEzC;IACA,IAAI,CAAC5B,eAAe,CAACxB,MAAM,EAAEC,MAAM,CAAC;IAEpC,IAAI,CAACqD,eAAe,CAACD,aAAa,CAACvB,CAAC,EAAEuB,aAAa,CAACtB,CAAC,EAAEsB,aAAa,CAACrB,CAAC,CAAC;EACzE;;EAEA;EACA;EACA;EACA;EACQsB,eAAeA,CAACxB,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAQ;IAC7D,MAAMuB,UAAU,GAAG,IAAI,CAAC5D,OAAO,CAACC,IAAI;IAEpC,IAAI,CAACa,IAAI,GAAG,CAACqB,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;IACrB,MAAMwB,IAAI,GAAGnE,yDAAkB,CAAC,IAAI,CAACK,KAAK,CAAC;IAC3C,IAAI,CAACa,UAAU,GAAG,IAAIiD,IAAI,CAAC1B,CAAC,GAAGC,CAAC,GAAGC,CAAC,CAAC;IAErC,MAAMI,SAAS,GAAG,IAAI,CAACzC,OAAO,CAACG,KAAK,GAAGgC,CAAC;IACxC,MAAM2B,QAAQ,GAAG,IAAI,CAAC9D,OAAO,CAACG,KAAK;IACnC,IAAIuC,KAAK,GAAG,CAAC;MACXC,KAAK,GAAG,CAAC;MACToB,UAAU,GAAG,CAAC;MACdC,aAAa,GAAG,CAAC;MACjBC,UAAU,GAAG,CAAC;IAChB,KAAK,IAAIvC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,CAAC,EAAE,EAAEX,CAAC,EAAE;MAC1B;MACAgB,KAAK,GAAGhB,CAAC,GAAGe,SAAS;MACrBE,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACnB,CAAC,GAAGe,SAAS,CAAC;MACjCsB,UAAU,GAAGrB,KAAK,GAAGP,CAAC,GAAGQ,KAAK,GAAGP,CAAC,GAAG0B,QAAQ;MAC7C,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,CAAC,EAAE,EAAE8B,CAAC,EAAE;QAC1BF,aAAa,GAAGE,CAAC,GAAGJ,QAAQ;QAC5BG,UAAU,GAAGvC,CAAC,IAAIS,CAAC,GAAGC,CAAC,CAAC,GAAG8B,CAAC,GAAG/B,CAAC;QAChC,IAAI,CAACvB,UAAU,CAACa,GAAG,CACjBmC,UAAU,CAACO,QAAQ,CAACJ,UAAU,GAAGC,aAAa,EAAED,UAAU,GAAGC,aAAa,GAAG7B,CAAC,CAAC,EAC/E8B,UACF,CAAC;MACH;IACF;EACF;;EAEA;EACOG,iBAAiBA,CACtBX,SAAiC,EACjCY,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVpE,MAAc,EACdC,MAAc,EACdP,KAAiB,EACX;IACN,IAAI,CAACe,IAAI,GAAG,CAACuD,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACxB,IAAI,CAAC3D,UAAU,GAAG6C,SAAS;IAC3B,IAAI,CAAC1D,KAAK,GAAGA,KAAK;IAClB;IACA,IAAI,CAAC2E,WAAW,CAACL,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACpC,IAAI,CAAC3E,MAAM,GAAG,IAAI;IAClB;IACA,IAAI,CAAC+B,eAAe,CAACxB,MAAM,EAAEC,MAAM,CAAC;IACpC,IAAI,CAACO,SAAS,GAAG,IAAItB,qDAAS,CAAC,IAAI,CAACqB,UAAU,CAAC;EACjD;;EAEA;EACQ8D,WAAWA,CAACL,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAQ;IACpF;IACA;IACA;IACA;IACA;IACA;IACA,IAAID,EAAE,GAAGH,EAAE,KAAK,CAAC,IAAII,EAAE,GAAGH,EAAE,KAAK,CAAC,IAAKE,EAAE,GAAGH,EAAE,IAAKI,EAAE,GAAGH,EAAE,CAAC,GAAGC,EAAE,EAAE;MAChEjB,OAAO,CAACqB,GAAG,CAAC,gDAAgD,CAAC;MAC7DrB,OAAO,CAACqB,GAAG,CAACH,EAAE,EAAEC,EAAE,EAAEJ,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;IACjC;IAEA,MAAMV,IAAI,GAAGnE,yDAAkB,CAAC,IAAI,CAACK,KAAK,CAAC;IAC3C,IAAI,CAACC,OAAO,GAAG;MACbG,KAAK,EAAEqE,EAAE;MACTpE,MAAM,EAAEqE,EAAE;MACVxE,IAAI,EAAE,IAAI4D,IAAI,CAACW,EAAE,GAAGC,EAAE;IACxB,CAAC;IACD,IAAI,CAACzE,OAAO,CAACC,IAAI,CAACiB,IAAI,CAAC,CAAC,CAAC;;IAEzB;IACA,MAAM0C,UAAU,GAAG,IAAI,CAAC5D,OAAO,CAACC,IAAI;IAEpC,MAAMkC,CAAC,GAAGkC,EAAE;MACVjC,CAAC,GAAGkC,EAAE;MACNjC,CAAC,GAAGkC,EAAE;IAER,MAAM9B,SAAS,GAAG,IAAI,CAACzC,OAAO,CAACG,KAAK,GAAGgC,CAAC;IACxC,MAAM2B,QAAQ,GAAG,IAAI,CAAC9D,OAAO,CAACG,KAAK;IACnC,IAAIuC,KAAK,GAAG,CAAC;MACXC,KAAK,GAAG,CAAC;MACToB,UAAU,GAAG,CAAC;MACdC,aAAa,GAAG,CAAC;MACjBY,YAAY,GAAG,CAAC;IAClB,KAAK,IAAIlD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,CAAC,EAAE,EAAEX,CAAC,EAAE;MAC1B;MACAgB,KAAK,GAAGhB,CAAC,GAAGe,SAAS;MACrBE,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACnB,CAAC,GAAGe,SAAS,CAAC;MACjCsB,UAAU,GAAGrB,KAAK,GAAGP,CAAC,GAAGQ,KAAK,GAAGP,CAAC,GAAG0B,QAAQ;MAC7C,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,CAAC,EAAE,EAAE8B,CAAC,EAAE;QAC1BF,aAAa,GAAGE,CAAC,GAAGJ,QAAQ;QAC5Bc,YAAY,GAAGlD,CAAC,IAAIS,CAAC,GAAGC,CAAC,CAAC,GAAG8B,CAAC,GAAG/B,CAAC;QAClCyB,UAAU,CAACnC,GAAG,CAAC,IAAI,CAACb,UAAU,CAACuD,QAAQ,CAACS,YAAY,EAAEA,YAAY,GAAGzC,CAAC,CAAC,EAAE4B,UAAU,GAAGC,aAAa,CAAC;MACtG;IACF;IAEA,IAAI,CAACjB,kBAAkB,CAAC,IAAI,CAAC/C,OAAO,CAACC,IAAI,EAAEuE,EAAE,EAAEC,EAAE,CAAC;EACpD;EAEOI,MAAMA,CAAC9D,GAAQ,EAAQ;IAC5B,IAAI,CAACA,GAAG,GAAGA,GAAG;EAChB;;EAEA;EACO+D,eAAeA,CAACC,OAAmB,EAAQ;IAChD,IAAI,CAAC9D,YAAY,GAAG8D,OAAO;EAC7B;EAEOC,oBAAoBA,CAACC,KAAa,EAAQ;IAC/C,IAAI,CAAC9D,iBAAiB,GAAG8D,KAAK;EAChC;AACF;;;;;;;;;;;;;;;ACrWA,MAAMC,KAAK,GAAG,GAAG;AASjB;AACA;AACA;AACA;AACA;AACe,MAAM3F,SAAS,CAAC;EAC7B;;EAEA;;EAEA;;EAEA;;EAEA;;EAEA;;EAKAK,WAAWA,CAACK,IAA4B,EAAE;IACxC,IAAI,CAACkF,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,IAAI,GAAG,IAAIC,WAAW,CAAC,CAAC;IAC7B,IAAI,CAACzD,GAAG,GAAG,CAAC;IACZ,IAAI,CAACC,GAAG,GAAG,CAAC;IACZ,IAAI,CAACyD,OAAO,GAAG,CAAC;;IAEhB;IACA,MAAMC,KAAK,GAAGlG,SAAS,CAACmG,kBAAkB,CAACzF,IAAI,EAAEiF,KAAK,CAAC;IACvD,IAAI,CAACI,IAAI,GAAGG,KAAK,CAACH,IAAI;IACtB,IAAI,CAACxD,GAAG,GAAG2D,KAAK,CAAC3D,GAAG;IACpB,IAAI,CAACC,GAAG,GAAG0D,KAAK,CAAC1D,GAAG;IACpB,IAAI,CAACyD,OAAO,GAAGC,KAAK,CAACD,OAAO;;IAE5B;IACA;IACA,KAAK,IAAI9D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC4D,IAAI,CAACK,MAAM,EAAEjE,CAAC,EAAE,EAAE;MACzC,IAAI,IAAI,CAAC4D,IAAI,CAAC5D,CAAC,CAAC,GAAG,CAAC,EAAE;QACpB,IAAI,CAACyD,UAAU,GAAGzD,CAAC;QACnB;MACF;IACF;IACA,KAAK,IAAIA,CAAC,GAAG,IAAI,CAAC4D,IAAI,CAACK,MAAM,GAAG,CAAC,EAAEjE,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC9C,IAAI,IAAI,CAAC4D,IAAI,CAAC5D,CAAC,CAAC,GAAG,CAAC,EAAE;QACpB,IAAI,CAAC0D,UAAU,GAAG1D,CAAC;QACnB;MACF;IACF;IAEA,IAAI,CAACkE,UAAU,GAAG3F,IAAI,CAAC0F,MAAM;;IAE7B;IACA,IAAI,CAACN,MAAM,GAAG,CAAC;IACf,IAAItD,GAAG,GAAG,IAAI,CAACuD,IAAI,CAAC,CAAC,CAAC;IACtB,KAAK,IAAI5D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC4D,IAAI,CAACK,MAAM,EAAEjE,CAAC,EAAE,EAAE;MACzC,IAAI,IAAI,CAAC4D,IAAI,CAAC5D,CAAC,CAAC,GAAGK,GAAG,EAAE;QACtB,IAAI,CAACsD,MAAM,GAAG3D,CAAC;QACfK,GAAG,GAAG,IAAI,CAACuD,IAAI,CAAC5D,CAAC,CAAC;MACpB;IACF;EACF;;EAEA;EACA,OAAcmE,OAAOA,CAACC,SAAiB,EAAEC,OAAe,EAAEP,OAAe,EAAEQ,OAAe,EAAU;IAClG,IAAIC,QAAQ,GAAGrD,IAAI,CAACC,KAAK,CAAC,CAACiD,SAAS,GAAGC,OAAO,IAAIP,OAAO,CAAC;IAC1D;IACA,IAAIS,QAAQ,KAAKD,OAAO,EAAE;MACxBC,QAAQ,EAAE;IACZ;IACA,OAAOA,QAAQ;EACjB;;EAEA;EACOC,cAAcA,CAACC,KAAa,EAAU;IAC3C,OAAO5G,SAAS,CAACsG,OAAO,CAACM,KAAK,EAAE,IAAI,CAACrE,GAAG,EAAE,IAAI,CAAC0D,OAAO,EAAEN,KAAK,CAAC;EAChE;;EAEA;AACF;AACA;AACA;EACEkB,UAAUA,CAAA,EAAW;IACnB,OAAO,IAAI,CAACtE,GAAG;EACjB;;EAEA;AACF;AACA;AACA;EACEuE,UAAUA,CAAA,EAAW;IACnB,OAAO,IAAI,CAACtE,GAAG;EACjB;;EAEA;AACF;AACA;AACA;EACEuE,MAAMA,CAAA,EAAW;IACf,OAAO,IAAI,CAACnB,UAAU;EACxB;;EAEA;AACF;AACA;AACA;EACEoB,MAAMA,CAAA,EAAW;IACf;IACA,OAAO,IAAI,CAACnB,UAAU;EACxB;EAEAoB,UAAUA,CAAA,EAAW;IACnB,OAAO,IAAI,CAAClB,IAAI,CAACK,MAAM;EACzB;EAEAc,MAAMA,CAAC/E,CAAS,EAAU;IACxB,OAAO,IAAI,CAAC4D,IAAI,CAAC5D,CAAC,CAAC;EACrB;EAEAgF,WAAWA,CAAChF,CAAS,EAAoB;IACvC,OAAO,CAAC,IAAI,CAACI,GAAG,GAAGJ,CAAC,GAAG,IAAI,CAAC8D,OAAO,EAAE,IAAI,CAAC1D,GAAG,GAAG,CAACJ,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC8D,OAAO,CAAC;EACzE;;EAEA;AACF;AACA;AACA;AACA;EACEmB,mBAAmBA,CAACC,GAAW,EAAU;IACvC,MAAMC,KAAK,GAAG,IAAI,CAACjB,UAAU,GAAGgB,GAAG;IAEnC,IAAIlF,CAAC,GAAG,CAAC;IACT,IAAIoF,KAAK,GAAG,CAAC;IACb,KAAKpF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC4D,IAAI,CAACK,MAAM,EAAE,EAAEjE,CAAC,EAAE;MACrCoF,KAAK,IAAI,IAAI,CAACxB,IAAI,CAAC5D,CAAC,CAAC;MACrB,IAAIoF,KAAK,GAAGD,KAAK,EAAE;QACjB;MACF;IACF;IACA,OAAOnF,CAAC;EACV;;EAEA;EACAqF,eAAeA,CAAA,EAAqB;IAClC,MAAMC,QAAQ,GAAG,IAAI,CAACpB,UAAU;IAChC;IACA,MAAMiB,KAAK,GAAGG,QAAQ,GAAG,EAAE;IAE3B,IAAItF,CAAC,GAAG,CAAC;IACT,IAAIoF,KAAK,GAAG,CAAC;IACb,KAAKpF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC4D,IAAI,CAACK,MAAM,EAAE,EAAEjE,CAAC,EAAE;MACrCoF,KAAK,IAAI,IAAI,CAACxB,IAAI,CAAC5D,CAAC,CAAC;MACrB,IAAIoF,KAAK,GAAGD,KAAK,EAAE;QACjB;MACF;IACF;IACA,MAAMI,IAAI,GAAGvF,CAAC;IAEdoF,KAAK,GAAG,CAAC;IACT,KAAKpF,CAAC,GAAG,IAAI,CAAC4D,IAAI,CAACK,MAAM,GAAG,CAAC,EAAEjE,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MAC1CoF,KAAK,IAAI,IAAI,CAACxB,IAAI,CAAC5D,CAAC,CAAC;MACrB,IAAIoF,KAAK,GAAGD,KAAK,EAAE;QACjB;MACF;IACF;IACA,MAAMK,IAAI,GAAGxF,CAAC;IAEd,OAAO,CAACuF,IAAI,EAAEC,IAAI,CAAC;EACrB;;EAEA;EACAC,cAAcA,CAAA,EAAqB;IACjC;IACA;IACA,MAAMC,cAAc,GAAG,IAAI;IAC3B,MAAMJ,QAAQ,GAAG,IAAI,CAACpB,UAAU;IAChC;IACA,MAAMiB,KAAK,GAAGG,QAAQ,GAAG,EAAE;IAC3B,MAAMK,SAAS,GAAGL,QAAQ,GAAGI,cAAc;;IAE3C;IACA,IAAIH,IAAI,GAAG,IAAI,CAAC3B,IAAI,CAACK,MAAM,GAAG,CAAC;IAC/B,IAAIuB,IAAI,GAAG,CAAC;IACZ,KAAK,IAAIxF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC4D,IAAI,CAACK,MAAM,EAAE,EAAEjE,CAAC,EAAE;MACzC,IAAI,IAAI,CAAC4D,IAAI,CAAC5D,CAAC,CAAC,GAAG2F,SAAS,IAAI,IAAI,CAAC/B,IAAI,CAAC5D,CAAC,CAAC,IAAImF,KAAK,EAAE;QACrDI,IAAI,GAAGvF,CAAC;QACR;MACF;IACF;IACA,KAAK,IAAIA,CAAC,GAAG,IAAI,CAAC4D,IAAI,CAACK,MAAM,GAAG,CAAC,EAAEjE,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MAC9C,IAAI,IAAI,CAAC4D,IAAI,CAAC5D,CAAC,CAAC,GAAG2F,SAAS,IAAI,IAAI,CAAC/B,IAAI,CAAC5D,CAAC,CAAC,IAAImF,KAAK,EAAE;QACrDK,IAAI,GAAGxF,CAAC;QACR;MACF;IACF;IAEA,IAAIwF,IAAI,GAAGD,IAAI,EAAE;MACfA,IAAI,GAAG,CAAC;MACRC,IAAI,GAAG,GAAG;IACZ;IAEA,OAAO,CAACD,IAAI,EAAEC,IAAI,CAAC;EACrB;;EAEA;EACAI,cAAcA,CAAA,EAAqB;IACjC;IACA;IACA,MAAMC,UAAU,GAAG,GAAG;IACtB,MAAMC,EAAE,GAAG5E,IAAI,CAACC,KAAK,CAAC,IAAI,CAACyC,IAAI,CAAC,IAAI,CAACD,MAAM,CAAC,GAAGkC,UAAU,CAAC;IAC1D,IAAIE,CAAC,GAAG,CAAC;IACT,IAAIC,CAAC,GAAG,IAAI,CAACpC,IAAI,CAACK,MAAM,GAAG,CAAC;IAC5B,KAAK,IAAIxD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACmD,IAAI,CAACK,MAAM,EAAE,EAAExD,CAAC,EAAE;MACzC,IAAI,IAAI,CAACmD,IAAI,CAACnD,CAAC,CAAC,GAAGqF,EAAE,EAAE;QACrBC,CAAC,GAAGtF,CAAC;QACL;MACF;IACF;IACA,KAAK,IAAIA,CAAC,GAAG,IAAI,CAACmD,IAAI,CAACK,MAAM,GAAG,CAAC,EAAExD,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;MAC9C,IAAI,IAAI,CAACmD,IAAI,CAACnD,CAAC,CAAC,GAAGqF,EAAE,EAAE;QACrBE,CAAC,GAAGvF,CAAC;QACL;MACF;IACF;IACA,OAAO,CAACsF,CAAC,EAAEC,CAAC,CAAC;EACf;EAEA,OAAehC,kBAAkBA,CAACiC,GAA2B,EAAE3B,OAAO,GAAG,CAAC,EAAiB;IACzF,IAAIA,OAAO,GAAG,CAAC,EAAE;MACfA,OAAO,GAAG,CAAC;IACb;;IAEA;IACA;IACA;IACA;;IAEA,IAAIlE,GAAG,GAAG6F,GAAG,CAAC,CAAC,CAAC;IAChB,IAAI5F,GAAG,GAAG4F,GAAG,CAAC,CAAC,CAAC;IAChB,KAAK,IAAIjG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiG,GAAG,CAAChC,MAAM,EAAEjE,CAAC,EAAE,EAAE;MACnC,IAAIiG,GAAG,CAACjG,CAAC,CAAC,GAAGI,GAAG,EAAE;QAChBA,GAAG,GAAG6F,GAAG,CAACjG,CAAC,CAAC;MACd,CAAC,MAAM,IAAIiG,GAAG,CAACjG,CAAC,CAAC,GAAGK,GAAG,EAAE;QACvBA,GAAG,GAAG4F,GAAG,CAACjG,CAAC,CAAC;MACd;IACF;IAEA,MAAM4D,IAAI,GAAG,IAAIC,WAAW,CAACS,OAAO,CAAC,CAAC9E,IAAI,CAAC,CAAC,CAAC;IAE7C,MAAMsE,OAAO,GAAG,CAACzD,GAAG,GAAGD,GAAG,IAAIkE,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAACjE,GAAG,GAAGD,GAAG,IAAIkE,OAAO;IACvE,KAAK,IAAItE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiG,GAAG,CAAChC,MAAM,EAAEjE,CAAC,EAAE,EAAE;MACnC,MAAMkG,IAAI,GAAGD,GAAG,CAACjG,CAAC,CAAC;MAEnB,MAAMuE,QAAQ,GAAG1G,SAAS,CAACsG,OAAO,CAAC+B,IAAI,EAAE9F,GAAG,EAAE0D,OAAO,EAAEQ,OAAO,CAAC;MAC/DV,IAAI,CAACW,QAAQ,CAAC,EAAE;IAClB;IAEA,OAAO;MAAEX,IAAI;MAAExD,GAAG;MAAEC,GAAG;MAAEyD;IAAQ,CAAC;EACpC;AACF;;;;;;;;;;;;;;;;;;;AChRiF;AACxC;AAkDlC,SAASyC,gBAAgBA,CAAA,EAAc;EAC5C,OAAO;IACLpI,IAAI,EAAE,EAAE;IACRqI,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IACrBxE,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACxByE,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC1BC,mBAAmB,EAAE,CAAC;IACtBC,YAAY,EAAE,CAAC,GAAG,CAAC;IACnBC,aAAa,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IAChCC,eAAe,EAAE,CAAC;IAClBC,mBAAmB,EAAE,CACnB;MACEC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACtBC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACxBC,SAAS,EAAE,EAAE;MACbC,QAAQ,EAAE,EAAE;MACZxF,QAAQ,EAAE;IACZ,CAAC,CACF;IACDyF,SAAS,EAAE;MACTC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACtBC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACnBC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;IACjB;EACF,CAAC;AACH;AAEO,MAAMC,UAAU,CAAC;EAGtBrJ,WAAWA,CAACsJ,SAAqB,EAAE;IACjC,IAAI,CAACA,SAAS,GAAGA,SAAS,IAAIjB,gBAAgB,CAAC,CAAC;EAClD;EAEA,IAAIkB,gBAAgBA,CAAA,EAAe;IACjC,OAAO,IAAI,CAACD,SAAS,CAACV,mBAAmB,CAAC,IAAI,CAACU,SAAS,CAACX,eAAe,CAAC;EAC3E;;EAEA;EACA,IAAIa,WAAWA,CAAA,EAAW;IACxB,OAAO,IAAI,CAACF,SAAS,CAACd,mBAAmB;EAC3C;;EAEA;EACA,IAAIiB,YAAYA,CAAA,EAAY;IAC1B,OAAOxB,0DAAU,CAAC,IAAI,CAACqB,SAAS,CAACV,mBAAmB,CAAC,CAAC,CAAC,CAAC;EAC1D;;EAEA;EACA,IAAIX,UAAUA,CAAA,EAAY;IACxB,OAAOA,0DAAU,CAAC,IAAI,CAACsB,gBAAgB,CAAC;EAC1C;;EAEA;EACA,IAAIrB,iBAAiBA,CAAA,EAAY;IAC/B,OAAOA,iEAAiB,CAAC,IAAI,CAACoB,SAAS,CAACV,mBAAmB,CAAC,CAAC,CAAC,CAAC;EACjE;;EAEA;EACA,IAAIc,WAAWA,CAAA,EAAW;IACxB,OAAO,IAAI,CAACJ,SAAS,CAACV,mBAAmB,CAAC,CAAC,CAAC,CAACG,SAAS;EACxD;;EAEA;EACA,IAAIY,KAAKA,CAAA,EAAW;IAClB;IACA,OAAO,IAAI,CAACJ,gBAAgB,CAACV,KAAK,CAAC,CAAC,CAAC;EACvC;;EAEA;EACA,IAAIe,SAASA,CAAA,EAAW;IACtB;IACA,OAAO,IAAI,CAACL,gBAAgB,CAACT,OAAO,CAAC,CAAC,CAAC;EACzC;;EAEA;EACA,IAAIE,QAAQA,CAAA,EAAW;IACrB,OAAO,IAAI,CAACO,gBAAgB,CAACP,QAAQ;EACvC;;EAEA;EACA,IAAIa,mBAAmBA,CAAA,EAAW;IAChC,OAAO,IAAI,CAACP,SAAS,CAACV,mBAAmB,CAAC7C,MAAM;EAClD;;EAEA;EACA,IAAI0C,YAAYA,CAAA,EAAa;IAC3B,OAAO,IAAI,CAACa,SAAS,CAACb,YAAY;EACpC;;EAEA;EACA,IAAIC,aAAaA,CAAA,EAA2C;IAC1D,OAAO,IAAI,CAACY,SAAS,CAACZ,aAAa;EACrC;;EAEA;EACA,IAAI5E,aAAaA,CAAA,EAAY;IAC3B,OAAO,IAAIqE,0CAAO,CAAC,GAAG,IAAI,CAACmB,SAAS,CAACxF,aAAa,CAAC;EACrD;;EAEA;EACA,IAAIyE,eAAeA,CAAA,EAAY;IAC7B,OAAO,IAAIJ,0CAAO,CAAC,GAAG,IAAI,CAACmB,SAAS,CAACf,eAAe,CAAC;EACvD;EAEA,IAAII,eAAeA,CAAA,EAAW;IAC5B,OAAO,IAAI,CAACW,SAAS,CAACX,eAAe;EACvC;;EAEA;AACF;AACA;AACA;EACE,IAAIL,aAAaA,CAAA,EAAY;IAC3B,OAAO,IAAIF,0CAAO,CAAC,GAAG,IAAI,CAACkB,SAAS,CAAChB,aAAa,CAAC;EACrD;EAEA,IAAIW,SAASA,CAAA,EAAgE;IAC3E,OAAO;MACLC,WAAW,EAAE,IAAIf,0CAAO,CAAC,GAAG,IAAI,CAACmB,SAAS,CAACL,SAAS,CAACC,WAAW,CAAC;MACjEC,QAAQ,EAAE,IAAIhB,0CAAO,CAAC,GAAG,IAAI,CAACmB,SAAS,CAACL,SAAS,CAACE,QAAQ,CAAC;MAC3DC,KAAK,EAAE,IAAIjB,0CAAO,CAAC,GAAG,IAAI,CAACmB,SAAS,CAACL,SAAS,CAACG,KAAK;IACtD,CAAC;EACH;AACF;AAEO,SAASU,gBAAgBA,CAACR,SAAoB,EAAoB;EACvE,MAAM;IAAEhB;EAAc,CAAC,GAAGgB,SAAS;EACnC,MAAMS,OAAO,GAAGT,SAAS,CAACV,mBAAmB,CAACU,SAAS,CAACX,eAAe,CAAC;EACxE;EACA,OAAO,CAACL,aAAa,CAAC,CAAC,CAAC,GAAGyB,OAAO,CAAClB,KAAK,CAAC,CAAC,CAAC,EAAEP,aAAa,CAAC,CAAC,CAAC,GAAGyB,OAAO,CAAClB,KAAK,CAAC,CAAC,CAAC,CAAC;AACnF;;;;;;;;;;;;;;;;;;;;ACtL+D;AAG/D,SAASoB,KAAKA,CAACtH,GAAW,EAAEuH,IAAY,EAAEC,IAAY,EAAU;EAC9D,OAAOnH,IAAI,CAACd,GAAG,CAACc,IAAI,CAACb,GAAG,CAAC+H,IAAI,EAAEvH,GAAG,CAAC,EAAEwH,IAAI,CAAC;AAC5C;AAEA,SAASC,IAAIA,CAACC,IAAI,EAAEC,IAAI,EAAEC,CAAC,EAAE;EAC3B,OAAOA,CAAC,IAAID,IAAI,GAAGD,IAAI,CAAC,GAAGA,IAAI;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,WAAWA,CAClBjE,KAAa,EACbkE,QAAgB,EAChBC,QAAgB,EAChBC,MAAc,EACdC,MAAc,EACdC,MAAc,EACdC,MAAc,EACN;EACR,MAAMC,UAAU,GAAG,CAACxE,KAAK,GAAGkE,QAAQ,KAAKC,QAAQ,GAAGD,QAAQ,CAAC;EAC7D,MAAMO,QAAQ,GAAG,CAACF,MAAM,GAAGD,MAAM,IAAIE,UAAU,GAAGF,MAAM;EACxD;EACA,MAAMI,aAAa,GAAG,CAACD,QAAQ,GAAGL,MAAM,KAAKC,MAAM,GAAGD,MAAM,CAAC;EAC7D,MAAMO,QAAQ,GAAGT,QAAQ,GAAGQ,aAAa,IAAIP,QAAQ,GAAGD,QAAQ,CAAC;EACjE,OAAOS,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CACvB5E,KAAa,EACbkE,QAAgB,EAChBC,QAAgB,EAChBC,MAAc,EACdC,MAAc,EACdC,MAAc,EACdC,MAAc,EACN;EACR,MAAMC,UAAU,GAAG,CAACxE,KAAK,GAAGkE,QAAQ,KAAKC,QAAQ,GAAGD,QAAQ,CAAC;EAC7D;EACA,MAAMW,IAAI,GAAG,CAACR,MAAM,GAAGD,MAAM,IAAII,UAAU,GAAGJ,MAAM;EACpD;EACA,MAAMU,aAAa,GAAG,CAACD,IAAI,GAAGP,MAAM,KAAKC,MAAM,GAAGD,MAAM,CAAC;EACzD,MAAMK,QAAQ,GAAGT,QAAQ,GAAGY,aAAa,IAAIX,QAAQ,GAAGD,QAAQ,CAAC;EACjE,OAAOS,QAAQ;AACjB;AAEO,MAAMI,WAAW,GAAG,GAAG;AACvB,MAAMzL,gBAAgB,GAAGyL,WAAW,GAAG,CAAC;;AAE/C;AACA;AACA,SAASC,sBAAsBA,CAACC,aAA6B,EAAc;EACzE;EACA;EACA;EACA;EACA,MAAMC,GAAG,GAAGH,WAAW;EAEvB,MAAMnK,GAAG,GAAG,IAAIb,UAAU,CAACmL,GAAG,GAAG,CAAC,CAAC,CAACnK,IAAI,CAAC,CAAC,CAAC;EAE3C,IAAIkK,aAAa,CAACzF,MAAM,KAAK,CAAC,EAAE;IAC9B,OAAO5E,GAAG;EACZ;;EAEA;EACAqK,aAAa,CAACE,IAAI,CAAC,CAACnB,CAAC,EAAE1C,CAAC,KAAK0C,CAAC,CAAChI,CAAC,GAAGsF,CAAC,CAACtF,CAAC,CAAC;;EAEvC;EACA,IAAIiJ,aAAa,CAACzF,MAAM,KAAK,CAAC,EAAE;IAC9B,MAAM4F,IAAI,GAAGC,kBAAkB,CAACJ,aAAa,CAAC,CAAC,CAAC,CAAC;IACjD;IACA;IACA,MAAMK,MAAM,GAAG5B,KAAK,CAACuB,aAAa,CAAC,CAAC,CAAC,CAACjJ,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;IAChD,KAAK,IAAIA,CAAC,GAAGsJ,MAAM,EAAEtJ,CAAC,GAAGkJ,GAAG,EAAE,EAAElJ,CAAC,EAAE;MACjCpB,GAAG,CAACoB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGoJ,IAAI,CAAC,CAAC,CAAC;MACxBxK,GAAG,CAACoB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGoJ,IAAI,CAAC,CAAC,CAAC;MACxBxK,GAAG,CAACoB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGoJ,IAAI,CAAC,CAAC,CAAC;MACxBxK,GAAG,CAACoB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGoJ,IAAI,CAAC,CAAC,CAAC;IAC1B;IACA,OAAOxK,GAAG;EACZ;EAEA,IAAI2K,EAAE,GAAGN,aAAa,CAAC,CAAC,CAAC;EACzB,IAAIO,EAAE,GAAGP,aAAa,CAAC,CAAC,CAAC;EACzB,IAAIQ,MAAM,GAAGJ,kBAAkB,CAACE,EAAE,CAAC;EACnC,IAAIG,MAAM,GAAGL,kBAAkB,CAACG,EAAE,CAAC;EACnC,IAAIG,SAAS,GAAG,CAAC;EACjB,IAAI3B,CAAC,GAAG,CAAC;EACT,KAAK,IAAIzI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2J,GAAG,EAAE,EAAE3J,CAAC,EAAE;IAC5B;IACA,OAAOA,CAAC,GAAGiK,EAAE,CAACxJ,CAAC,EAAE;MACf;MACAuJ,EAAE,GAAGC,EAAE;MACPC,MAAM,GAAGC,MAAM;MACfC,SAAS,EAAE;MACX,IAAIA,SAAS,IAAIV,aAAa,CAACzF,MAAM,EAAE;QACrC;QACAgG,EAAE,GAAG;UAAExJ,CAAC,EAAE,GAAG;UAAE4J,KAAK,EAAEJ,EAAE,CAACI,KAAK;UAAEC,OAAO,EAAEL,EAAE,CAACK;QAAQ,CAAC;MACvD,CAAC,MAAM;QACLL,EAAE,GAAGP,aAAa,CAACU,SAAS,CAAC;MAC/B;MACAD,MAAM,GAAGL,kBAAkB,CAACG,EAAE,CAAC;IACjC;IACA;IACA,IAAIA,EAAE,CAACxJ,CAAC,KAAKuJ,EAAE,CAACvJ,CAAC,EAAE;MACjB;MACAgI,CAAC,GAAG,GAAG;IACT,CAAC,MAAM;MACLA,CAAC,GAAG,CAACzI,CAAC,GAAGgK,EAAE,CAACvJ,CAAC,KAAKwJ,EAAE,CAACxJ,CAAC,GAAGuJ,EAAE,CAACvJ,CAAC,CAAC;IAChC;IACApB,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGmI,KAAK,CAACG,IAAI,CAAC4B,MAAM,CAAC,CAAC,CAAC,EAAEC,MAAM,CAAC,CAAC,CAAC,EAAE1B,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;IAC7DpJ,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGmI,KAAK,CAACG,IAAI,CAAC4B,MAAM,CAAC,CAAC,CAAC,EAAEC,MAAM,CAAC,CAAC,CAAC,EAAE1B,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;IAC7DpJ,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGmI,KAAK,CAACG,IAAI,CAAC4B,MAAM,CAAC,CAAC,CAAC,EAAEC,MAAM,CAAC,CAAC,CAAC,EAAE1B,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;IAC7DpJ,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGmI,KAAK,CAACG,IAAI,CAAC4B,MAAM,CAAC,CAAC,CAAC,EAAEC,MAAM,CAAC,CAAC,CAAC,EAAE1B,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;EAC/D;EACA,OAAOpJ,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOA,SAASyK,kBAAkBA,CAACS,YAAY,EAAE;EACxC,OAAO,CAACA,YAAY,CAACF,KAAK,CAAC,CAAC,CAAC,EAAEE,YAAY,CAACF,KAAK,CAAC,CAAC,CAAC,EAAEE,YAAY,CAACF,KAAK,CAAC,CAAC,CAAC,EAAEnJ,IAAI,CAACC,KAAK,CAACoJ,YAAY,CAACD,OAAO,GAAG,GAAG,CAAC,CAAC;AACtH;;AAEA;AACA;AACA,MAAME,4BAA4B,GAAGA,CAACC,UAAU,GAAG,CAAC,EAAEC,UAAU,GAAG,CAAC,KAAmC,CACrG;EAAEjK,CAAC,EAAE,CAAC;EAAE6J,OAAO,EAAEG,UAAU;EAAEJ,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;AAAE,CAAC,EACrD;EAAE5J,CAAC,EAAE,GAAG;EAAE6J,OAAO,EAAEI,UAAU;EAAEL,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;AAAE,CAAC,CACxD;;AAED;AACA;AACA;AACA;AACA;AACA;AACO,MAAMvM,GAAG,CAAC;EAIfI,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACmB,GAAG,GAAG,IAAIb,UAAU,CAACT,gBAAgB,CAAC;IAC3C,IAAI,CAAC2L,aAAa,GAAG,EAAE;IACvB,IAAI,CAACiB,eAAe,CAAC,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACErL,gBAAgBA,CAACyG,CAAS,EAAEC,CAAS,EAAO;IAC1C,IAAIA,CAAC,GAAGD,CAAC,EAAE;MACT;MACA,MAAM6E,GAAG,GAAG5E,CAAC;MACbA,CAAC,GAAGD,CAAC;MACLA,CAAC,GAAG6E,GAAG;IACT;;IAEA;IACA,IAAI7E,CAAC,GAAG,CAAC,IAAIC,CAAC,GAAG,CAAC,EAAE;MAClB,IAAI,CAAC0D,aAAa,GAAGc,4BAA4B,CAAC,CAAC,EAAE,CAAC,CAAC;MACvD,OAAO,IAAI,CAACK,uBAAuB,CAAC,IAAI,CAACnB,aAAa,CAAC;IACzD;IACA,IAAI3D,CAAC,IAAI,GAAG,IAAIC,CAAC,IAAI,GAAG,EAAE;MACxB,IAAI,CAAC0D,aAAa,GAAGc,4BAA4B,CAAC,CAAC,EAAE,CAAC,CAAC;MACvD,OAAO,IAAI,CAACK,uBAAuB,CAAC,IAAI,CAACnB,aAAa,CAAC;IACzD;;IAEA;IACA,MAAMA,aAA6B,GAAG,EAAE;;IAExC;IACA,IAAIoB,QAAQ,GAAG,CAAC;IAChB,IAAI/E,CAAC,GAAG,CAAC,EAAE;MACT+E,QAAQ,GAAG,CAAC/E,CAAC,IAAIC,CAAC,GAAGD,CAAC,CAAC;IACzB;IACA2D,aAAa,CAACqB,IAAI,CAAC;MAAEtK,CAAC,EAAE,CAAC;MAAE6J,OAAO,EAAEQ,QAAQ;MAAET,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;IAAE,CAAC,CAAC;;IAEvE;IACA,IAAItE,CAAC,GAAG,CAAC,EAAE;MACT2D,aAAa,CAACqB,IAAI,CAAC;QAAEtK,CAAC,EAAEsF,CAAC;QAAEuE,OAAO,EAAE,CAAC;QAAED,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;MAAE,CAAC,CAAC;IAClE;;IAEA;IACA,IAAIrE,CAAC,GAAG,GAAG,EAAE;MACX,IAAIA,CAAC,KAAKD,CAAC,EAAE;QACX;QACA2D,aAAa,CAACqB,IAAI,CAAC;UAAEtK,CAAC,EAAEsF,CAAC,GAAG,GAAG;UAAEuE,OAAO,EAAE,CAAC;UAAED,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;QAAE,CAAC,CAAC;MACxE,CAAC,MAAM;QACLX,aAAa,CAACqB,IAAI,CAAC;UAAEtK,CAAC,EAAEuF,CAAC;UAAEsE,OAAO,EAAE,CAAC;UAAED,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;QAAE,CAAC,CAAC;MAClE;IACF;;IAEA;IACA,IAAIW,MAAM,GAAG,CAAC;IACd,IAAIhF,CAAC,GAAG,GAAG,EAAE;MACXgF,MAAM,GAAG,CAAC,GAAG,GAAGjF,CAAC,KAAKC,CAAC,GAAGD,CAAC,CAAC;IAC9B;IACA2D,aAAa,CAACqB,IAAI,CAAC;MAAEtK,CAAC,EAAE,GAAG;MAAE6J,OAAO,EAAEU,MAAM;MAAEX,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;IAAE,CAAC,CAAC;IAEvE,OAAO,IAAI,CAACQ,uBAAuB,CAACnB,aAAa,CAAC;EACpD;;EAEA;EACAiB,eAAeA,CAAA,EAAQ;IACrB,IAAI,CAACjB,aAAa,GAAGc,4BAA4B,CAAC,CAAC;IACnD,OAAO,IAAI,CAACK,uBAAuB,CAAC,IAAI,CAACnB,aAAa,CAAC;EACzD;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEuB,qBAAqBA,CAACC,GAAW,EAAEC,GAAW,EAAO;IACnD;IACA,MAAMpF,CAAC,GAAGoF,GAAG,GAAGD,GAAG,GAAG,GAAG;IACzB,MAAMlF,CAAC,GAAGmF,GAAG,GAAGD,GAAG,GAAG,GAAG;IACzB,OAAO,IAAI,CAAC5L,gBAAgB,CAACyG,CAAC,GAAG,GAAG,EAAEC,CAAC,GAAG,GAAG,CAAC;EAChD;;EAEA;EACA;EACA6E,uBAAuBA,CAACnB,aAA6B,EAAO;IAC1D,IAAI,CAACrK,GAAG,GAAGoK,sBAAsB,CAACC,aAAa,CAAC;IAChD,IAAI,CAACA,aAAa,GAAGA,aAAa;IAClC,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACE0B,qBAAqBA,CAACjM,SAAoB,EAAO;IAC/C;;IAEA,MAAMkM,GAAa,GAAG,EAAE;IACxB,KAAK,IAAIrL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,SAAS,CAAC2F,UAAU,CAAC,CAAC,EAAE,EAAE9E,CAAC,EAAE;MAC/CqL,GAAG,CAACrL,CAAC,CAAC,GAAG,CAAC;IACZ;;IAEA;IACAqL,GAAG,CAAC,CAAC,CAAC,GAAGlM,SAAS,CAAC4F,MAAM,CAAC,CAAC,CAAC;IAC5B,KAAK,IAAI/E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,SAAS,CAAC2F,UAAU,CAAC,CAAC,EAAE,EAAE9E,CAAC,EAAE;MAC/CqL,GAAG,CAACrL,CAAC,CAAC,GAAGqL,GAAG,CAACrL,CAAC,GAAG,CAAC,CAAC,GAAGb,SAAS,CAAC4F,MAAM,CAAC/E,CAAC,CAAC;IAC3C;IAEA,MAAMsL,GAAG,GAAGD,GAAG,CAACA,GAAG,CAACpH,MAAM,GAAG,CAAC,CAAC,GAAGoH,GAAG,CAAC,CAAC,CAAC;IACxC,IAAIC,GAAG,GAAG,CAAC,EAAE;MACX;MACA,MAAMC,gBAAgC,GAAG,CAAC;QAAE9K,CAAC,EAAE,CAAC;QAAE6J,OAAO,EAAE,CAAC;QAAED,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;MAAE,CAAC,CAAC;MACvF,IAAImB,KAAK,GAAG,CAAC;MACb,IAAIC,SAAS,GAAG,CAAC;MACjB,IAAInB,OAAO,GAAG,CAAC;MACf,IAAIoB,WAAW,GAAG,CAAC;MACnB,KAAK,IAAI1L,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwJ,WAAW,EAAE,EAAExJ,CAAC,EAAE;QACpC0L,WAAW,GAAGpB,OAAO;QACrBA,OAAO,GAAGnC,KAAK,CAACjH,IAAI,CAACyK,KAAK,CAAC,GAAG,IAAIN,GAAG,CAACrL,CAAC,CAAC,GAAGqL,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;QAE5DG,KAAK,GAAGlB,OAAO,GAAGoB,WAAW;QAC7B;QACA,IAAIF,KAAK,IAAIC,SAAS,EAAE;UACtBF,gBAAgB,CAACR,IAAI,CAAC;YAAEtK,CAAC,EAAET,CAAC,GAAG,CAAC;YAAEsK,OAAO,EAAEoB,WAAW,GAAG,KAAK;YAAErB,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;UAAE,CAAC,CAAC;UACzFoB,SAAS,GAAGD,KAAK;QACnB;MACF;MAEAD,gBAAgB,CAACR,IAAI,CAAC;QAAEtK,CAAC,EAAE,GAAG;QAAE6J,OAAO,EAAE,CAAC;QAAED,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;MAAE,CAAC,CAAC;MAErE,OAAO,IAAI,CAACQ,uBAAuB,CAACU,gBAAgB,CAAC;IACvD,CAAC,MAAM;MACL;MACA,OAAO,IAAI,CAACZ,eAAe,CAAC,CAAC;IAC/B;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEiB,iBAAiBA,CAACzM,SAAoB,EAAO;IAC3C,MAAME,GAAG,GAAG,IAAIb,UAAU,CAACT,gBAAgB,CAAC,CAACyB,IAAI,CAAC,CAAC,CAAC;IACpD,MAAMkK,aAA6B,GAAG,EAAE;IACxC;IACAA,aAAa,CAACqB,IAAI,CAAC;MAAEtK,CAAC,EAAE,CAAC;MAAE6J,OAAO,EAAE,CAAC;MAAED,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;IAAE,CAAC,CAAC;IAC1D,IAAIwB,KAAK,GAAG,CAAC;IACb,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,CAAC,GAAG,CAAC;IACT,IAAIC,CAAC,GAAG,CAAC;IACT,IAAInG,CAAC,GAAG,CAAC;IACT,IAAI0C,CAAC,GAAG,CAAC;;IAET;IACA,KAAK,IAAIzI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwJ,WAAW,EAAE,EAAExJ,CAAC,EAAE;MACpC,MAAMmM,IAAI,GAAGjL,IAAI,CAACC,KAAK,CAAEnB,CAAC,IAAIwJ,WAAW,GAAG,CAAC,CAAC,IAAKrK,SAAS,CAAC2F,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;MAC/E,IAAI3F,SAAS,CAAC4F,MAAM,CAACoH,IAAI,CAAC,GAAG,CAAC,EAAE;QAC9B,MAAMrM,GAAG,GAAGoI,4EAAsB,CAACiE,IAAI,CAAC;QAExC9M,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGF,GAAG,CAAC,CAAC,CAAC;QACvBT,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGF,GAAG,CAAC,CAAC,CAAC;QACvBT,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGF,GAAG,CAAC,CAAC,CAAC;QACvBT,GAAG,CAACW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG;QAEpBiM,CAAC,GAAGnM,GAAG,CAAC,CAAC,CAAC;QACVoM,CAAC,GAAGpM,GAAG,CAAC,CAAC,CAAC;QACViG,CAAC,GAAGjG,GAAG,CAAC,CAAC,CAAC;QACV2I,CAAC,GAAG,CAAC;MACP,CAAC,MAAM;QACL;QACAwD,CAAC,GAAG,CAAC;QACLC,CAAC,GAAG,CAAC;QACLnG,CAAC,GAAG,CAAC;QACL0C,CAAC,GAAG,CAAC;QACL;MACF;MACA;MACA,IAAIwD,CAAC,KAAKJ,KAAK,IAAIK,CAAC,KAAKJ,KAAK,IAAI/F,CAAC,KAAKgG,KAAK,IAAItD,CAAC,KAAKuD,KAAK,EAAE;QAC5D,IAAIA,KAAK,KAAK,CAAC,EAAE;UACftC,aAAa,CAACqB,IAAI,CAAC;YAAEtK,CAAC,EAAET,CAAC,GAAG,GAAG;YAAEsK,OAAO,EAAE0B,KAAK;YAAE3B,KAAK,EAAE,CAACwB,KAAK,EAAEC,KAAK,EAAEC,KAAK;UAAE,CAAC,CAAC;QAClF;QACArC,aAAa,CAACqB,IAAI,CAAC;UAAEtK,CAAC,EAAET,CAAC;UAAEsK,OAAO,EAAE7B,CAAC;UAAE4B,KAAK,EAAE,CAAC4B,CAAC,EAAEC,CAAC,EAAEnG,CAAC;QAAE,CAAC,CAAC;QAC1D8F,KAAK,GAAGI,CAAC;QACTH,KAAK,GAAGI,CAAC;QACTH,KAAK,GAAGhG,CAAC;QACTiG,KAAK,GAAGvD,CAAC;MACX;IACF;IAEA,IAAI,CAACpJ,GAAG,GAAGA,GAAG;IACd,IAAI,CAACqK,aAAa,GAAGA,aAAa;IAClC,OAAO,IAAI;EACb;;EAEA;EACApJ,YAAYA,CAACuI,MAAc,EAAEC,MAAc,EAAEC,MAAc,EAAEC,MAAc,EAAE;IAC3E;IACA;IACA,IAAI,CAAC3J,GAAG,GAAG+M,QAAQ,CAAC,IAAI,CAAC/M,GAAG,EAAEwJ,MAAM,EAAEC,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC;IAC7D,IAAI,CAACU,aAAa,GAAG2C,kBAAkB,CAAC,IAAI,CAAC3C,aAAa,EAAEb,MAAM,EAAEC,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC;EAC7F;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASoD,QAAQA,CAAC/M,GAAe,EAAEwJ,MAAc,EAAEC,MAAc,EAAEC,MAAc,EAAEC,MAAc,EAAc;EACpH,MAAMsD,MAAM,GAAG,IAAI9N,UAAU,CAACT,gBAAgB,CAAC;;EAE/C;EACA;EACA;EACA,KAAK,IAAIiC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwJ,WAAW,EAAE,EAAExJ,CAAC,EAAE;IACpC,IAAIsJ,IAAI,GAAGZ,WAAW,CAAC1I,CAAC,EAAE,CAAC,EAAEwJ,WAAW,GAAG,CAAC,EAAEX,MAAM,EAAEC,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC;IAC7E,IAAIM,IAAI,GAAG,CAAC,EAAE;MACZA,IAAI,GAAG,CAAC;IACV;IACA,IAAIA,IAAI,GAAGE,WAAW,GAAG,CAAC,EAAE;MAC1BF,IAAI,GAAGE,WAAW,GAAG,CAAC;IACxB;IACA;IACA,MAAM+C,EAAE,GAAGrL,IAAI,CAACC,KAAK,CAACmI,IAAI,CAAC;IAC3B,MAAMkD,EAAE,GAAGtL,IAAI,CAACuL,IAAI,CAACnD,IAAI,CAAC;IAC1B,MAAMpE,GAAG,GAAGoE,IAAI,GAAGiD,EAAE;;IAErB;IACAD,MAAM,CAACtM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGkB,IAAI,CAACyK,KAAK,CAACrD,IAAI,CAACjJ,GAAG,CAACkN,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAElN,GAAG,CAACmN,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEtH,GAAG,CAAC,CAAC;IAC3EoH,MAAM,CAACtM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGkB,IAAI,CAACyK,KAAK,CAACrD,IAAI,CAACjJ,GAAG,CAACkN,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAElN,GAAG,CAACmN,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEtH,GAAG,CAAC,CAAC;IAC3EoH,MAAM,CAACtM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGkB,IAAI,CAACyK,KAAK,CAACrD,IAAI,CAACjJ,GAAG,CAACkN,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAElN,GAAG,CAACmN,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEtH,GAAG,CAAC,CAAC;IAC3EoH,MAAM,CAACtM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGkB,IAAI,CAACyK,KAAK,CAACrD,IAAI,CAACjJ,GAAG,CAACkN,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAElN,GAAG,CAACmN,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEtH,GAAG,CAAC,CAAC;EAC7E;EAEA,OAAOoH,MAAM;AACf;AAEO,SAASD,kBAAkBA,CAChC3C,aAA6B,EAC7Bb,MAAc,EACdC,MAAc,EACdC,MAAc,EACdC,MAAc,EACd0D,cAAc,GAAG,IAAI,EACL;EAChB,IAAIhD,aAAa,CAACzF,MAAM,KAAK,CAAC,EAAE;IAC9B,OAAOyF,aAAa;EACtB;EAEA,MAAMiD,gBAAgC,GAAG,EAAE;;EAE3C;EACA,MAAMC,SAAS,GAAGlD,aAAa,CAAC,CAAC,CAAC,CAACjJ,CAAC;EACpC,MAAMoM,QAAQ,GAAGnD,aAAa,CAACA,aAAa,CAACzF,MAAM,GAAG,CAAC,CAAC,CAACxD,CAAC;;EAE1D;;EAEA;EACA;EACA;EACA;EACA,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0J,aAAa,CAACzF,MAAM,EAAE,EAAEjE,CAAC,EAAE;IAC7C,MAAM8M,EAAE,GAAGpD,aAAa,CAAC1J,CAAC,CAAC;IAC3B,MAAMsJ,IAAI,GAAGD,gBAAgB,CAACyD,EAAE,CAACrM,CAAC,EAAE,CAAC,EAAE+I,WAAW,GAAG,CAAC,EAAEX,MAAM,EAAEC,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC;IACvF,MAAM+D,KAAmB,GAAG;MAC1BtM,CAAC,EAAE6I,IAAI;MACPgB,OAAO,EAAEwC,EAAE,CAACxC,OAAO;MACnBD,KAAK,EAAE,CAACyC,EAAE,CAACzC,KAAK,CAAC,CAAC,CAAC,EAAEyC,EAAE,CAACzC,KAAK,CAAC,CAAC,CAAC,EAAEyC,EAAE,CAACzC,KAAK,CAAC,CAAC,CAAC;IAC/C,CAAC;IACDsC,gBAAgB,CAAC5B,IAAI,CAACgC,KAAK,CAAC;EAC9B;EAEA,OAAOL,cAAc,GAAGM,6BAA6B,CAACL,gBAAgB,EAAEC,SAAS,EAAEC,QAAQ,CAAC,GAAGF,gBAAgB;AACjH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,6BAA6BA,CAACtD,aAA6B,EAAEkD,SAAiB,EAAEC,QAAgB,EAAE;EACzG,MAAMI,OAAO,GAAG,MAAM;EACtB,MAAMC,KAAK,GAAGxD,aAAa,CAAC,CAAC,CAAC;EAC9B,MAAMyD,MAAM,GAAGzD,aAAa,CAAC,CAAC,CAAC;EAC/B,MAAM0D,UAAU,GAAG1D,aAAa,CAACA,aAAa,CAACzF,MAAM,GAAG,CAAC,CAAC;EAC1D,MAAMoJ,IAAI,GAAG3D,aAAa,CAACA,aAAa,CAACzF,MAAM,GAAG,CAAC,CAAC;EAEpD,IAAI/C,IAAI,CAACoM,GAAG,CAACJ,KAAK,CAAC5C,OAAO,IAAI6C,MAAM,EAAE7C,OAAO,IAAIiD,QAAQ,CAAC,CAAC,GAAGN,OAAO,EAAE;IACrE,IAAIC,KAAK,CAACzM,CAAC,GAAG,CAAC,EAAE;MACf;MACAyM,KAAK,CAACzM,CAAC,GAAGS,IAAI,CAACd,GAAG,CAAC,CAAC,EAAE+M,MAAM,CAAC1M,CAAC,GAAG,CAAC,CAAC;IACrC,CAAC,MAAM,IAAImM,SAAS,GAAGK,OAAO,EAAE;MAC9B;MACAC,KAAK,CAACzM,CAAC,GAAG,CAAC;IACb;EACF;EAEA,IAAIS,IAAI,CAACoM,GAAG,CAACD,IAAI,CAAC/C,OAAO,IAAI8C,UAAU,EAAE9C,OAAO,IAAIiD,QAAQ,CAAC,CAAC,GAAGN,OAAO,EAAE;IACxE,IAAII,IAAI,CAAC5M,CAAC,GAAG,GAAG,EAAE;MAChB;MACA4M,IAAI,CAAC5M,CAAC,GAAGS,IAAI,CAACb,GAAG,CAAC,GAAG,EAAE+M,UAAU,CAAC3M,CAAC,GAAG,CAAC,CAAC;IAC1C,CAAC,MAAM,IAAIoM,QAAQ,GAAG,GAAG,GAAGI,OAAO,EAAE;MACnC;MACAI,IAAI,CAAC5M,CAAC,GAAG,GAAG;IACd;EACF;EAEA,OAAOiJ,aAAa;AACtB;;;;;;;;;;;;;;;;;;;;;ACnfgC;AAEG;AAG4B;AACoC;AACV;AAEX;AAS9E;AACA;AACA;AACA;AACA;AACe,MAAMiE,MAAM,CAAC;EAI1B;AACF;AACA;;EAWE;;EAEA;;EAEA;;EAEA;;EAUAzP,WAAWA,CAACsJ,SAAoB,GAAGjB,+DAAgB,CAAC,CAAC,EAAEqH,QAAkB,GAAG,IAAIJ,+DAAQ,CAAC,CAAC,EAAEK,MAAsB,EAAE;IAClH,IAAI,CAACzP,MAAM,GAAG,KAAK;IACnB,IAAI,CAACoJ,SAAS,GAAG,IAAID,qDAAU,CAACC,SAAS,CAAC;IAC1C;IACA,IAAI,CAACrJ,IAAI,GAAGqJ,SAAS,CAACrJ,IAAI;IAC1B,IAAI,CAACyP,QAAQ,GAAG;MACd;MACA/G,eAAe,EAAE,CAAC;MAClBiH,cAAc,EAAE,CAAC;MACjBC,YAAY,EAAEN,yEAAc;MAC5BO,QAAQ,EAAEC,KAAK,CAACC,IAAI,CAAC;QAAEjK,MAAM,EAAE,IAAI,CAACuD,SAAS,CAACE;MAAY,CAAC,EAAE,CAACyG,IAAI,EAAEC,GAAG,KAAKA,GAAG,CAAC;MAChF,GAAGR;IACL,CAAC;IACD,IAAI,CAACS,gBAAgB,GAAG;MACtB,GAAG,IAAI,CAACT,QAAQ;MAChBI,QAAQ,EAAE,IAAI,CAACJ,QAAQ,CAACI,QAAQ,CAACM,KAAK,CAAC,CAAC;MACxCC,SAAS,EAAE,IAAI,CAACX,QAAQ,CAACW,SAAS,CAACC,KAAK,CAAC;IAC3C,CAAC;IACD,IAAI,CAACX,MAAM,GAAGA,MAAM;IACpB;IACA,IAAI,CAACY,aAAa,GAAG,CAAC,CAAC;IAEvB,IAAI,CAACC,cAAc,GAAG,IAAIrI,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC1C,IAAI,CAACsI,gBAAgB,GAAG,IAAItI,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC5C,IAAI,CAACuI,YAAY,GAAG,IAAIvI,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACxC,IAAI,CAACwI,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,gBAAgB,GAAG,IAAIzI,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC5C,IAAI,CAACD,iBAAiB,GAAG,IAAI,CAACoB,SAAS,CAACpB,iBAAiB;IACzD,IAAI,CAAC2I,sBAAsB,GAAG,CAAC;IAC/B,IAAI,CAACC,YAAY,CAAC,IAAI,CAAC5I,iBAAiB,CAAC;IAEzC,IAAI,CAACsB,WAAW,GAAG,IAAI,CAACF,SAAS,CAACE,WAAW;IAC7C,IAAI,CAACf,YAAY,GAAG,IAAI,CAACa,SAAS,CAACb,YAAY,CAAC2H,KAAK,CAAC,CAAC;IACvD,IAAI,CAACW,oBAAoB,GAAG,IAAI,CAACzH,SAAS,CAACZ,aAAa,GACpD,IAAI,CAACY,SAAS,CAACZ,aAAa,CAAC0H,KAAK,CAAC,CAAC,GACpC,IAAI,CAAC3H,YAAY,CAAC0E,GAAG,CAAC,CAAClN,IAAI,EAAE+Q,KAAK,KAAKhH,4EAAsB,CAACgH,KAAK,CAAC,CAAC;IACzE;IACA,IAAI,IAAI,CAACD,oBAAoB,CAAChL,MAAM,GAAG,IAAI,CAACuD,SAAS,CAACE,WAAW,EAAE;MACjE,KAAK,IAAI1H,CAAC,GAAG,IAAI,CAACiP,oBAAoB,CAAChL,MAAM,GAAG,CAAC,EAAEjE,CAAC,GAAG,IAAI,CAACwH,SAAS,CAACE,WAAW,EAAE,EAAE1H,CAAC,EAAE;QACtF,IAAI,CAACiP,oBAAoB,CAACjP,CAAC,CAAC,GAAGkI,4EAAsB,CAAClI,CAAC,CAAC;MAC1D;IACF;IAEA,IAAI,CAACgO,QAAQ,GAAG,EAAE;IAClB,KAAK,IAAIhO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACwH,SAAS,CAACE,WAAW,EAAE,EAAE1H,CAAC,EAAE;MACnD,MAAMmP,OAAO,GAAG,IAAIlR,mDAAO,CAAC,IAAI,CAAC0I,YAAY,CAAC3G,CAAC,CAAC,CAAC;MACjD,IAAI,CAACgO,QAAQ,CAACjD,IAAI,CAACoE,OAAO,CAAC;MAC3B;MACAA,OAAO,CAAC/P,IAAI,GAAG,IAAI,CAACoI,SAAS,CAACxF,aAAa,CAACoN,OAAO,CAAC,CAAC;IACvD;IAEA,IAAI,CAACC,kBAAkB,GAAG,IAAI,CAAC7H,SAAS,CAACI,WAAW;IAEpD,IAAI,CAAC0H,mBAAmB,GAAG,EAAE;EAC/B;EAEQC,WAAWA,CAAA,EAAG;IACpB,IAAI,CAACnR,MAAM,GAAG,KAAK;IACnB,IAAI,CAAC4P,QAAQ,CAACwB,OAAO,CAAEL,OAAO,IAAK;MACjCA,OAAO,CAAC/Q,MAAM,GAAG,KAAK;IACxB,CAAC,CAAC;EACJ;EAEAqR,QAAQA,CAAA,EAAY;IAClB,OAAO,IAAI,CAACrR,MAAM;EACpB;EAEAsR,gBAAgBA,CAAA,EAAG;IACjB,MAAM;MAAEvJ,UAAU;MAAEnE,aAAa;MAAEyE;IAAgB,CAAC,GAAG,IAAI,CAACe,SAAS;IAErE,IAAI,CAACwH,YAAY,CAAC,IAAI,CAAC5I,iBAAiB,CAAC;IAEzC,IAAI,CAACsI,cAAc,GAAG1M,aAAa,CAACwM,KAAK,CAAC,CAAC,CAACmB,MAAM,CAACxJ,UAAU,CAAC;IAC9D,IAAI,CAACwI,gBAAgB,GAAGlI,eAAe,CAAC+H,KAAK,CAAC,CAAC,CAACmB,MAAM,CAACxJ,UAAU,CAAC;EACpE;;EAEA;EACQyJ,eAAeA,CAAA,EAAY;IACjC,OACE,IAAI,CAAChC,QAAQ,CAACiC,gBAAgB,KAAK,IAAI,CAACxB,gBAAgB,CAACwB,gBAAgB;IAAI;IAC7E,IAAI,CAACjC,QAAQ,CAACkC,IAAI,KAAK,IAAI,CAACzB,gBAAgB,CAACyB,IAAI;IAAI;IACrD,CAAC,IAAI,CAAClC,QAAQ,CAACW,SAAS,CAACwB,WAAW,CAAC,IAAI,CAAC1B,gBAAgB,CAACE,SAAS,CAAC;IAAI;IACzE,IAAI,CAACF,gBAAgB,CAACL,QAAQ,CAACgC,IAAI,CAAEb,OAAO,IAAK,CAAC,IAAI,CAACvB,QAAQ,CAACI,QAAQ,CAACiC,QAAQ,CAACd,OAAO,CAAC,CAAC,CAAC;IAAA;EAEhG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUe,oBAAoBA,CAAA,EAAY;IACtC,OACE,CAAC,IAAI,CAACtC,QAAQ,CAACW,SAAS,CAAC4B,MAAM,CAAC,IAAI,CAAC9B,gBAAgB,CAACE,SAAS,CAAC,IAChE,IAAI,CAACF,gBAAgB,CAACN,YAAY,KAAK,IAAI,CAACH,QAAQ,CAACG,YAAY,IACjE,IAAI,CAACM,gBAAgB,CAACxH,eAAe,KAAK,IAAI,CAAC+G,QAAQ,CAAC/G,eAAe,IACvE,IAAI,CAACwH,gBAAgB,CAACP,cAAc,KAAK,IAAI,CAACF,QAAQ,CAACE,cAAc;EAEzE;;EAEA;EACA,MAAMsC,kBAAkBA,CAACC,QAA2B,EAAEC,eAAoC,EAAiB;IACzG,IAAI,CAACjC,gBAAgB,GAAG;MAAE,GAAG,IAAI,CAACA,gBAAgB;MAAE,GAAGgC;IAAS,CAAC;IACjE,IAAIE,YAAY,GAAG,IAAI,CAACX,eAAe,CAAC,CAAC;;IAEzC;IACA,IAAI,CAACW,YAAY,IAAI,IAAI,CAACL,oBAAoB,CAAC,CAAC,EAAE;MAChD;MACA,MAAM9Q,IAAI,GAAG,MAAM,IAAI,CAACoR,kBAAkB,CAAC,CAAC;MAC5C,IAAIpR,IAAI,EAAE;QACR,MAAMqR,OAAO,GAAGrR,IAAI,CAACiM,GAAG,CAAC,CAAC;UAAEtE;QAAM,CAAC,KAA+B,CAACA,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACjG;QACA,MAAM2J,WAAW,GAAGhD,sFAAuB,CAAC,IAAI,CAACW,gBAAgB,EAAEoC,OAAO,CAAC;QAC3EF,YAAY,GAAG,IAAI,CAAC/I,SAAS,CAACX,eAAe,KAAK6J,WAAW;MAC/D;IACF;IAEA,IAAIH,YAAY,EAAE;MAChB,IAAI,CAACI,WAAW,CAACL,eAAe,CAAC;IACnC;EACF;EAEA,MAAcE,kBAAkBA,CAAA,EAAsC;IACpE,IAAI;MACF,OAAO,MAAM,IAAI,CAAC3C,MAAM,EAAE+C,QAAQ,CAAC,IAAI,CAACvC,gBAAgB,CAAC;IAC3D,CAAC,CAAC,OAAOrI,CAAC,EAAE;MACV,IAAI,CAACsJ,mBAAmB,CAACE,OAAO,CAAEqB,QAAQ,IAAKA,QAAQ,CAACC,iBAAiB,CAAC,IAAI,EAAE9K,CAAC,CAAC,CAAC;MACnF,OAAO+K,SAAS;IAClB;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAcJ,WAAWA,CAACL,eAAoC,EAAiB;IAC7E,IAAI,CAACf,WAAW,CAAC,CAAC;IAClB,IAAI,CAAC3B,QAAQ,GAAG;MACd,GAAG,IAAI,CAACS,gBAAgB;MACxBE,SAAS,EAAE,IAAI,CAACF,gBAAgB,CAACE,SAAS,CAACC,KAAK,CAAC;IACnD,CAAC;IAED,IAAI;MACF,MAAM,IAAI,CAACX,MAAM,EAAEmD,cAAc,CAAC,IAAI,EAAED,SAAS,EAAET,eAAe,CAAC;IACrE,CAAC,CAAC,OAAOtK,CAAC,EAAE;MACV,IAAI,CAACsJ,mBAAmB,CAACE,OAAO,CAAEqB,QAAQ,IAAKA,QAAQ,CAACC,iBAAiB,CAAC,IAAI,EAAE9K,CAAC,CAAC,CAAC;MACnF,MAAMA,CAAC;IACT;EACF;;EAEA;EACA;EACA;EACAgJ,YAAYA,CAACiC,IAAa,EAAQ;IAChC;IACAA,IAAI,CAACxQ,CAAC,GAAGwQ,IAAI,CAACxQ,CAAC,GAAG,CAAC,GAAGwQ,IAAI,CAACxQ,CAAC,GAAG,GAAG;IAClCwQ,IAAI,CAACvQ,CAAC,GAAGuQ,IAAI,CAACvQ,CAAC,GAAG,CAAC,GAAGuQ,IAAI,CAACvQ,CAAC,GAAG,GAAG;IAClCuQ,IAAI,CAACtQ,CAAC,GAAGsQ,IAAI,CAACtQ,CAAC,GAAG,CAAC,GAAGsQ,IAAI,CAACtQ,CAAC,GAAG,GAAG;IAClC,IAAI,CAACyF,iBAAiB,GAAG6K,IAAI;IAE7B,IAAI,CAACrC,YAAY,GAAG,IAAI,CAACpH,SAAS,CAACG,YAAY,CAAC6G,KAAK,CAAC,CAAC,CAAC0C,QAAQ,CAAC,IAAI,CAAC9K,iBAAiB,CAAC;IACxF;IACA,IAAI,CAACyI,aAAa,GAAG3N,IAAI,CAACb,GAAG,CAAC,IAAI,CAACuO,YAAY,CAACnO,CAAC,EAAE,IAAI,CAACmO,YAAY,CAAClO,CAAC,EAAE,IAAI,CAACkO,YAAY,CAACjO,CAAC,CAAC;IAC5F;IACA,IAAI,CAACmO,gBAAgB,GAAG,IAAI,CAACF,YAAY,CAACJ,KAAK,CAAC,CAAC,CAAC2C,YAAY,CAAC,IAAI,CAACtC,aAAa,CAAC;IAClF;IACA;IACA,IAAI,CAACE,sBAAsB,GAAG,EAAE,IAAI7N,IAAI,CAACC,KAAK,CAACD,IAAI,CAACkQ,KAAK,CAAC,IAAI,CAACvC,aAAa,GAAG,CAAC,CAAC,CAAC;EACpF;EAEAwC,aAAaA,CAACC,MAAc,EAAQ;IAClC,IAAI,CAACjC,kBAAkB,GAAGiC,MAAM;EAClC;;EAEA;EACAC,gBAAgBA,CAAA,EAAY;IAC1B;IACA,OAAO,IAAI,CAAC7C,cAAc,CACvBF,KAAK,CAAC,CAAC,CACP2C,YAAY,CAAC,CAAC,CAAC,CACfK,GAAG,CAAC,IAAI,CAAC7C,gBAAgB,CAAC,CAC1B8C,SAAS,CAAC,GAAG,CAAC,CACdP,QAAQ,CAAC,IAAI,CAACpC,gBAAgB,CAAC;EACpC;EAEA4C,OAAOA,CAAA,EAAS;IACd;EAAA;EAGFC,UAAUA,CAACC,YAAoB,EAAW;IACxC,OAAO,IAAI,CAAC5D,QAAQ,CAAC4D,YAAY,CAAC;EACpC;EAEAtB,eAAeA,CAACuB,KAAe,EAAQ;IACrC;IACA,IAAI,IAAI,CAACjE,QAAQ,CAACI,QAAQ,CAAC8D,KAAK,CAAEF,YAAY,IAAK,IAAI,CAAC5D,QAAQ,CAAC4D,YAAY,CAAC,CAACxT,MAAM,CAAC,EAAE;MACtF,IAAI,CAACA,MAAM,GAAG,IAAI;IACpB;IACAyT,KAAK,CAACrC,OAAO,CAAEoC,YAAY,IAAK,IAAI,CAACG,mBAAmB,GAAG,IAAI,EAAEH,YAAY,CAAC,CAAC;IAC/E,IAAI,CAACtC,mBAAmB,CAACE,OAAO,CAAEqB,QAAQ,IAAKA,QAAQ,CAACmB,YAAY,CAAC,IAAI,EAAEH,KAAK,CAAC,CAAC;EACpF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEI,uBAAuBA,CACrBL,YAAoB,EACpBM,SAAiC,EACjCC,UAAkB,EAClBC,WAAmB,EACnBC,KAAuB,EACvBhU,KAAiB,GAAG,OAAO,EACrB;IACN,IAAI,CAAC2P,QAAQ,CAAC4D,YAAY,CAAC,CAAC9P,YAAY,CACtCoQ,SAAS,EACTC,UAAU,EACVC,WAAW,EACX/T,KAAK,EACLgU,KAAK,CAAC,CAAC,CAAC,EACRA,KAAK,CAAC,CAAC,CAAC,EACR,IAAI,CAAC7K,SAAS,CAACxF,aACjB,CAAC;IACD,IAAI,CAACsO,eAAe,CAAC,CAACsB,YAAY,CAAC,CAAC;EACtC;;EAEA;EACA;AACF;AACA;AACA;AACA;EACEU,wBAAwBA,CACtBV,YAAoB,EACpB1S,UAAkC,EAClCmT,KAAuB,EACvBhU,KAAiB,GAAG,OAAO,EACrB;IACN,MAAM;MAAE2D,aAAa;MAAEwE;IAAc,CAAC,GAAG,IAAI,CAACgB,SAAS;IACvD,IAAI,CAACwG,QAAQ,CAAC4D,YAAY,CAAC,CAAClP,iBAAiB,CAC3CxD,UAAU,EACV8C,aAAa,CAACvB,CAAC,EACfuB,aAAa,CAACtB,CAAC,EACfsB,aAAa,CAACrB,CAAC,EACf6F,aAAa,CAAC/F,CAAC,GAAGuB,aAAa,CAACvB,CAAC,EACjC+F,aAAa,CAAC9F,CAAC,GAAGsB,aAAa,CAACtB,CAAC,EACjC2R,KAAK,CAAC,CAAC,CAAC,EACRA,KAAK,CAAC,CAAC,CAAC,EACRhU,KACF,CAAC;IACD,IAAI,CAACiS,eAAe,CAAC,CAACsB,YAAY,CAAC,CAAC;EACtC;;EAEA;EACA;AACF;AACA;AACA;AACA;AACA;EACEW,kBAAkBA,CAACpU,IAAY,EAAEkM,KAAgC,EAAU;IACzE,MAAM+D,GAAG,GAAG,IAAI,CAAC5G,SAAS,CAACE,WAAW;IACtC,MAAM8K,MAAM,GAAGrU,IAAI,IAAI,UAAU,GAAGiQ,GAAG;IACvC,MAAMqE,OAAO,GAAGpI,KAAK,IAAInC,4EAAsB,CAACkG,GAAG,CAAC;IACpD,IAAI,CAAC1G,WAAW,IAAI,CAAC;IACrB,IAAI,CAACf,YAAY,CAACoE,IAAI,CAACyH,MAAM,CAAC;IAC9B,IAAI,CAACvD,oBAAoB,CAAClE,IAAI,CAAC0H,OAAO,CAAC;IAEvC,IAAI,CAACzE,QAAQ,CAACjD,IAAI,CAAC,IAAI9M,mDAAO,CAACuU,MAAM,CAAC,CAAC;IAEvC,KAAK,IAAIxS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACsP,mBAAmB,CAACrL,MAAM,EAAE,EAAEjE,CAAC,EAAE;MACxD,IAAI,CAACsP,mBAAmB,CAACtP,CAAC,CAAC,CAAC0S,oBAAoB,CAAC,IAAI,EAAEtE,GAAG,CAAC;IAC7D;IAEA,OAAOA,GAAG;EACZ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE5N,YAAYA,CAACmS,CAAS,EAAElS,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAU;IAC/D,OAAO,IAAI,CAACqN,QAAQ,CAAC2E,CAAC,CAAC,CAACnS,YAAY,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;EAC/C;;EAEA;AACF;AACA;AACA;AACA;EACEJ,YAAYA,CAACoS,CAAS,EAAa;IACjC,OAAO,IAAI,CAAC3E,QAAQ,CAAC2E,CAAC,CAAC,CAACpS,YAAY,CAAC,CAAC;EACxC;;EAEA;AACF;AACA;AACA;AACA;EACE4C,MAAMA,CAACwP,CAAS,EAAEtT,GAAQ,EAAQ;IAChC,IAAI,CAAC2O,QAAQ,CAAC2E,CAAC,CAAC,CAACxP,MAAM,CAAC9D,GAAG,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;AACA;EACE+D,eAAeA,CAACuP,CAAS,EAAEtP,OAAmB,EAAQ;IACpD,IAAI,CAAC2K,QAAQ,CAAC2E,CAAC,CAAC,CAACvP,eAAe,CAACC,OAAO,CAAC;EAC3C;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,oBAAoBA,CAACqP,CAAS,EAAEpP,KAAa,EAAQ;IACnD,IAAI,CAACyK,QAAQ,CAAC2E,CAAC,CAAC,CAACrP,oBAAoB,CAACC,KAAK,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;EACEqP,WAAWA,CAAA,EAA6B;IACtC;IACA,OAAO,IAAI,CAACpL,SAAS,CAACL,SAAS,CAACE,QAAQ,CAAC+H,OAAO,CAAC,CAAC;EACpD;;EAEA;AACF;AACA;AACA;EACEyD,cAAcA,CAAA,EAA6B;IACzC,OAAO,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAACtL,SAAS,CAACL,SAAS,CAACC,WAAW,CAACgI,OAAO,CAAC,CAAC,CAAC;EAChF;;EAEA;AACF;AACA;AACA;EACE0D,kBAAkBA,CAACC,GAA6B,EAA4B;IAC1E;IACA;IACA,MAAMC,CAAC,GAAG,GAAG,GAAG9R,IAAI,CAACb,GAAG,CAAC,IAAI,CAACuO,YAAY,CAACnO,CAAC,EAAES,IAAI,CAACb,GAAG,CAAC,IAAI,CAACuO,YAAY,CAAClO,CAAC,EAAE,IAAI,CAACkO,YAAY,CAACjO,CAAC,CAAC,CAAC;IACjG,OAAO,IAAI0F,0CAAO,CAAC,CAAC,CAAC4M,SAAS,CAACF,GAAG,CAAC,CAAC7B,QAAQ,CAAC,IAAI,CAAC9K,iBAAiB,CAAC,CAAC8M,cAAc,CAACF,CAAC,CAAC,CAAC5D,OAAO,CAAC,CAAC;EAClG;EAEA+D,qBAAqBA,CAACC,CAAqB,EAAQ;IACjD,IAAI,CAAC9D,mBAAmB,CAACvE,IAAI,CAACqI,CAAC,CAAC;EAClC;EAEAC,wBAAwBA,CAACD,CAAqB,EAAQ;IACpD,IAAIA,CAAC,EAAE;MACL,MAAMpT,CAAC,GAAG,IAAI,CAACsP,mBAAmB,CAACgE,OAAO,CAACF,CAAC,CAAC;MAC7C,IAAIpT,CAAC,KAAK,CAAC,CAAC,EAAE;QACZ,IAAI,CAACsP,mBAAmB,CAACiE,MAAM,CAACvT,CAAC,EAAE,CAAC,CAAC;MACvC;IACF;EACF;EAEAwT,4BAA4BA,CAAA,EAAS;IACnC,IAAI,CAAClE,mBAAmB,GAAG,EAAE;EAC/B;AACF;;;;;;;;;;;;;;;ACraA;AACA,MAAMmE,sBAAsB,GAAG,WAAW;AAE3B,MAAMC,WAAW,CAAC;EAM/B;;EAGA;EACA;;EAEAxV,WAAWA,CAACyV,OAAO,GAAGF,sBAAsB,EAAE;IAC5C,IAAI,CAACG,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;IACxB,IAAI,CAACF,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACG,WAAW,GAAG,CAAC;IAEpB,IAAI,CAAC5G,KAAK,GAAG,IAAI;IACjB,IAAI,CAACG,IAAI,GAAG,IAAI;EAClB;;EAEA;EACA;EACA,IAAW4D,IAAIA,CAAA,EAAG;IAChB,OAAO,IAAI,CAAC6C,WAAW;EACzB;;EAEA;EACA,IAAWC,eAAeA,CAAA,EAAG;IAC3B,OAAO,IAAI,CAACH,OAAO,CAAC3C,IAAI;EAC1B;;EAEA;AACF;AACA;AACA;EACU+C,oBAAoBA,CAACC,KAAiB,EAAQ;IACpD,IAAI,CAACL,OAAO,CAACM,MAAM,CAACD,KAAK,CAACE,GAAG,CAAC;IAC9B,IAAI,CAACL,WAAW,IAAIG,KAAK,CAAC1V,IAAI,CAAC6V,UAAU;EAC3C;;EAEA;AACF;AACA;AACA;EACUC,mBAAmBA,CAACJ,KAAiB,EAAQ;IACnD,MAAM;MAAEK,IAAI;MAAEC;IAAK,CAAC,GAAGN,KAAK;IAE5B,IAAIK,IAAI,EAAE;MACRA,IAAI,CAACC,IAAI,GAAGA,IAAI;IAClB,CAAC,MAAM;MACL,IAAI,CAACrH,KAAK,GAAGqH,IAAI;IACnB;IAEA,IAAIA,IAAI,EAAE;MACRA,IAAI,CAACD,IAAI,GAAGA,IAAI;IAClB,CAAC,MAAM;MACL,IAAI,CAACjH,IAAI,GAAGiH,IAAI;IAClB;EACF;;EAEA;EACQE,eAAeA,CAACP,KAAiB,EAAQ;IAC/C,IAAI,IAAI,CAAC/G,KAAK,EAAE;MACd,IAAI,CAACA,KAAK,CAACoH,IAAI,GAAGL,KAAK;IACzB,CAAC,MAAM;MACL,IAAI,CAAC5G,IAAI,GAAG4G,KAAK;IACnB;IACAA,KAAK,CAACM,IAAI,GAAG,IAAI,CAACrH,KAAK;IACvB+G,KAAK,CAACK,IAAI,GAAG,IAAI;IACjB,IAAI,CAACpH,KAAK,GAAG+G,KAAK;EACpB;;EAEA;EACQQ,gBAAgBA,CAACR,KAAiB,EAAQ;IAChD,IAAIA,KAAK,KAAK,IAAI,CAAC/G,KAAK,EAAE;IAC1B,IAAI,CAACmH,mBAAmB,CAACJ,KAAK,CAAC;IAC/B,IAAI,CAACO,eAAe,CAACP,KAAK,CAAC;EAC7B;;EAEA;EACQS,SAASA,CAAA,EAAS;IACxB,IAAI,CAAC,IAAI,CAACrH,IAAI,EAAE;MACdzL,OAAO,CAAC+S,KAAK,CAAC,+EAA+E,CAAC;MAC9F;IACF;IAEA,IAAI,CAACX,oBAAoB,CAAC,IAAI,CAAC3G,IAAI,CAAC;IAEpC,IAAI,IAAI,CAACA,IAAI,CAACiH,IAAI,EAAE;MAClB,IAAI,CAACjH,IAAI,CAACiH,IAAI,CAACC,IAAI,GAAG,IAAI;IAC5B;IACA,IAAI,CAAClH,IAAI,GAAG,IAAI,CAACA,IAAI,CAACiH,IAAI;EAC5B;;EAEA;EACQM,KAAKA,CAACX,KAAiB,EAAQ;IACrC,IAAI,CAACD,oBAAoB,CAACC,KAAK,CAAC;IAChC,IAAI,CAACI,mBAAmB,CAACJ,KAAK,CAAC;EACjC;;EAEA;AACF;AACA;AACA;EACSY,MAAMA,CAACV,GAAW,EAAE5V,IAAiB,EAAW;IACrD,IAAIA,IAAI,CAAC6V,UAAU,GAAG,IAAI,CAACT,OAAO,EAAE;MAClC/R,OAAO,CAAC+S,KAAK,CAAC,qEAAqE,CAAC;MACpF,OAAO,KAAK;IACd;;IAEA;IACA;IACA,MAAMG,SAAS,GAAG,IAAI,CAACC,QAAQ,CAACZ,GAAG,CAAC;IACpC,IAAIW,SAAS,KAAK/D,SAAS,EAAE;MAC3B+D,SAAS,CAACvW,IAAI,GAAGA,IAAI;MACrB,OAAO,IAAI;IACb;;IAEA;IACA,MAAMyW,QAAoB,GAAG;MAAEzW,IAAI;MAAE+V,IAAI,EAAE,IAAI;MAAEC,IAAI,EAAE,IAAI;MAAEJ;IAAI,CAAC;IAClE,IAAI,CAACK,eAAe,CAACQ,QAAQ,CAAC;IAC9B,IAAI,CAACpB,OAAO,CAAC7T,GAAG,CAACoU,GAAG,EAAEa,QAAQ,CAAC;IAC/B,IAAI,CAAClB,WAAW,IAAIvV,IAAI,CAAC6V,UAAU;;IAEnC;IACA,OAAO,IAAI,CAACN,WAAW,GAAG,IAAI,CAACH,OAAO,EAAE;MACtC,IAAI,CAACe,SAAS,CAAC,CAAC;IAClB;IACA,OAAO,IAAI;EACb;;EAEA;EACQK,QAAQA,CAACZ,GAAW,EAA0B;IACpD,MAAMc,MAAM,GAAG,IAAI,CAACrB,OAAO,CAACsB,GAAG,CAACf,GAAG,CAAC;IACpC,IAAIc,MAAM,EAAE;MACV,IAAI,CAACR,gBAAgB,CAACQ,MAAM,CAAC;IAC/B;IACA,OAAOA,MAAM;EACf;;EAEA;EACOC,GAAGA,CAACf,GAAW,EAA2B;IAC/C,OAAO,IAAI,CAACY,QAAQ,CAACZ,GAAG,CAAC,EAAE5V,IAAI;EACjC;;EAEA;EACO4W,eAAeA,CAACC,MAAc,EAAQ;IAC3C,KAAK,MAAM,CAACjB,GAAG,EAAEF,KAAK,CAAC,IAAI,IAAI,CAACL,OAAO,CAACA,OAAO,CAAC,CAAC,EAAE;MACjD,IAAIO,GAAG,CAACkB,UAAU,CAACD,MAAM,CAAC,EAAE;QAC1B,IAAI,CAACR,KAAK,CAACX,KAAK,CAAC;MACnB;IACF;EACF;;EAEA;EACOqB,KAAKA,CAAA,EAAS;IACnB,OAAO,IAAI,CAACjI,IAAI,EAAE;MAChB,IAAI,CAACqH,SAAS,CAAC,CAAC;IAClB;EACF;AACF;;;;;;;;;;;;;;;;;;AC/KgC;AA4BzB,SAASa,iBAAiBA,CAAA,EAAe;EAC9C,OAAO;IACLxO,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACtBC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACxBC,SAAS,EAAE,IAAI;IACfC,QAAQ,EAAE,GAAG;IACbxF,QAAQ,EAAE;EACZ,CAAC;AACH;AAEO,SAASyE,UAAUA,CAACqP,UAAsB,EAAW;EAC1D,OAAO,IAAInP,0CAAO,CAACmP,UAAU,CAACzO,KAAK,CAAC,CAAC,CAAC,EAAEyO,UAAU,CAACzO,KAAK,CAAC,CAAC,CAAC,EAAEyO,UAAU,CAACzO,KAAK,CAAC,CAAC,CAAC,CAAC;AACnF;AAEO,SAASX,iBAAiBA,CAACoP,UAAsB,EAAW;EACjE,OAAO,IAAInP,0CAAO,CAACmP,UAAU,CAACxO,OAAO,CAAC,CAAC,CAAC,EAAEwO,UAAU,CAACxO,OAAO,CAAC,CAAC,CAAC,EAAEwO,UAAU,CAACxO,OAAO,CAAC,CAAC,CAAC,CAAC;AACzF;;;;;;;;;;;;;;;;;;AC7CgD;AAKhD;AACA;AACA;AACO,IAAK0O,aAAa,0BAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAA,OAAbA,aAAa;AAAA;AAsBlB,IAAKC,IAAI,0BAAJA,IAAI;EAAJA,IAAI;EAAJA,IAAI;EAAJA,IAAI;EAAJA,IAAI;EAAJA,IAAI;EAAA,OAAJA,IAAI;AAAA;;AAUhB;AACA;AACA;AACO,MAAMC,oBAAoB,CAAC;EAChC;;EAIA;;EAGA;;EAMA;;EAMA;;EAIA;;EAOA;;EAIA;;EAIA;;EAOA;AACF;AACA;AACA;EACE1X,WAAWA,CAAC2X,MAAe,EAAE;IAC3B,IAAI,CAACzO,WAAW,GAAG,IAAIf,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACvC,IAAI,CAACgB,QAAQ,GAAG,IAAIoO,wCAAK,CAAC,CAAC;IAC3B,IAAI,CAACnO,KAAK,GAAG,IAAIjB,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACjC,IAAI,CAACyP,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,QAAQ,GAAGJ,IAAI,CAACK,IAAI;IACzB,IAAI,CAACC,UAAU,GAAG,GAAG;IACrB,IAAI,CAACC,QAAQ,GAAG,IAAI7P,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACpC,IAAI,CAAC8P,gBAAgB,GAAG,CAAC,CAAC;IAC1B,IAAI,CAACC,SAAS,GAAG,GAAG;IACpB,IAAI,CAACC,QAAQ,GAAG,GAAG;IACnB,IAAI,CAACC,UAAU,GAAG,GAAG;IACrB,IAAI,CAACC,QAAQ,GAAG,GAAG;IACnB,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,MAAM,GAAG;MACZC,IAAI,EAAE,IAAIvQ,0CAAO,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;MACnCwQ,IAAI,EAAE,IAAIxQ,0CAAO,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;IACjC,CAAC;IACD,IAAI,CAACyQ,gBAAgB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IACvC,IAAI,CAACC,kBAAkB,GAAG,GAAG;IAC7B,IAAI,CAACC,oBAAoB,GAAG,GAAG;IAC/B,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,cAAc,GAAG,KAAK;IAC3B;IACA,IAAItB,MAAM,EAAE;MACV,IAAI,CAACuB,MAAM,GAAGlW,IAAI,CAACC,KAAK,CAAC0U,MAAM,CAACrO,SAAS,CAACxF,aAAa,CAACrB,CAAC,GAAG,CAAC,CAAC;MAC9D,IAAI,CAAC0W,OAAO,GAAG,IAAIpJ,KAAK,CAAC4H,MAAM,CAACrO,SAAS,CAACE,WAAW,CAAC,CAAClI,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;MAC5E,IAAI,CAAC8X,QAAQ,GAAG,IAAIrJ,KAAK,CAAC4H,MAAM,CAACrO,SAAS,CAACE,WAAW,CAAC,CAAClI,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MACvE,IAAI,CAAC+X,QAAQ,GAAG,IAAItJ,KAAK,CAAC4H,MAAM,CAACrO,SAAS,CAACE,WAAW,CAAC,CAAClI,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MACvE,IAAI,CAACgY,UAAU,GAAG,IAAIvJ,KAAK,CAAC4H,MAAM,CAACrO,SAAS,CAACE,WAAW,CAAC,CAAClI,IAAI,CAAC,CAAC,CAAC;IACnE,CAAC,MAAM;MACL,IAAI,CAAC4X,MAAM,GAAG,CAAC;MACf,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;MAChC,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAC3B,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAC3B,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC,CAAC;IACvB;IACA,IAAI,CAACC,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACC,UAAU,GAAG,IAAIpR,0CAAO,CAAC,CAAC,EAAE,CAAC,CAAC;EACrC;EAEOqR,gBAAgBA,CAAC9B,MAAc,EAAQ;IAC5C,IAAI,CAACuB,MAAM,GAAGlW,IAAI,CAACC,KAAK,CAAC0U,MAAM,CAACrO,SAAS,CAACxF,aAAa,CAACrB,CAAC,GAAG,CAAC,CAAC;IAC9D,IAAI,CAAC0W,OAAO,GAAG,IAAIpJ,KAAK,CAAC4H,MAAM,CAACrO,SAAS,CAACE,WAAW,CAAC,CAAClI,IAAI,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IAC5E,IAAI,CAAC8X,QAAQ,GAAG,IAAIrJ,KAAK,CAAC4H,MAAM,CAACrO,SAAS,CAACE,WAAW,CAAC,CAAClI,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACvE,IAAI,CAAC+X,QAAQ,GAAG,IAAItJ,KAAK,CAAC4H,MAAM,CAACrO,SAAS,CAACE,WAAW,CAAC,CAAClI,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACvE,IAAI,CAACgY,UAAU,GAAG,IAAIvJ,KAAK,CAAC4H,MAAM,CAACrO,SAAS,CAACE,WAAW,CAAC,CAAClI,IAAI,CAAC,CAAC,CAAC;EACnE;;EAEA;AACF;AACA;AACA;EACE,OAAeoY,YAAYA,CAACC,EAAa,EAAEC,EAAa,EAAW;IACjE,IAAID,EAAE,CAAC5T,MAAM,KAAK6T,EAAE,CAAC7T,MAAM,EAAE;MAC3B,OAAO,KAAK;IACd;IACA,KAAK,IAAIjE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6X,EAAE,CAAC5T,MAAM,EAAEjE,CAAC,EAAE,EAAE;MAClC,MAAM+X,KAAK,GAAGF,EAAE,CAAC7X,CAAC,CAAC;MACnB,MAAMgY,KAAK,GAAGF,EAAE,CAAC9X,CAAC,CAAC;MACnB,IAAI+X,KAAK,YAAY9J,KAAK,IAAI+J,KAAK,YAAY/J,KAAK,EAAE;QACpD,IAAI,CAAC,IAAI,CAAC2J,YAAY,CAACG,KAAK,EAAEC,KAAK,CAAC,EAAE;UACpC,OAAO,KAAK;QACd;MACF,CAAC,MAAM,IAAID,KAAK,KAAKC,KAAK,EAAE;QAC1B,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACSC,OAAOA,CAACC,EAAwB,EAAW;IAChD,KAAK,MAAM/D,GAAG,IAAIgE,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC,EAAE;MACnC,MAAMC,EAAE,GAAG,IAAI,CAAClE,GAAG,CAAC;MACpB,MAAMmE,EAAE,GAAGJ,EAAE,CAAC/D,GAAG,CAAC;MAClB,IAAIkE,EAAE,YAAYpK,KAAK,EAAE;QACvB,IAAI,CAAC2H,oBAAoB,CAACgC,YAAY,CAACS,EAAE,EAAEC,EAAE,CAAC,EAAE;UAC9C,OAAO,KAAK;QACd;MACF,CAAC,MAAM,IAAID,EAAE,IAAIA,EAAE,CAACzB,IAAI,KAAK7F,SAAS,EAAE;QACtC;QACA,MAAMwH,OAAO,GAAGF,EAAY;QAC5B,MAAMG,OAAO,GAAGF,EAAY;QAC5B,IAAI,CAACC,OAAO,CAAC3B,IAAI,CAACzG,MAAM,CAACqI,OAAO,CAAC5B,IAAI,CAAC,IAAI,CAAC2B,OAAO,CAAC1B,IAAI,CAAC1G,MAAM,CAACqI,OAAO,CAAC3B,IAAI,CAAC,EAAE;UAC5E,OAAO,KAAK;QACd;MACF,CAAC,MAAM,IAAIwB,EAAE,YAAYhS,0CAAO,IAAIgS,EAAE,YAAY/R,0CAAO,IAAI+R,EAAE,YAAY5C,wCAAK,EAAE;QAChF,IAAI,CAAC4C,EAAE,CAAClI,MAAM,CAACmI,EAAE,CAAC,EAAE;UAClB,OAAO,KAAK;QACd;MACF,CAAC,MAAM;QACL;QACA,IAAID,EAAE,KAAKC,EAAE,EAAE;UACb,OAAO,KAAK;QACd;MACF;IACF;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACE,OAAeG,aAAaA,CAAChQ,CAAY,EAAa;IACpD,MAAM1C,CAAY,GAAG,IAAIkI,KAAK,CAACxF,CAAC,CAACxE,MAAM,CAAC;IACxC,KAAK,IAAIjE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyI,CAAC,CAACxE,MAAM,EAAEjE,CAAC,EAAE,EAAE;MACjC,MAAMa,GAAG,GAAG4H,CAAC,CAACzI,CAAC,CAAC;MAChB,IAAIa,GAAG,YAAYoN,KAAK,EAAE;QACxBlI,CAAC,CAAC/F,CAAC,CAAC,GAAG,IAAI,CAACyY,aAAa,CAAC5X,GAAG,CAAC;MAChC,CAAC,MAAM;QACLkF,CAAC,CAAC/F,CAAC,CAAC,GAAGa,GAAG;MACZ;IACF;IACA,OAAOkF,CAAC;EACV;;EAEA;AACF;AACA;AACA;AACA;AACA;EACSyI,KAAKA,CAAA,EAAyB;IACnC,MAAMkK,GAAG,GAAG,IAAI9C,oBAAoB,CAAC,CAAC,CAAC,CAAC;IACxC,KAAK,MAAMzB,GAAG,IAAIgE,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC,EAAE;MACnC,MAAMvX,GAAG,GAAG,IAAI,CAACsT,GAAG,CAAC;MACrB,IAAItT,GAAG,YAAYoN,KAAK,EAAE;QACxByK,GAAG,CAACvE,GAAG,CAAC,GAAGyB,oBAAoB,CAAC6C,aAAa,CAAC5X,GAAG,CAAC;MACpD,CAAC,MAAM,IAAIsT,GAAG,KAAK,QAAQ,EAAE;QAC3B;QACAuE,GAAG,CAAC/B,MAAM,CAACE,IAAI,GAAG,IAAI,CAACF,MAAM,CAACE,IAAI,CAACrI,KAAK,CAAC,CAAC;QAC1CkK,GAAG,CAAC/B,MAAM,CAACC,IAAI,GAAG,IAAI,CAACD,MAAM,CAACC,IAAI,CAACpI,KAAK,CAAC,CAAC;MAC5C,CAAC,MAAM,IAAI3N,GAAG,YAAYwF,0CAAO,IAAIxF,GAAG,YAAYyF,0CAAO,IAAIzF,GAAG,YAAY4U,wCAAK,EAAE;QACnFiD,GAAG,CAACvE,GAAG,CAAC,GAAGtT,GAAG,CAAC2N,KAAK,CAAC,CAAC;MACxB,CAAC,MAAM,IAAI3N,GAAG,YAAY8X,MAAM,EAAE;QAChCD,GAAG,CAACvE,GAAG,CAAC,GAAG,EAAE,GAAGtT,GAAG;MACrB,CAAC,MAAM;QACL;QACA6X,GAAG,CAACvE,GAAG,CAAC,GAAGtT,GAAG;MAChB;IACF;IACA,OAAO6X,GAAG;EACZ;AACF;;;;;;;;;;;;;;;;ACpPO,MAAME,aAAyC,GAAG,CACvD,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,EACb,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EACf,CAAC,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CACd;AAOD;AACA;AACA;AACA,SAASC,QAAQA,CAACtX,CAAoB,EAAEuX,CAAS,EAAEC,CAAS,EAA4B;EACtF,IAAI9M,CAAC,EAAEC,CAAC,EAAEnG,CAAC;EACX,IAAIiT,EAAE,GAAG,CAAC;EACV,IAAIC,SAAS,CAAChV,MAAM,KAAK,CAAC,EAAE;IAC1B,MAAMiV,GAAG,GAAG3X,CAAa;IACxBuX,CAAC,GAAGI,GAAG,CAACJ,CAAC,EAAIC,CAAC,GAAGG,GAAG,CAACH,CAAC,EAAIC,EAAE,GAAGE,GAAG,CAAC3X,CAAE;EACxC,CAAC,MAAM;IACLyX,EAAE,GAAGzX,CAAW;EAClB;EACA,MAAMvB,CAAC,GAAGkB,IAAI,CAACC,KAAK,CAAC6X,EAAE,GAAG,CAAC,CAAC;EAC5B,MAAMG,CAAC,GAAGH,EAAE,GAAG,CAAC,GAAGhZ,CAAC;EACpB,MAAMoZ,CAAC,GAAGL,CAAC,IAAI,CAAC,GAAGD,CAAC,CAAC;EACrB,MAAMO,CAAC,GAAGN,CAAC,IAAI,CAAC,GAAGI,CAAC,GAAGL,CAAC,CAAC;EACzB,MAAMQ,CAAC,GAAGP,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAGI,CAAC,IAAIL,CAAC,CAAC;EAC/B,QAAQ9Y,CAAC,GAAG,CAAC;IACX,KAAK,CAAC;MACHiM,CAAC,GAAG8M,CAAC,EAAI7M,CAAC,GAAGoN,CAAC,EAAIvT,CAAC,GAAGqT,CAAE;MACzB;IACF,KAAK,CAAC;MACHnN,CAAC,GAAGoN,CAAC,EAAInN,CAAC,GAAG6M,CAAC,EAAIhT,CAAC,GAAGqT,CAAE;MACzB;IACF,KAAK,CAAC;MACHnN,CAAC,GAAGmN,CAAC,EAAIlN,CAAC,GAAG6M,CAAC,EAAIhT,CAAC,GAAGuT,CAAE;MACzB;IACF,KAAK,CAAC;MACHrN,CAAC,GAAGmN,CAAC,EAAIlN,CAAC,GAAGmN,CAAC,EAAItT,CAAC,GAAGgT,CAAE;MACzB;IACF,KAAK,CAAC;MACH9M,CAAC,GAAGqN,CAAC,EAAIpN,CAAC,GAAGkN,CAAC,EAAIrT,CAAC,GAAGgT,CAAE;MACzB;IACF,KAAK,CAAC;MACH9M,CAAC,GAAG8M,CAAC,EAAI7M,CAAC,GAAGkN,CAAC,EAAIrT,CAAC,GAAGsT,CAAE;MACzB;EACJ;EACA,OAAO,CAACnY,IAAI,CAACyK,KAAK,CAACM,CAAC,GAAG,GAAG,CAAC,EAAE/K,IAAI,CAACyK,KAAK,CAACO,CAAC,GAAG,GAAG,CAAC,EAAEhL,IAAI,CAACyK,KAAK,CAAC5F,CAAC,GAAG,GAAG,CAAC,CAAC;AACxE;;AAEA;AACA,SAASwT,GAAGA,CAACT,CAAC,EAAE;EACd,OAAO,YAAY;IACjBA,CAAC,GAAG5X,IAAI,CAACsY,IAAI,CAAC,KAAK,EAAEV,CAAC,CAAC,GAAG,CAAC,GAAG,UAAU;IACxC,OAAO,CAACA,CAAC,GAAG,UAAU,IAAI,UAAU;EACtC,CAAC;AACH;AACA;AACA,MAAMW,MAAM,GAAGF,GAAG,CAAC,GAAG,CAAC;;AAEvB;AACA;AACO,MAAMrR,sBAAsB,GAAIgH,KAAa,IAA+B;EACjF,IAAI,CAAC0J,aAAa,CAAC1J,KAAK,CAAC,EAAE;IACzB0J,aAAa,CAAC1J,KAAK,CAAC,GAAG2J,QAAQ,CAACY,MAAM,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,EAAEA,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC;EACvF;EACA,OAAOb,aAAa,CAAC1J,KAAK,CAAC;AAC7B,CAAC;;;;;;;;;;;;;;;;ACpEM,IAAWwK,QAAQ,0BAARA,QAAQ;EAARA,QAAQ,CAARA,QAAQ;EAARA,QAAQ,CAARA,QAAQ;EAARA,QAAQ,CAARA,QAAQ;EAARA,QAAQ,CAARA,QAAQ;EAARA,QAAQ,CAARA,QAAQ;EAAA,OAARA,QAAQ;AAAA;AAQ1B,MAAMC,mBAAkD,GAAG;EACzD,CAACD,QAAQ,CAACE,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC,IAAI,EAAE,aAAa,EAAE,cAAc,CAAC,CAAC;EACtE,CAACH,QAAQ,CAACI,MAAM,GAAG,IAAID,GAAG,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;EAC7D,CAACH,QAAQ,CAACK,MAAM,GAAG,IAAIF,GAAG,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;EAC7D,CAACH,QAAQ,CAACM,IAAI,GAAG,IAAIH,GAAG,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;EACtD,CAACH,QAAQ,CAACO,GAAG,GAAG,IAAIJ,GAAG,CAAC,CAAC,GAAG,EAAE,KAAK,EAAE,MAAM,CAAC;AAC9C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASK,aAAaA,CAACC,IAAY,EAAwB;EAChE,KAAK,MAAM,CAACjT,QAAQ,EAAEkT,eAAe,CAAC,IAAIjC,MAAM,CAACvE,OAAO,CAAC+F,mBAAmB,CAAC,EAAE;IAC7E,IAAIS,eAAe,CAACC,GAAG,CAACF,IAAI,CAAC,EAAE;MAC7B,OAAOjT,QAAQ;IACjB;EACF;AACF;;;;;;;;;;;;;;;;;;;;;ACjCsC;AAEJ;AAE2B;AAEC;AAIvD,MAAMsG,QAAQ,CAAC;EACpBsC,IAAI,GAAG,CAAC;EACR;;EAEA;;EAEA;AACF;AACA;AACA;;EAEE;EACAvB,SAAS,GAAG,IAAI+L,uCAAI,CAAC,IAAIjU,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAIA,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EAEhE;AACF;AACA;AACA;EACEwJ,gBAAgB,GAAG,KAAK;AAC1B;AAEO,SAAS2K,gBAAgBA,CAACC,IAAc,EAAU;EACvD,MAAM;IAAEra,GAAG;IAAEC;EAAI,CAAC,GAAGoa,IAAI,CAAClM,SAAS;EACnC,OAAO,GAAGkM,IAAI,CAAC5T,eAAe,IAAI4T,IAAI,CAAC3K,IAAI,MAAM1P,GAAG,CAACK,CAAC,IAAIJ,GAAG,CAACI,CAAC,OAAOL,GAAG,CAACM,CAAC,IAAIL,GAAG,CAACK,CAAC,OAAON,GAAG,CAACO,CAAC,IAAIN,GAAG,CAACM,CAAC,GAAG;AAC9G;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AASA;AACA;AACA;AACA;AACA;AACA;;AAsCA;AACO,MAAe+Z,sBAAsB,CAA0B;EACpE;;EAGA;AACF;AACA;AACA;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAQEC,mBAAmBA,CAACC,WAAgC,EAAQ;IAC1D;EAAA;EAGFC,uBAAuBA,CAACC,KAAc,EAAQ;IAC5C;IACA;EAAA;EAGFC,kBAAkBA,CAACC,QAAyC,EAAQ;IAClE;EAAA;EAGF,MAAMC,YAAYA,CAACrN,QAAkB,EAAE0C,eAAoC,EAAmB;IAC5F,MAAM;MAAE9I,SAAS;MAAEoG,QAAQ,EAAEsN;IAAiB,CAAC,GAAG,MAAM,IAAI,CAACC,eAAe,CAACvN,QAAQ,CAAC;IACtF,MAAMwN,GAAG,GAAG,IAAIzN,kDAAM,CAACnG,SAAS,EAAE0T,gBAAgB,EAAE,IAAI,CAAC;IACzDE,GAAG,CAACrJ,mBAAmB,GAAGzB,eAAe;IACzC8K,GAAG,CAAC3M,aAAa,GAAG8L,2EAAoB,CAAC/S,SAAS,CAAC;IACnD,OAAO4T,GAAG;EACZ;EAEA,MAAMpK,cAAcA,CAClB6E,MAAc,EACdwF,gBAA2B,EAC3B/K,eAAoC,EACrB;IACf,MAAMgL,gBAAgB,GAAGA,CAAC9T,SAAqB,EAAEoG,QAAmB,KAAW;MAC7E,IAAIpG,SAAS,EAAE;QACbqO,MAAM,CAACrO,SAAS,GAAG,IAAID,qDAAU,CAACC,SAAS,CAAC;QAC5CqO,MAAM,CAACnG,gBAAgB,CAAC,CAAC;MAC3B;MACAmG,MAAM,CAACjI,QAAQ,GAAG;QAAE,GAAGA,QAAQ;QAAE,GAAG6M;MAAK,CAAC;IAC5C,CAAC;IAED,MAAMc,aAAqC,GAAGA,CAACC,cAAc,EAAEC,MAAM,EAAEC,UAAU,EAAEC,MAAM,EAAEC,SAAS,KAAK;MACvG,KAAK,IAAI5b,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwb,cAAc,CAACvX,MAAM,EAAEjE,CAAC,EAAE,EAAE;QAC9C,MAAM4R,YAAY,GAAG4J,cAAc,CAACxb,CAAC,CAAC;QACtC,MAAM3B,KAAK,GAAGod,MAAM,CAACzb,CAAC,CAAC;QACvB,MAAMzB,IAAI,GAAGmd,UAAU,CAAC1b,CAAC,CAAC;QAC1B,MAAMqS,KAAK,GAAGsJ,MAAM,CAAC3b,CAAC,CAAC;QACvB,IAAI4b,SAAS,EAAE;UACb/F,MAAM,CAAC5D,uBAAuB,CAACL,YAAY,EAAErT,IAAI,EAAEqd,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,EAAEvJ,KAAK,EAAEhU,KAAK,CAAC;QAC9F,CAAC,MAAM;UACLwX,MAAM,CAACvD,wBAAwB,CAACV,YAAY,EAAErT,IAAI,EAAE8T,KAAK,EAAEhU,KAAK,CAAC;QACnE;QACAiS,eAAe,GAAGuF,MAAM,EAAEjE,YAAY,CAAC;MACzC;IACF,CAAC;IAED,MAAM6I,IAAI,GAAG;MAAE,GAAG5E,MAAM,CAACjI,QAAQ;MAAE,GAAGyN;IAAiB,CAAC;IACxD,OAAO,IAAI,CAACQ,kBAAkB,CAAChG,MAAM,CAACrO,SAAS,CAACA,SAAS,EAAEiT,IAAI,EAAEa,gBAAgB,EAAEC,aAAa,CAAC;EACnG;AACF;;;;;;;;;;;;;;;;;;;ACjMsC;AAOV;AACuC;AAId;;AAOrD;;AAgDA;;AAEA,MAAMQ,gBAAgB,GAAIC,IAAmB,IAA+B;EAC1E;EACA;EACA;EACA,MAAMC,EAAE,GAAID,IAAI,CAACE,YAAY,GAAGF,IAAI,CAACvd,KAAK,GAAIud,IAAI,CAACG,UAAU;EAC7D,MAAMC,EAAE,GAAIJ,IAAI,CAACK,YAAY,GAAGL,IAAI,CAACtd,MAAM,GAAIsd,IAAI,CAACM,WAAW;EAC/D,MAAMC,EAAE,GAAGP,IAAI,CAACQ,YAAY;EAC5B,OAAO,CAACP,EAAE,EAAEG,EAAE,EAAEG,EAAE,CAAC;AACrB,CAAC;AAED,MAAME,gBAAgB,GAAIT,IAAmB,IAAgB;EAC3D,MAAM,CAACC,EAAE,EAAEG,EAAE,EAAEG,EAAE,CAAC,GAAGR,gBAAgB,CAACC,IAAI,CAAC;EAC3C;EACA;EACA,MAAMU,EAA4B,GAAGV,IAAI,CAAC7U,SAAS,EAAEC,WAAW,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC7EsV,EAAE,CAAC,CAAC,CAAC,GAAIA,EAAE,CAAC,CAAC,CAAC,GAAGV,IAAI,CAACG,UAAU,GAAIH,IAAI,CAACvd,KAAK;EAC9Cie,EAAE,CAAC,CAAC,CAAC,GAAIA,EAAE,CAAC,CAAC,CAAC,GAAGV,IAAI,CAACM,WAAW,GAAIN,IAAI,CAACtd,MAAM;EAChD,OAAO;IACLP,IAAI,EAAE6d,IAAI,CAAC7d,IAAI;IACfqI,aAAa,EAAE,CAACwV,IAAI,CAACW,IAAI,EAAEX,IAAI,CAACY,IAAI,CAAC;IACrC5a,aAAa,EAAE,CAACga,IAAI,CAACG,UAAU,EAAEH,IAAI,CAACM,WAAW,EAAEN,IAAI,CAACa,KAAK,CAAC;IAC9DpW,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC1BC,mBAAmB,EAAEsV,IAAI,CAAChO,QAAQ;IAClCrH,YAAY,EAAEqV,IAAI,CAACc,aAAa;IAChClW,aAAa,EAAEoV,IAAI,CAACe,cAAc;IAClClW,eAAe,EAAE,CAAC;IAClBC,mBAAmB,EAAE,CACnB;MACEC,KAAK,EAAE,CAACiV,IAAI,CAACnU,KAAK,IAAI,CAAC,EAAEmU,IAAI,CAAChO,QAAQ,EAAEgO,IAAI,CAACa,KAAK,EAAEb,IAAI,CAACM,WAAW,EAAEN,IAAI,CAACG,UAAU,CAAC;MACtFnV,OAAO,EAAE,CAACgV,IAAI,CAACgB,UAAU,IAAI,CAAC,EAAE,CAAC,EAAET,EAAE,EAAEH,EAAE,EAAEH,EAAE,CAAC;MAC9ChV,SAAS,EAAE+U,IAAI,CAACiB,eAAe,IAAI,IAAI;MACvC/V,QAAQ,EAAE8U,IAAI,CAACkB,SAAS,IAAI,GAAG;MAC/Bxb,QAAQ,EAAE;IACZ,CAAC,CACF;IAEDyF,SAAS,EAAE;MACTC,WAAW,EAAEsV,EAAE;MACfrV,QAAQ,EAAE2U,IAAI,CAAC7U,SAAS,EAAEE,QAAQ,GAAG2U,IAAI,CAAC7U,SAAS,CAACE,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACxEC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;IACjB,CAAC;IAED6V,QAAQ,EAAE;MACR,GAAGnB,IAAI,CAACmB,QAAQ;MAChB;MACAC,kBAAkB,EAAE,CAACpB,IAAI,CAACvd,KAAK,EAAEud,IAAI,CAACtd,MAAM,EAAEsd,IAAI,CAACa,KAAK,CAAC;MACzDQ,yBAAyB,EAAE,CAACrB,IAAI,CAACE,YAAY,EAAEF,IAAI,CAACK,YAAY,EAAEL,IAAI,CAACQ,YAAY;IACrF;EACF,CAAC;AACH,CAAC;AAED,MAAMc,mBAAmB,SAAS5C,qEAAsB,CAAC;EAGvD6C,YAAY,GAAG,KAAK;EAIpBrf,WAAWA,CAACsf,IAAuB,EAAEC,KAAmB,EAAE;IACxD,KAAK,CAAC,CAAC;IAEP,IAAIxP,KAAK,CAACyP,OAAO,CAACF,IAAI,CAAC,EAAE;MACvB,IAAI,CAACA,IAAI,GAAGA,IAAI;IAClB,CAAC,MAAM;MACL,IAAI,CAACA,IAAI,GAAG,CAACA,IAAI,CAAC;IACpB;IAEA,IAAI,CAACG,QAAQ,GAAG,IAAI1P,KAAK,CAAC,IAAI,CAACuP,IAAI,CAACvZ,MAAM,CAAC;IAC3C,IAAI,CAACwZ,KAAK,GAAGA,KAAK;EACpB;EAEA,MAAcG,gBAAgBA,CAAC9N,IAAY,EAA0B;IACnE,MAAM+N,UAAU,GAAG,IAAI,CAACF,QAAQ,CAAC7N,IAAI,CAAC;IACtC,IAAI+N,UAAU,EAAE;MACd,OAAOA,UAAU;IACnB;IAEA,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,IAAI,CAACP,IAAI,CAAC1N,IAAI,CAAC,CAAC;IAC7C,MAAMtI,SAAS,GAAI,MAAMsW,QAAQ,CAAC9B,IAAI,CAAC,CAAmB;IAE1DxU,SAAS,CAACyV,eAAe,GAAGzV,SAAS,CAACyV,eAAe,IAAI,IAAI;IAC7DzV,SAAS,CAACK,KAAK,GAAGL,SAAS,CAACK,KAAK,IAAI,IAAI,CAAC2V,IAAI,CAACvZ,MAAM;IACrD,IAAI,CAAC0Z,QAAQ,CAAC7N,IAAI,CAAC,GAAGtI,SAAS;IAC/B,OAAOA,SAAS;EAClB;EAEAqT,uBAAuBA,CAACmD,IAAa,EAAQ;IAC3C,IAAI,CAACT,YAAY,GAAGS,IAAI;EAC1B;EAEA,MAAMpN,QAAQA,CAAChD,QAAkB,EAAyB;IACxD,MAAM+P,QAAQ,GAAG,MAAM,IAAI,CAACC,gBAAgB,CAAChQ,QAAQ,CAACkC,IAAI,CAAC;IAE3D,MAAM,CAACmM,EAAE,EAAEG,EAAE,EAAEG,EAAE,CAAC,GAAGR,gBAAgB,CAAC4B,QAAQ,CAAC;IAE/C,MAAMM,CAAa,GAAG;MACpBlX,KAAK,EAAE,CAAC4W,QAAQ,CAAC9V,KAAK,IAAI,CAAC,EAAE8V,QAAQ,CAAC3P,QAAQ,EAAE2P,QAAQ,CAACd,KAAK,EAAEc,QAAQ,CAACrB,WAAW,EAAEqB,QAAQ,CAACxB,UAAU,CAAC;MAC1GnV,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAEuV,EAAE,EAAEH,EAAE,EAAEH,EAAE,CAAC;MAC3BhV,SAAS,EAAE0W,QAAQ,CAACV,eAAe,IAAI,IAAI;MAC3Cvb,QAAQ,EAAE,OAAO;MACjBwF,QAAQ,EAAEyW,QAAQ,CAACT,SAAS,IAAI;IAClC,CAAC;IACD,OAAO,CAACe,CAAC,CAAC;EACZ;EAEA,MAAM9C,eAAeA,CAACvN,QAAkB,EAA6B;IACnE,MAAM+P,QAAQ,GAAG,MAAM,IAAI,CAACC,gBAAgB,CAAChQ,QAAQ,CAACkC,IAAI,CAAC;IAC3D,OAAO;MAAEtI,SAAS,EAAEiV,gBAAgB,CAACkB,QAAQ,CAAC;MAAE/P;IAAS,CAAC;EAC5D;EAEA,MAAMiO,kBAAkBA,CACtBrU,SAAoB,EACpBoG,QAAkB,EAClB0N,gBAAqE,EACrE4C,MAA8B,EACf;IACf;IACA;IACA;IACA;IACA,MAAMP,QAAQ,GAAG,MAAM,IAAI,CAACC,gBAAgB,CAAChQ,QAAQ,CAACkC,IAAI,CAAC;IAE3D,IAAIqO,MAAM,GAAGR,QAAQ,EAAEQ,MAAM;IAC7B,IAAI,CAACA,MAAM,EAAE;MACX;IACF;IAEA,MAAMC,iBAAiB,GAAGxQ,QAAQ,CAACI,QAAQ;IAC3C,IAAIoQ,iBAAiB,EAAE;MACrB;MACAD,MAAM,GAAGA,MAAM,CAACE,MAAM,CAAC,CAAC;QAAErQ;MAAS,CAAC,KAAKA,QAAQ,CAACgC,IAAI,CAAEsO,EAAE,IAAKF,iBAAiB,CAACnO,QAAQ,CAACqO,EAAE,CAAC,CAAC,CAAC;IACjG;;IAEA;IACA,MAAMC,SAAS,GAAG,IAAI,CAACf,IAAI,CAAC5P,QAAQ,CAACkC,IAAI,CAAC,CAAC0O,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IAChEL,MAAM,GAAGA,MAAM,CAAC9S,GAAG,CAAEoT,OAAO,KAAM;MAAE,GAAGA,OAAO;MAAEtgB,IAAI,EAAEogB,SAAS,GAAGE,OAAO,CAACtgB;IAAK,CAAC,CAAC,CAAC;;IAElF;IACA,MAAM+c,gBAAgB,GAAG;MACvB,GAAGtN,QAAQ;MACX;MACAW,SAAS,EAAE,IAAI+L,uCAAI,CAAC,IAAIjU,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAIA,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAC/DQ,eAAe,EAAE,CAAC;MAClB;MACAmH,QAAQ,EAAEmQ,MAAM,CAACO,OAAO,CAAC,CAAC;QAAE1Q;MAAS,CAAC,KAAKA,QAAQ;IACrD,CAAC;IACDsN,gBAAgB,CAACvK,SAAS,EAAEmK,gBAAgB,CAAC;IAE7C,MAAM,CAAC5Z,CAAC,EAAEC,CAAC,CAAC,GAAGyG,+DAAgB,CAACR,SAAS,CAAC;IAC1C,MAAMmX,aAAa,GAAGA,CACpBL,EAAY,EACZjgB,KAAmB,EACnBE,IAA8B,EAC9Bod,MAA0B,KACvBuC,MAAM,CAACI,EAAE,EAAEjgB,KAAK,EAAEE,IAAI,EAAEod,MAAM,EAAE,CAACra,CAAC,EAAEC,CAAC,CAAC,CAAC;IAC5C,MAAM+b,mBAAmB,CAACsB,mBAAmB,CAACT,MAAM,EAAEQ,aAAa,EAAE,IAAI,CAAClB,KAAK,EAAE,IAAI,CAACF,YAAY,CAAC;EACrG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,aAAaqB,mBAAmBA,CAC9BC,UAAiC,EACjCX,MAA8B,EAC9BT,KAAmB,EACnBF,YAAY,GAAG,KAAK,EACL;IACf,MAAMuB,oBAA8B,GAAG,EAAE;IACzC,MAAMC,kBAAgC,GAAG,EAAE;IAC3C,MAAMC,iBAA2C,GAAG,EAAE;IACtD,MAAMC,mBAAuC,GAAG,EAAE;IAElD,MAAMC,aAAa,GAAGL,UAAU,CAACxT,GAAG,CAAC,MAAOpL,KAAK,IAAK;MACpD;MACA;MACA;MACA,IAAIkf,QAAQ,GAAG,IAAI;MACnB,KAAK,IAAI3c,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtB,IAAI,CAACd,GAAG,CAACH,KAAK,CAAC+N,QAAQ,CAAC/J,MAAM,EAAE,CAAC,CAAC,EAAE,EAAEzB,CAAC,EAAE;QAC3D,MAAM4c,OAAO,GAAGnf,KAAK,CAAC+N,QAAQ,CAACxL,CAAC,CAAC;QACjC,MAAM6c,WAAW,GAAG5B,KAAK,EAAEvI,GAAG,CAAC,GAAGjV,KAAK,CAAC9B,IAAI,IAAIihB,OAAO,EAAE,CAAC;QAC1D,IAAIC,WAAW,EAAE;UACf;UACA,MAAMC,WAAW,GAAG,IAAI9gB,UAAU,CAAC6gB,WAAW,CAAC;UAC/C,IAAI9B,YAAY,EAAE;YAChB;YACAuB,oBAAoB,CAAC/T,IAAI,CAACqU,OAAO,CAAC;YAClCL,kBAAkB,CAAChU,IAAI,CAAC,OAAO,CAAC;YAChCiU,iBAAiB,CAACjU,IAAI,CAACuU,WAAW,CAAC;YACnCL,mBAAmB,CAAClU,IAAI,CAAC+Q,iEAAY,CAACwD,WAAW,CAAC,CAAC;UACrD,CAAC,MAAM;YACLpB,MAAM,CAAC,CAACkB,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE,CAACE,WAAW,CAAC,EAAE,CAACxD,iEAAY,CAACwD,WAAW,CAAC,CAAC,CAAC;UAC1E;QACF,CAAC,MAAM;UACLH,QAAQ,GAAG,KAAK;UAChB;UACA;QACF;MACF;;MAEA;MACA;MACA,IAAIA,QAAQ,EAAE;QACZ;MACF;MAEA,MAAMrB,QAAQ,GAAG,MAAMC,KAAK,CAAC9d,KAAK,CAAC9B,IAAI,EAAE;QAAEohB,IAAI,EAAE;MAAO,CAAC,CAAC;MAC1D,MAAMC,IAAI,GAAG,MAAM1B,QAAQ,CAAC0B,IAAI,CAAC,CAAC;MAClC,MAAMC,MAAM,GAAG,MAAMC,iBAAiB,CAACF,IAAI,CAAC;MAE5C,MAAMG,MAAM,GAAG,IAAIC,eAAe,CAACH,MAAM,CAAChhB,KAAK,EAAEghB,MAAM,CAAC/gB,MAAM,CAAC;MAC/D,MAAMmhB,GAAG,GAAGF,MAAM,CAACG,UAAU,CAAC,IAAI,CAA6C;MAC/E,IAAI,CAACD,GAAG,EAAE;QACRje,OAAO,CAACqB,GAAG,CAAC,uCAAuC,GAAGhD,KAAK,CAAC9B,IAAI,CAAC;QACjE;MACF;MACA0hB,GAAG,CAACE,wBAAwB,GAAG,MAAM;MACrCF,GAAG,CAACG,WAAW,GAAG,GAAG;MACrBH,GAAG,CAACI,SAAS,CAACR,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;MAC3B,MAAMS,KAAK,GAAGL,GAAG,CAACM,YAAY,CAAC,CAAC,EAAE,CAAC,EAAEV,MAAM,CAAChhB,KAAK,EAAEghB,MAAM,CAAC/gB,MAAM,CAAC;MAEjE,MAAM0hB,YAA0B,GAAG,EAAE;MACrC,MAAMnc,MAAM,GAAGwb,MAAM,CAAChhB,KAAK,GAAGghB,MAAM,CAAC/gB,MAAM;;MAE3C;MACA,KAAK,IAAI4f,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGpd,IAAI,CAACd,GAAG,CAACH,KAAK,CAAC+N,QAAQ,CAAC/J,MAAM,EAAE,CAAC,CAAC,EAAE,EAAEqa,EAAE,EAAE;QAC9D8B,YAAY,CAACrV,IAAI,CAAC,IAAIvM,UAAU,CAACyF,MAAM,CAAC,CAAC;MAC3C;;MAEA;MACA,MAAMoc,YAAgC,GAAG,EAAE;MAC3C,KAAK,IAAI7d,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtB,IAAI,CAACd,GAAG,CAACH,KAAK,CAAC+N,QAAQ,CAAC/J,MAAM,EAAE,CAAC,CAAC,EAAE,EAAEzB,CAAC,EAAE;QAC3D,IAAI7D,MAAM,GAAG4O,QAAQ;QACrB,IAAI3O,MAAM,GAAG,CAAC2O,QAAQ;QACtB,KAAK,IAAI0O,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGhY,MAAM,EAAEgY,EAAE,EAAE,EAAE;UAClCmE,YAAY,CAAC5d,CAAC,CAAC,CAACyZ,EAAE,CAAC,GAAGiE,KAAK,CAAC3hB,IAAI,CAAC0d,EAAE,GAAG,CAAC,GAAGzZ,CAAC,CAAC;UAC5C7D,MAAM,GAAGuC,IAAI,CAACd,GAAG,CAACzB,MAAM,EAAEyhB,YAAY,CAAC5d,CAAC,CAAC,CAACyZ,EAAE,CAAC,CAAC;UAC9Crd,MAAM,GAAGsC,IAAI,CAACb,GAAG,CAACzB,MAAM,EAAEwhB,YAAY,CAAC5d,CAAC,CAAC,CAACyZ,EAAE,CAAC,CAAC;QAChD;QACAoE,YAAY,CAAC7d,CAAC,CAAC,GAAG,CAAC7D,MAAM,EAAEC,MAAM,CAAC;MACpC;;MAEA;;MAEA,KAAK,IAAI0f,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGpd,IAAI,CAACd,GAAG,CAACH,KAAK,CAAC+N,QAAQ,CAAC/J,MAAM,EAAE,CAAC,CAAC,EAAE,EAAEqa,EAAE,EAAE;QAC9D,MAAMc,OAAO,GAAGnf,KAAK,CAAC+N,QAAQ,CAACsQ,EAAE,CAAC;QAClCb,KAAK,EAAE5I,MAAM,CAAC,GAAG5U,KAAK,CAAC9B,IAAI,IAAIihB,OAAO,EAAE,EAAEgB,YAAY,CAAC9B,EAAE,CAAC,CAAC;QAC3D;QACA;QACA,IAAIf,YAAY,EAAE;UAChBuB,oBAAoB,CAAC/T,IAAI,CAACqU,OAAO,CAAC;UAClCL,kBAAkB,CAAChU,IAAI,CAAC,OAAO,CAAC;UAChCiU,iBAAiB,CAACjU,IAAI,CAACqV,YAAY,CAAC9B,EAAE,CAAC,CAAC;UACxCW,mBAAmB,CAAClU,IAAI,CAACsV,YAAY,CAAC/B,EAAE,CAAC,CAAC;QAC5C,CAAC,MAAM;UACLJ,MAAM,CAAC,CAACkB,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE,CAACgB,YAAY,CAAC9B,EAAE,CAAC,CAAC,EAAE,CAAC+B,YAAY,CAAC/B,EAAE,CAAC,CAAC,EAAE,CAACmB,MAAM,CAAChhB,KAAK,EAAEghB,MAAM,CAAC/gB,MAAM,CAAC,CAAC;QACrG;MACF;IACF,CAAC,CAAC;IAEF,MAAM4hB,OAAO,CAACC,GAAG,CAACrB,aAAa,CAAC;IAChC,IAAI3B,YAAY,EAAE;MAChBW,MAAM,CAACY,oBAAoB,EAAEC,kBAAkB,EAAEC,iBAAiB,EAAEC,mBAAmB,CAAC;IAC1F;EACF;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1VsC;AAEA;AAC2B;AAEjE;AACA;AACqC;AAKuC;AAMhD;AAOI;AAC0C;AAClB;AASzB;AASkE;AAC5B;AAErE,MAAM6C,2BAA2B,GAAG,yBAAyB;;AAE7D;AACA,SAASC,cAAcA,CACrBzC,WAAiD,EACjDjhB,KAA0B,EAC4E;EACtG;EACA;EACA,IAAI+B,GAAG,GAAGkf,WAAW,CAAC,CAAC,CAAC;EACxB,IAAIjf,GAAG,GAAGif,WAAW,CAAC,CAAC,CAAC;EACxB,KAAK,IAAItf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsf,WAAW,CAACrb,MAAM,EAAEjE,CAAC,EAAE,EAAE;IAC3C,MAAMa,GAAG,GAAGye,WAAW,CAACtf,CAAC,CAAC;IAC1B,IAAIa,GAAG,GAAGT,GAAG,EAAE;MACbA,GAAG,GAAGS,GAAG;IACX;IACA,IAAIA,GAAG,GAAGR,GAAG,EAAE;MACbA,GAAG,GAAGQ,GAAG;IACX;EACF;EAEA,IAAIxC,KAAK,KAAK,SAAS,EAAE;IACvB;IACA,MAAM2jB,GAAG,GAAG,IAAIC,YAAY,CAAC3C,WAAW,CAACrb,MAAM,CAAC;IAChD,KAAK,IAAIjE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsf,WAAW,CAACrb,MAAM,EAAEjE,CAAC,EAAE,EAAE;MAC3CgiB,GAAG,CAAChiB,CAAC,CAAC,GAAGsf,WAAW,CAACtf,CAAC,CAAC;IACzB;IACA3B,KAAK,GAAG,SAAS;IACjBihB,WAAW,GAAG0C,GAAG;EACnB;EAEA,OAAO;IAAEzjB,IAAI,EAAE+gB,WAAW;IAAEjhB,KAAK;IAAE+B,GAAG;IAAEC;EAAI,CAAC;AAC/C;AA6BA,MAAM6hB,qBAAqB,GAAG;EAC5BC,mBAAmB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAqC;EACrEC,iBAAiB,EAAE;AACrB,CAAC;AAED,MAAMC,aAAa,SAAS3H,qEAAsB,CAAC;EACjD;;EAEA;;EAGA;EACA;;EAGQ6C,YAAY,GAAG,KAAK;EAEpBrf,WAAWA;EACjB;AACJ;AACA;AACA;EACYokB,OAAqB,EAC7B;EACQC,YAAsC,EAC9C;EACQC,YAAoC,GAAGN,qBAAqB,EACpE;EACQO,kBAAuC,GAAG,EAAE,EACpD;IACA,KAAK,CAAC,CAAC;IAAC,KARAH,OAAqB,GAArBA,OAAqB;IAAA,KAErBC,YAAsC,GAAtCA,YAAsC;IAAA,KAEtCC,YAAoC,GAApCA,YAAoC;IAAA,KAEpCC,kBAAuC,GAAvCA,kBAAuC;EAGjD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,aAAaC,YAAYA,CACvBlF,IAAuB,EACvBmF,MAAyB,GAAG,CAAC,EAC7BlF,KAAmB,EACnBmF,KAAgC,EAChCJ,YAAqC,EACb;IACxB;IACA,IAAI,CAACI,KAAK,EAAE;MACVA,KAAK,GAAG,IAAIjC,0EAAwB,CAAC6B,YAAY,EAAEK,gBAAgB,EAAEL,YAAY,EAAEM,wBAAwB,CAAC;IAC9G;IACA,MAAMC,OAAO,GAAG9U,KAAK,CAACyP,OAAO,CAACF,IAAI,CAAC,GAAGA,IAAI,GAAG,CAACA,IAAI,CAAC;IACnD,MAAMwF,SAAS,GAAG/U,KAAK,CAACyP,OAAO,CAACiF,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC;;IAE3D;IACA,MAAMM,WAAW,GAAGF,OAAO,CAAC1X,GAAG,CAAC,OAAO6X,GAAG,EAAEljB,CAAC,KAAK;MAChD,MAAMmjB,KAAK,GAAG,IAAIjC,mEAAY,CAAc,IAAIR,+CAAU,CAACwC,GAAG,CAAC,EAAEzF,KAAK,EAAEmF,KAAK,CAAC;MAC9E,MAAMQ,IAAI,GAAG5C,+CAAS,CAAC2C,KAAK,CAAC;MAE7B,MAAME,KAAK,GAAG,MAAM7C,gDACb,CAAC4C,IAAI,EAAE;QAAEG,IAAI,EAAE;MAAQ,CAAC,CAAC,CAC7BC,KAAK,CAAC5B,wEAAmB,CAAC,mCAAmCsB,GAAG,EAAE,EAAEvB,oEAAmB,CAAC8B,SAAS,CAAC,CAAC;;MAEtG;MACA,IAAIC,KAAK,GAAGV,SAAS,CAAC9hB,IAAI,CAACd,GAAG,CAACJ,CAAC,EAAEgjB,SAAS,CAAC/e,MAAM,GAAG,CAAC,CAAC,CAAC;MACxD,IAAIyf,KAAK,GAAGL,KAAK,CAACM,KAAK,CAACC,WAAW,EAAE3f,MAAM,EAAE;QAC3CrC,OAAO,CAACC,IAAI,CAAC,iCAAiC6hB,KAAK,6BAA6B,CAAC;QACjFA,KAAK,GAAG,CAAC;MACX;MAEA7B,kFAAuB,CAACwB,KAAK,CAACM,KAAK,EAAED,KAAK,EAAEX,OAAO,CAAC9e,MAAM,GAAG,CAAC,GAAG,eAAejE,CAAC,EAAE,GAAG,MAAM,CAAC;MAC7F,MAAM;QAAE4jB,WAAW;QAAEC;MAAM,CAAC,GAAGR,KAAK,CAACM,KAAwB;MAC7D,MAAMG,kBAAkB,GAAGF,WAAW,CAACF,KAAK,CAAC;;MAE7C;MACA,MAAMK,QAAQ,GAAGD,kBAAkB,CAACE,QAAQ,CAAC3Y,GAAG,CAAC,CAAC;QAAE4Y;MAAK,CAAC,KACxDzD,gDACO,CAAC4C,IAAI,CAACc,OAAO,CAACD,IAAI,CAAC,EAAE;QAAEV,IAAI,EAAE;MAAQ,CAAC,CAAC,CAC3CC,KAAK,CACJ5B,wEAAmB,CACjB,8BAA8BqC,IAAI,wBAAwBf,GAAG,EAAE,EAC/DvB,oEAAmB,CAAC8B,SACtB,CACF,CACJ,CAAC;MACD,MAAMU,WAAW,GAAI,MAAM7D,OAAO,CAACC,GAAG,CAACwD,QAAQ,CAAwB;MACvE,MAAMK,SAAS,GAAG3C,sEAAgB,CAACqC,kBAAkB,CAACO,IAAI,CAAC;MAE3D,OAAO;QACLF,WAAW;QACXL,kBAAkB;QAClBQ,aAAa,EAAET,KAAK;QACpBO,SAAS;QACTG,aAAa,EAAE;MACjB,CAAC;IACH,CAAC,CAAC;IACF,MAAMjC,OAAO,GAAG,MAAMhC,OAAO,CAACC,GAAG,CAAC0C,WAAW,CAAC;;IAE9C;IACA,IAAIuB,YAAY,GAAG,CAAC;IACpB,KAAK,MAAM1L,CAAC,IAAIwJ,OAAO,EAAE;MACvBxJ,CAAC,CAACyL,aAAa,GAAGC,YAAY;MAC9BA,YAAY,IAAI1L,CAAC,CAACwL,aAAa,EAAEtW,QAAQ,CAAC/J,MAAM,IAAI6U,CAAC,CAACqL,WAAW,CAAC,CAAC,CAAC,CAACpd,KAAK,CAAC+R,CAAC,CAACsL,SAAS,CAAC,CAAC,CAAC,CAAC;IAC5F;IACA;IACA9C,4EAAsB,CAACgB,OAAO,CAAC;IAC/B;IACA;IACA;IACA,MAAMmC,YAAY,GAAGjC,YAAY,EAAEC,kBAAkB,GAAGD,YAAY,CAACC,kBAAkB,CAACnU,KAAK,CAAC,CAAC,GAAGyC,SAAS;IAC3G,OAAO,IAAIsR,aAAa,CAACC,OAAO,EAAEM,KAAK,EAAEJ,YAAY,EAAEiC,YAAY,CAAC;EACtE;EAEQC,cAAcA,CAAA,EAAqB;IACzC,MAAMC,MAAM,GAAG,IAAI,CAACrC,OAAO,CAAC,CAAC,CAAC;IAC9B;IACA,MAAMsC,EAAE,GAAGD,MAAM,CAACP,SAAS,CAAC,CAAC,CAAC;IAC9B,MAAMS,aAAa,GAAGF,MAAM,CAACb,kBAAkB,CAACO,IAAI,CAACO,EAAE,CAAC,CAACzK,IAAI;IAC7D,MAAM2K,eAAe,GAAG9D,uEAAgB,CAAC6D,aAAa,CAAC,IAAIA,aAAa,IAAI,EAAE;IAE9E,MAAME,EAAE,GAAGJ,MAAM,CAACP,SAAS,CAAC,CAAC,CAAC;IAC9B,MAAMY,YAAY,GAAGD,EAAE,GAAG,CAAC,CAAC,GAAGJ,MAAM,CAACb,kBAAkB,CAACO,IAAI,CAACU,EAAE,CAAC,CAAC5K,IAAI,GAAGpJ,SAAS;IAClF,MAAMkU,cAAc,GAAGjE,uEAAgB,CAACgE,YAAY,CAAC,IAAIA,YAAY,IAAI,EAAE;IAE3E,OAAO,CAACF,eAAe,EAAEG,cAAc,CAAC;EAC1C;EAEQC,iBAAiBA,CAAA,EAA+B;IACtD,MAAMP,MAAM,GAAG,IAAI,CAACrC,OAAO,CAAC,CAAC,CAAC;IAC9B,MAAM,CAAC3hB,CAAC,EAAED,CAAC,EAAED,CAAC,CAAC,GAAGkkB,MAAM,CAACP,SAAS,CAAC9V,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5C,OAAOqW,MAAM,CAACR,WAAW,CAAC9Y,GAAG,CAAC,CAAC;MAAEtE;IAAM,CAAC,KAAK,CAACpG,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAGoG,KAAK,CAACpG,CAAC,CAAC,EAAEoG,KAAK,CAACrG,CAAC,CAAC,EAAEqG,KAAK,CAACtG,CAAC,CAAC,CAAC,CAAC;EAC7F;EAEQ2gB,QAAQA,CAAC+D,KAAa,EAAiB;IAC7C,OAAO/D,8DAAQ,CAAC,IAAI,CAACkB,OAAO,CAAC,CAAC,CAAC,CAACwB,kBAAkB,CAACE,QAAQ,CAACmB,KAAK,CAAC,EAAE,IAAI,CAAC7C,OAAO,CAAC,CAAC,CAAC,CAAC8B,SAAS,CAAC;EAChG;EAEQ7C,gBAAgBA,CAAI6D,SAAmB,EAAEC,SAAS,GAAG,CAAC,EAAO;IACnE,OAAO9D,sEAAgB,CAAC6D,SAAS,EAAE,IAAI,CAAC9C,OAAO,CAAC+C,SAAS,CAAC,CAACjB,SAAS,CAAC;EACvE;EAEQ5C,YAAYA,CAAI8D,aAAkB,EAAEC,YAAe,EAAEF,SAAS,GAAG,CAAC,EAAY;IACpF,OAAO7D,kEAAY,CAAC8D,aAAa,EAAE,IAAI,CAAChD,OAAO,CAAC+C,SAAS,CAAC,CAACjB,SAAS,EAAEmB,YAAY,CAAC;EACrF;;EAEA;AACF;AACA;AACA;AACA;EACUC,oBAAoBA,CAACC,oBAA4B,EAAyD;IAChH,MAAMC,UAAU,GAAG,IAAI,CAACpD,OAAO,CAACre,MAAM,GAAG,CAAC;IAC1C,MAAM0hB,OAAO,GAAG,IAAI,CAACrD,OAAO,CAACoD,UAAU,CAAC;IACxC,MAAME,kBAAkB,GAAGD,OAAO,CAACxB,WAAW,CAAC,CAAC,CAAC,CAACpd,KAAK,CAAC4e,OAAO,CAACvB,SAAS,CAAC,CAAC,CAAC,CAAC;IAE7E,MAAMyB,eAAe,GAAGF,OAAO,CAACpB,aAAa,GAAGqB,kBAAkB;IAClE,IAAIH,oBAAoB,GAAGI,eAAe,EAAE;MAC1C,MAAM,IAAInE,gEAAe,CACvB,wBAAwB+D,oBAAoB,kBAAkBI,eAAe,sBAAsB,EACnG;QAAEC,IAAI,EAAEnE,oEAAmB,CAACoE;MAAiB,CAC/C,CAAC;IACH;IAEA,MAAMC,eAAe,GAAG,IAAI,CAAC1D,OAAO,CAAC2D,SAAS,CAAEC,GAAG,IAAKA,GAAG,CAAC3B,aAAa,GAAGkB,oBAAoB,CAAC;IACjG,MAAMU,WAAW,GAAGH,eAAe,KAAK,CAAC,CAAC,GAAGN,UAAU,GAAGM,eAAe,GAAG,CAAC;IAC7E,MAAMI,oBAAoB,GAAGX,oBAAoB,GAAG,IAAI,CAACnD,OAAO,CAAC6D,WAAW,CAAC,CAAC5B,aAAa;IAC3F,OAAO;MAAE4B,WAAW;MAAEC;IAAqB,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;EACEzL,mBAAmBA,CAAC0L,UAA+B,EAAQ;IACzD,IAAI,CAAC5D,kBAAkB,GAAG4D,UAAU;EACtC;EAEAxL,uBAAuBA,CAACmD,IAAa,EAAQ;IAC3C,IAAI,CAACT,YAAY,GAAGS,IAAI;EAC1B;EAEAjD,kBAAkBA,CAACuL,OAAwC,EAAQ;IACjE,IAAI,CAAC9D,YAAY,GAAG;MAAE,GAAG,IAAI,CAACA,YAAY;MAAE,GAAG8D;IAAQ,CAAC;EAC1D;EAEA1V,QAAQA,CAAChD,QAAkB,EAAyB;IAClD,MAAM,CAAC3G,SAAS,EAAEC,QAAQ,CAAC,GAAG,IAAI,CAACwd,cAAc,CAAC,CAAC;IACnD;IACA,MAAM6B,SAAS,GAAG,IAAI,CAACA,SAAS,IAAI,IAAIjM,wCAAI,CAAC,IAAIjU,2CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAIA,2CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACxF,MAAMkI,SAAS,GAAGqS,uEAAgB,CAAChT,QAAQ,CAACW,SAAS,EAAEgY,SAAS,CAAC;IACjE,MAAMC,UAAU,GAAGjY,SAAS,CAACkY,OAAO,CAAC,IAAIpgB,2CAAO,CAAC,CAAC,CAAC;IACnD,MAAMqgB,SAAS,GAAG,CAAC,CAAC,EAAE,CAAC,EAAEF,UAAU,CAAC7lB,CAAC,EAAE6lB,UAAU,CAAC9lB,CAAC,EAAE8lB,UAAU,CAAC/lB,CAAC,CAAC;IAElE,MAAMwU,MAAM,GAAG,IAAI,CAACqN,OAAO,CAAC,CAAC,CAAC,CAAC6B,WAAW,CAAC9Y,GAAG,CAAC,CAAC8Z,KAAK,EAAEnlB,CAAC,KAAK;MAC3D,MAAMsH,KAAK,GAAG,IAAI,CAAC8Z,QAAQ,CAACphB,CAAC,CAAC;MAC9B,MAAMZ,IAAgB,GAAG;QACvB6H,SAAS,EAAEA,SAAS;QACpBC,QAAQ,EAAEA,QAAQ;QAClBH,KAAK,EAAE,IAAI,CAACya,YAAY,CAAC2D,KAAK,CAACpe,KAAK,EAAE,CAAC,CAAC,CAACsE,GAAG,CAAC,CAACxK,GAAG,EAAEuN,GAAG,KACpDlN,IAAI,CAACb,GAAG,CAACa,IAAI,CAACuL,IAAI,CAAC5L,GAAG,GAAG6lB,SAAS,CAACtY,GAAG,CAAC,CAAC,EAAE,CAAC,CAC7C,CAAkB;QAClBpH,OAAO,EAAE,IAAI,CAACwa,YAAY,CAACla,KAAK,EAAE,CAAC,CAAC;QACpC5F,QAAQ,EAAEyjB,KAAK,CAAC9mB;MAClB,CAAC;MACD,OAAOe,IAAI;IACb,CAAC,CAAC;IAEF,OAAOkhB,OAAO,CAAC4D,OAAO,CAACjP,MAAM,CAAC;EAChC;EAEAkG,eAAeA,CAACvN,QAAkB,EAA6B;IAC7D;IACA,MAAM+Y,OAAO,GAAG,IAAI,CAACrE,OAAO,CAAC,CAAC,CAAC;IAC/B,MAAM,CAAChJ,CAAC,GAAI3Y,CAAC,EAAED,CAAC,EAAED,CAAC,CAAC,GAAGkmB,OAAO,CAACvC,SAAS;IACxC,MAAMwC,IAAI,GAAGtN,CAAC,GAAG,CAAC,CAAC;IACnB,MAAMuN,IAAI,GAAGlmB,CAAC,GAAG,CAAC,CAAC;IAEnB,MAAM+P,WAAW,GAAGqQ,sEAAe,CAACnT,QAAQ,EAAE,IAAI,CAACsX,iBAAiB,CAAC,CAAC,CAAC;IACvE,MAAM4B,OAAO,GAAGH,OAAO,CAACxC,WAAW,CAACzT,WAAW,CAAC,CAAC3J,KAAK;IAEtD,MAAM,CAACa,WAAW,EAAEV,QAAQ,CAAC,GAAG,IAAI,CAACwd,cAAc,CAAC,CAAC;;IAErD;IACA,MAAMqC,UAAU,GAAG,IAAI,CAACzE,OAAO,CAAC,IAAI,CAACA,OAAO,CAACre,MAAM,GAAG,CAAC,CAAC;IACxD,MAAM+iB,KAAK,GAAGD,UAAU,CAAC3C,SAAS,CAAC,CAAC,CAAC;IACrC,MAAM6C,QAAQ,GAAGD,KAAK,GAAG,CAAC,CAAC;IAC3B,MAAMtf,WAAW,GAAGqf,UAAU,CAACxC,aAAa,IAAI0C,QAAQ,GAAGF,UAAU,CAAC5C,WAAW,CAACzT,WAAW,CAAC,CAAC3J,KAAK,CAACigB,KAAK,CAAC,GAAG,CAAC,CAAC;IAChH;IACA;IACA,IAAInf,KAAK,GAAG,CAAC;IACb,IAAI+e,IAAI,EAAE;MACR/e,KAAK,GAAGif,OAAO,CAACxN,CAAC,CAAC;MAClB,KAAK,IAAItZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACsiB,OAAO,CAACre,MAAM,EAAEjE,CAAC,EAAE,EAAE;QAC5C,MAAM+G,KAAK,GAAG,IAAI,CAACub,OAAO,CAACtiB,CAAC,CAAC,CAACmkB,WAAW,CAACzT,WAAW,CAAC,CAAC3J,KAAK;QAC5D,MAAMmgB,MAAM,GAAG,IAAI,CAAC5E,OAAO,CAACtiB,CAAC,CAAC,CAACokB,SAAS,CAAC,CAAC,CAAC;QAC3C,IAAIrd,KAAK,CAACmgB,MAAM,CAAC,GAAGrf,KAAK,EAAE;UACzBjG,OAAO,CAACC,IAAI,CAAC,8DAA8D,EAAEkF,KAAK,CAACmgB,MAAM,CAAC,EAAErf,KAAK,CAAC;UAClGA,KAAK,GAAGd,KAAK,CAACmgB,MAAM,CAAC;QACvB;MACF;IACF;IAEA,IAAI,CAAC,IAAI,CAACX,SAAS,EAAE;MACnB,IAAI,CAACA,SAAS,GAAG3Y,QAAQ,CAACW,SAAS,CAACC,KAAK,CAAC,CAAC;IAC7C;;IAEA;IACA,MAAM2Y,QAAQ,GAAGrG,+EAAwB,CACvClT,QAAQ,CAACW,SAAS,EAClB,IAAIlI,2CAAO,CAACygB,OAAO,CAACrmB,CAAC,CAAC,EAAEqmB,OAAO,CAACpmB,CAAC,CAAC,EAAEmmB,IAAI,GAAGC,OAAO,CAACnmB,CAAC,CAAC,GAAG,CAAC,CAC3D,CAAC;IACD,MAAMymB,QAAQ,GAAGD,QAAQ,CAACV,OAAO,CAAC,IAAIpgB,2CAAO,CAAC,CAAC,CAAC;IAEhD,MAAMG,aAAa,GAAGqa,6EAAsB,CAACuG,QAAQ,CAACzmB,CAAC,EAAEymB,QAAQ,CAAC3mB,CAAC,EAAE2mB,QAAQ,CAAC1mB,CAAC,CAAC;;IAEhF;IACA;IACA,MAAM2mB,eAAe,GAAG,IAAIxT,GAAG,CAAiB,CAAC;IACjD,MAAMlN,YAAY,GAAG,IAAI,CAAC2b,OAAO,CAAC5D,OAAO,CAAEwH,GAAG,IAAK;MACjD,MAAMoB,kBAAkB,GAAGjG,2EAAqB,CAAC6E,GAAG,CAAC;;MAErD;MACA,OAAOoB,kBAAkB,CAACjc,GAAG,CAAEkc,WAAW,IAAK;QAC7C,MAAMC,mBAAmB,GAAGH,eAAe,CAACnS,GAAG,CAACqS,WAAW,CAAC;QAE5D,IAAIC,mBAAmB,KAAKzW,SAAS,EAAE;UACrC;UACAsW,eAAe,CAACtnB,GAAG,CAACwnB,WAAW,EAAEC,mBAAmB,GAAG,CAAC,CAAC;UACzD,OAAO,GAAGD,WAAW,KAAKC,mBAAmB,GAAG;QAClD,CAAC,MAAM;UACLH,eAAe,CAACtnB,GAAG,CAACwnB,WAAW,EAAE,CAAC,CAAC;UACnC,OAAOA,WAAW;QACpB;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,MAAME,OAAqB,GAAGd,OAAO,CAACxC,WAAW,CAAC9Y,GAAG,CAAC,CAAC8Z,KAAK,EAAEnlB,CAAC,KAAK;MAClE,MAAMZ,IAAI,GAAG;QACX6H,SAAS,EAAEW,WAAW;QACtBV,QAAQ,EAAEA,QAAQ;QAClBH,KAAK,EAAE,IAAI,CAACya,YAAY,CAAC2D,KAAK,CAACpe,KAAK,EAAE,CAAC,CAAC;QACxCC,OAAO,EAAE,IAAI,CAACoa,QAAQ,CAACphB,CAAC,CAAC;QACzB0B,QAAQ,EAAEyjB,KAAK,CAAC9mB;MAClB,CAAC;MACD,OAAOe,IAAI;IACb,CAAC,CAAC;IAEF,MAAMsoB,OAAkB,GAAG;MACzBvpB,IAAI,EAAEwoB,OAAO,CAACrC,aAAa,EAAEnmB,IAAI,IAAI,QAAQ;MAE7CqI,aAAa,EAAE,CAACA,aAAa,CAAC/F,CAAC,EAAE+F,aAAa,CAAC9F,CAAC,CAAC;MACjDsB,aAAa,EAAE,CAAColB,QAAQ,CAAC3mB,CAAC,EAAE2mB,QAAQ,CAAC1mB,CAAC,EAAE0mB,QAAQ,CAACzmB,CAAC,CAAC;MACnD8F,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAE1BC,mBAAmB,EAAEgB,WAAW;MAChCf,YAAY;MACZE,eAAe,EAAE6J,WAAW;MAC5B5J,mBAAmB,EAAE2gB,OAAO;MAE5BtgB,SAAS,EAAE;QACTC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACtBC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACnBC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;MACjB;IACF,CAAC;;IAED;IACA;IACA,MAAMqgB,kBAA4B,GAAG;MACnC,GAAG/Z,QAAQ;MACXW,SAAS,EAAE,IAAI+L,wCAAI,CAAC,IAAIjU,2CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAIA,2CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAChE,CAAC;IAED,OAAOia,OAAO,CAAC4D,OAAO,CAAC;MAAE1c,SAAS,EAAEkgB,OAAO;MAAE9Z,QAAQ,EAAE+Z;IAAmB,CAAC,CAAC;EAC9E;EAEA,MAAcC,aAAaA,CACzBC,UAA4B,EAC5BC,MAAqB,EACrBC,UAAwB,EACT;IACf,MAAM;MAAE5E,KAAK;MAAEc;IAAK,CAAC,GAAG4D,UAAU;IAClC,MAAMG,SAAS,GAAG/D,IAAI,CAACgE,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG;IAC/C,MAAM9T,GAAG,GAAG8P,IAAI,GAAG+D,SAAS,GAAG,IAAI,CAACzG,gBAAgB,CAACuG,MAAM,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC;IACtE;IACA,MAAM/E,KAAK,CACRjO,GAAG,CAACf,GAAG,EAAkB;MAAE4T,UAAU;MAAEI,UAAU,EAAE;IAAK,CAAC,CAAC,CAC1D3E,KAAK,CACJ5B,wEAAmB,CACjB,qCAAqCzN,GAAG,EAAE,EAC1CwN,oEAAmB,CAACyG,gBAAgB,EACpCtG,2BACF,CACF,CAAC;EACL;;EAEA;EACQuG,aAAaA,CAACjQ,IAA0B,EAAEyP,UAAkB,EAAQ;IAC1E;IACA,MAAMS,WAAW,GAAGlQ,IAAI,CAAC/M,GAAG,CAAC,CAAC;MAAEga,SAAS;MAAElR;IAAI,CAAC,KAAK;MACnD,MAAMoU,OAAO,GAAGpH,uEAAiB,CAAC,IAAI,CAACmB,OAAO,CAAC+C,SAAS,CAAC,CAACjB,SAAS,CAAC;MACpE,MAAMoE,sBAAsB,GAAGrU,GAAG,CAC/BsU,IAAI,CAAC,CAAC,CACNC,KAAK,CAAC,GAAG,CAAC,CACVpa,KAAK,CAAC,CAACia,OAAO,CAAC,CACflK,MAAM,CAAEvF,CAAC,IAAKA,CAAC,KAAK,EAAE,CAAC,CACvBzN,GAAG,CAAEyN,CAAC,IAAK6P,QAAQ,CAAC7P,CAAC,EAAE,EAAE,CAAC,CAAC;MAC9B,MAAM8P,YAAY,GAAG,IAAI,CAACpH,YAAY,CAACgH,sBAAsB,EAAE,CAAC,EAAEnD,SAAS,CAAC;MAC5E;MACA;MACAuD,YAAY,CAAC,CAAC,CAAC,IAAI,IAAI,CAACtG,OAAO,CAAC+C,SAAS,CAAC,CAACd,aAAa;MACxD,OAAOqE,YAAY;IACrB,CAAC,CAAC;;IAEF;IACA,MAAMC,cAAc,GAAG,IAAI,CAACvG,OAAO,CAACjX,GAAG,CAAE6a,GAAG,IAAK;MAC/C,MAAMf,KAAK,GAAGe,GAAG,CAAC/B,WAAW,CAAC0D,UAAU,CAAC;MACzC,MAAMiB,kBAAkB,GAAG3D,KAAK,CAACpe,KAAK,CAACsE,GAAG,CAAC,CAAC0d,GAAG,EAAE3a,GAAG,KAAKlN,IAAI,CAACuL,IAAI,CAACsc,GAAG,GAAG5D,KAAK,CAAC6D,MAAM,CAAC5a,GAAG,CAAC,CAAC,CAAC;MAC5F,OAAO,IAAI,CAACoT,YAAY,CAACsH,kBAAkB,EAAE,CAAC,CAAC;IACjD,CAAC,CAAC;IACF;IACA,MAAMG,gBAAgB,GAAG,IAAIhI,4EAAqB,CAChDqH,WAAW,EACX,IAAI,CAAC9F,YAAY,CAACL,mBAAmB,EACrC0G,cAAc,EACd,IAAI,CAACpG,kBAAkB,EACvB,IAAI,CAACD,YAAY,CAAC0G,sBACpB,CAAC;IAED,MAAMnB,UAAU,GAAG,IAAI,CAACxF,YAAY,CAAC4G,aAAa,CAAC,CAAC;IACpD,IAAIC,aAAa,GAAG,CAAC;IACrB,KAAK,MAAMC,KAAK,IAAIJ,gBAAgB,EAAE;MACpC,IAAIG,aAAa,IAAI,IAAI,CAAC5G,YAAY,CAACJ,iBAAiB,EAAE;QACxD;MACF;MACA;MACA,MAAM;QAAE+D,WAAW;QAAEC;MAAqB,CAAC,GAAG,IAAI,CAACZ,oBAAoB,CAAC6D,KAAK,CAAC,CAAC,CAAC,CAAC;MACjF,MAAMC,gBAAgB,GAAG,IAAI,CAAChH,OAAO,CAAC6D,WAAW,CAAC,CAAChC,WAAW,CAAC0D,UAAU,CAAC;MAC1EwB,KAAK,CAAC,CAAC,CAAC,GAAGjD,oBAAoB;MAC/B,IAAI,CAACwB,aAAa,CAAC0B,gBAAgB,EAAED,KAAK,EAAEtB,UAAU,CAAC;MACvDqB,aAAa,EAAE;IACjB;;IAEA;IACA,IAAI,IAAI,CAACG,kBAAkB,KAAKxY,SAAS,EAAE;MACzC,IAAI,CAACwR,YAAY,CAACiH,gBAAgB,CAAC,IAAI,CAACD,kBAAkB,EAAEzH,2BAA2B,CAAC;IAC1F;IACA,IAAI,CAACyH,kBAAkB,GAAGxB,UAAU;EACtC;EAEQ0B,sBAAsBA,CAACjiB,SAAoB,EAAEoG,QAAkB,EAAa;IAClF;IACA,MAAM2Y,SAAS,GAAG,IAAI,CAACA,SAAS,IAAI,IAAIjM,wCAAI,CAAC,IAAIjU,2CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAIA,2CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACxF,MAAMkI,SAAS,GAAGqS,uEAAgB,CAAChT,QAAQ,CAACW,SAAS,EAAEgY,SAAS,CAAC;;IAEjE;IACA,MAAM1f,eAAe,GAAGka,sEAAe,CAAC;MAAE,GAAGnT,QAAQ;MAAEW;IAAU,CAAC,EAAE,IAAI,CAAC2W,iBAAiB,CAAC,CAAC,CAAC;IAC7F,MAAMwE,WAAW,GAAG,IAAI,CAACpH,OAAO,CAAC,CAAC,CAAC,CAAC6B,WAAW,CAACtd,eAAe,CAAC,CAACE,KAAK;;IAEtE;IACA,MAAM,CAACpG,CAAC,EAAED,CAAC,EAAED,CAAC,CAAC,GAAG,IAAI,CAAC6hB,OAAO,CAAC,CAAC,CAAC,CAAC8B,SAAS,CAAC9V,KAAK,CAAC,CAAC,CAAC;IACpD,MAAMqb,QAAQ,GAAG7I,+EAAwB,CACvCvS,SAAS,EACT,IAAIlI,2CAAO,CAACqjB,WAAW,CAACjpB,CAAC,CAAC,EAAEipB,WAAW,CAAChpB,CAAC,CAAC,EAAEC,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG+oB,WAAW,CAAC/oB,CAAC,CAAC,CAC3E,CAAC;;IAED;IACA,MAAMqB,aAAa,GAAG2nB,QAAQ,CAAClD,OAAO,CAAC,IAAIpgB,2CAAO,CAAC,CAAC,CAAC;IACrD,MAAMG,aAAa,GAAGqa,6EAAsB,CAAC7e,aAAa,CAACrB,CAAC,EAAEqB,aAAa,CAACvB,CAAC,EAAEuB,aAAa,CAACtB,CAAC,CAAC;IAE/F,OAAO;MACL,GAAG8G,SAAS;MACZhB,aAAa,EAAE,CAACA,aAAa,CAAC/F,CAAC,EAAE+F,aAAa,CAAC9F,CAAC,CAAC;MACjDsB,aAAa,EAAE,CAACA,aAAa,CAACvB,CAAC,EAAEuB,aAAa,CAACtB,CAAC,EAAEsB,aAAa,CAACrB,CAAC,CAAC;MAClE8F,eAAe,EAAE,CAACkjB,QAAQ,CAACvpB,GAAG,CAACK,CAAC,EAAEkpB,QAAQ,CAACvpB,GAAG,CAACM,CAAC,EAAEipB,QAAQ,CAACvpB,GAAG,CAACO,CAAC,CAAC;MACjEkG;IACF,CAAC;EACH;EAEA,MAAMgV,kBAAkBA,CACtBrU,SAAoB,EACpBoG,QAAkB,EAClB0N,gBAAgD,EAChD4C,MAA8B,EACf;IACf;IACA;IACA,MAAMX,YAAY,GAAG,IAAI,CAACA,YAAY;IAEtC,MAAMqM,gBAAgB,GAAG,IAAI,CAACH,sBAAsB,CAACjiB,SAAS,EAAEoG,QAAQ,CAAC;IACzE0N,gBAAgB,CAACsO,gBAAgB,CAAC;IAClC,MAAM;MAAEljB,mBAAmB;MAAEG;IAAgB,CAAC,GAAG+iB,gBAAgB;IACjE,MAAMC,cAAc,GAAGjc,QAAQ,CAACI,QAAQ,IAAIC,KAAK,CAACC,IAAI,CAAC;MAAEjK,MAAM,EAAEyC;IAAoB,CAAC,EAAE,CAACojB,CAAC,EAAE9pB,CAAC,KAAKA,CAAC,CAAC;IAEpG,MAAM+nB,UAAU,GAAG,IAAI,CAACxF,YAAY,CAAC4G,aAAa,CAAC,CAAC;;IAEpD;IACA,MAAM/Q,IAA0B,GAAG,EAAE;IACrC,MAAM2R,aAAa,GAAGA,CAAC1E,SAAiB,EAAElR,GAAW,EAAE6V,GAAiB,KAAK;MAC3E,IAAIA,GAAG,KAAKjC,UAAU,EAAE;QACtB3P,IAAI,CAACrN,IAAI,CAAC;UAAEsa,SAAS;UAAElR;QAAI,CAAC,CAAC;MAC/B;IACF,CAAC;IAED,MAAM2K,oBAA8B,GAAG,EAAE;IACzC,MAAME,iBAAyD,GAAG,EAAE;IACpE,MAAMD,kBAAyC,GAAG,EAAE;IACpD,MAAME,mBAAuC,GAAG,EAAE;IAElD,MAAMgL,eAAe,GAAGJ,cAAc,CAACxe,GAAG,CAAC,MAAOiT,EAAE,IAAK;MACvD;MACA,MAAMle,GAAG,GAAG,IAAIiG,2CAAO,CAAC,GAAGujB,gBAAgB,CAACnjB,eAAe,CAAC;MAC5D,MAAMpG,GAAG,GAAGD,GAAG,CAACoO,KAAK,CAAC,CAAC,CAACgD,GAAG,CAAC,IAAInL,2CAAO,CAAC,GAAGujB,gBAAgB,CAAC5nB,aAAa,CAAC,CAAC;MAC3E,MAAM;QAAEmkB,WAAW,EAAEd,SAAS;QAAEe,oBAAoB,EAAE8D;MAAS,CAAC,GAAG,IAAI,CAAC1E,oBAAoB,CAAClH,EAAE,CAAC;MAChG,MAAM6L,aAAa,GAAG,CAACvc,QAAQ,CAACkC,IAAI,EAAEoa,QAAQ,EAAE5b,yDAAK,CAAClO,GAAG,CAACO,CAAC,EAAEN,GAAG,CAACM,CAAC,CAAC,EAAE2N,yDAAK,CAAClO,GAAG,CAACM,CAAC,EAAEL,GAAG,CAACK,CAAC,CAAC,EAAE4N,yDAAK,CAAClO,GAAG,CAACK,CAAC,EAAEJ,GAAG,CAACI,CAAC,CAAC,CAAC;MAE9G,MAAM0kB,KAAK,GAAG,IAAI,CAAC7C,OAAO,CAAC+C,SAAS,CAAC,CAAClB,WAAW,CAACtd,eAAe,CAAC;MAClE,MAAMujB,SAAS,GAAG,IAAI,CAAC7I,gBAAgB,CAAC4I,aAAa,EAA2B9E,SAAS,CAAC;MAC1F,MAAMgF,SAAS,GAAGA,CAAClW,GAAW,EAAE6V,GAAiB,KAAKD,aAAa,CAAC1E,SAAS,EAAElR,GAAG,EAAE6V,GAAG,CAAC;MAExF,MAAM/U,MAAM,GAAG,MAAMwL,uDAAO,CAAC0E,KAAK,EAAEiF,SAAS,EAAE;QAAEE,IAAI,EAAE;UAAEvC,UAAU;UAAEsC;QAAU;MAAE,CAAC,CAAC,CAAC7G,KAAK,CACvF5B,wEAAmB,CACjB,qCAAqC,EACrCD,oEAAmB,CAACyG,gBAAgB,EACpCtG,2BACF,CACF,CAAC;MAED,IAAI7M,MAAM,EAAE1W,IAAI,KAAKwS,SAAS,EAAE;QAC9B;MACF;MAEA,MAAMwZ,SAAS,GAAGxI,cAAc,CAAC9M,MAAM,CAAC1W,IAAI,EAAE4mB,KAAK,CAAC9mB,KAAK,CAAC;MAC1D,IAAIkf,YAAY,EAAE;QAChBwB,kBAAkB,CAAChU,IAAI,CAACwf,SAAS,CAAClsB,KAAK,CAAC;QACxC2gB,iBAAiB,CAACjU,IAAI,CAACwf,SAAS,CAAChsB,IAAI,CAAC;QACtCugB,oBAAoB,CAAC/T,IAAI,CAACuT,EAAE,CAAC;QAC7BW,mBAAmB,CAAClU,IAAI,CAAC,CAACwf,SAAS,CAACnqB,GAAG,EAAEmqB,SAAS,CAAClqB,GAAG,CAAC,CAAC;MAC1D,CAAC,MAAM;QACL6d,MAAM,CAAC,CAACI,EAAE,CAAC,EAAE,CAACiM,SAAS,CAAClsB,KAAK,CAAC,EAAE,CAACksB,SAAS,CAAChsB,IAAI,CAAC,EAAE,CAAC,CAACgsB,SAAS,CAACnqB,GAAG,EAAEmqB,SAAS,CAAClqB,GAAG,CAAC,CAAC,CAAC;MACrF;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,IAAI,CAACmqB,cAAc,KAAKzZ,SAAS,EAAE;MACrC,IAAI,CAACwR,YAAY,CAACiH,gBAAgB,CAAC,IAAI,CAACgB,cAAc,EAAE1I,2BAA2B,CAAC;IACtF;IACA,IAAI,CAAC0I,cAAc,GAAGzC,UAAU;IAEhC,IAAI,CAACM,aAAa,CAACjQ,IAAI,EAAEvR,eAAe,CAAC;IAEzC,MAAMyZ,OAAO,CAACC,GAAG,CAAC0J,eAAe,CAAC;IAElC,IAAI1M,YAAY,EAAE;MAChBW,MAAM,CAACY,oBAAoB,EAAEC,kBAAkB,EAAEC,iBAAiB,EAAEC,mBAAmB,CAAC;IAC1F;IACA,IAAI,CAACsD,YAAY,CAACiH,gBAAgB,CAACzB,UAAU,EAAEjG,2BAA2B,CAAC;EAC7E;AACF;;;;;;;;;;;;;;;;;;;;ACrmBsC;AAOV;AACoC;AAIX;;AAErD;AACA;AACA;;AAUA;;AAkBA,MAAMrF,gBAAgB,GAAIT,IAAkB,IAAgB;EAC1D,MAAMxV,aAAa,GAAGqa,6EAAsB,CAAC7E,IAAI,CAACyO,KAAK,EAAEzO,IAAI,CAAC0O,KAAK,EAAE1O,IAAI,CAAC2O,KAAK,CAAC;EAChF,OAAO;IACLxsB,IAAI,EAAE6d,IAAI,CAAC7d,IAAI;IAEf;IACA;IACAqI,aAAa,EAAE,CAACA,aAAa,CAAC/F,CAAC,EAAE+F,aAAa,CAAC9F,CAAC,CAAC;IACjDsB,aAAa,EAAE,CAACga,IAAI,CAAC0O,KAAK,EAAE1O,IAAI,CAAC2O,KAAK,EAAE3O,IAAI,CAACyO,KAAK,CAAC;IACnDhkB,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAE1BC,mBAAmB,EAAEsV,IAAI,CAAC4O,KAAK;IAC/BjkB,YAAY,EAAEqV,IAAI,CAACrV,YAAY;IAC/BC,aAAa,EAAEmK,SAAS;IAExBlK,eAAe,EAAE,CAAC;IAClBC,mBAAmB,EAAE,CACnB;MACEC,KAAK,EAAE,CAAC,CAAC,EAAEiV,IAAI,CAAC4O,KAAK,EAAE5O,IAAI,CAACyO,KAAK,EAAEzO,IAAI,CAAC2O,KAAK,EAAE3O,IAAI,CAAC0O,KAAK,CAAC;MAC1D1jB,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAEgV,IAAI,CAAC5V,iBAAiB,CAAC,CAAC,CAAC,EAAE4V,IAAI,CAAC5V,iBAAiB,CAAC,CAAC,CAAC,EAAE4V,IAAI,CAAC5V,iBAAiB,CAAC,CAAC,CAAC,CAAC;MAChGa,SAAS,EAAE+U,IAAI,CAACpU,WAAW,IAAI,IAAI;MACnCV,QAAQ,EAAE,GAAG;MACbxF,QAAQ,EAAE;IACZ,CAAC,CACF;IAEDyF,SAAS,EAAE;MACTC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACtBC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACnBC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;IACjB,CAAC;IAED6V,QAAQ,EAAEnB,IAAI,CAACmB;EACjB,CAAC;AACH,CAAC;AAED,MAAM0N,cAAc,SAASnQ,qEAAsB,CAAC;EAIlDxc,WAAWA,CAAC4sB,OAAqB,EAAEC,WAAyB,EAAE;IAC5D,KAAK,CAAC,CAAC;IACP,IAAI,CAACpN,QAAQ,GAAGoN,WAAW;IAC3B,IAAI,CAACxsB,IAAI,GAAGusB,OAAO;IACnB;IACA,IACE,IAAI,CAACvsB,IAAI,CAACwI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC4W,QAAQ,CAACiN,KAAK,IAC1C,IAAI,CAACrsB,IAAI,CAACwI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC4W,QAAQ,CAAC8M,KAAK,IAC1C,IAAI,CAAClsB,IAAI,CAACwI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC4W,QAAQ,CAACgN,KAAK,IAC1C,IAAI,CAACpsB,IAAI,CAACwI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC4W,QAAQ,CAAC+M,KAAK,EAC1C;MACA,MAAM,IAAIM,KAAK,CAAC,oDAAoD,CAAC;IACvE;EACF;EAEA,MAAMpa,QAAQA,CAACqa,SAAmB,EAAyB;IACzD,MAAMtN,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAE9B,MAAMM,CAAa,GAAG;MACpBlX,KAAK,EAAE,CAAC,CAAC,EAAE4W,QAAQ,CAACiN,KAAK,EAAEjN,QAAQ,CAAC8M,KAAK,EAAE9M,QAAQ,CAACgN,KAAK,EAAEhN,QAAQ,CAAC+M,KAAK,CAAC;MAC1E1jB,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE2W,QAAQ,CAACvX,iBAAiB,CAAC,CAAC,CAAC,EAAEuX,QAAQ,CAACvX,iBAAiB,CAAC,CAAC,CAAC,EAAEuX,QAAQ,CAACvX,iBAAiB,CAAC,CAAC,CAAC,CAAC;MAC5Ga,SAAS,EAAE0W,QAAQ,CAAC/V,WAAW,IAAI,IAAI;MACvClG,QAAQ,EAAE,OAAO;MACjBwF,QAAQ,EAAE,GAAG,CAAE;IACjB,CAAC;IACD,OAAO,CAAC+W,CAAC,CAAC;EACZ;EAEA,MAAM9C,eAAeA,CAACvN,QAAkB,EAA6B;IACnE,OAAO;MAAEpG,SAAS,EAAEiV,gBAAgB,CAAC,IAAI,CAACkB,QAAQ,CAAC;MAAE/P;IAAS,CAAC;EACjE;EAEAiO,kBAAkBA,CAChBrU,SAAoB,EACpBoG,QAAkB,EAClB0N,gBAAoE,EACpE4C,MAA8B,EACf;IACf,MAAME,iBAAiB,GAAGxQ,QAAQ,CAACI,QAAQ;IAE3C,MAAMkN,gBAAgB,GAAG;MACvB,GAAGtN,QAAQ;MACX;MACAW,SAAS,EAAE,IAAI+L,uCAAI,CAAC,IAAIjU,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAIA,0CAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAC/DQ,eAAe,EAAE;IACnB,CAAC;IACDyU,gBAAgB,CAACvK,SAAS,EAAEmK,gBAAgB,CAAC;IAE7C,KAAK,IAAIkE,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG5X,SAAS,CAACd,mBAAmB,EAAE,EAAE0Y,OAAO,EAAE;MACxE,IAAIhB,iBAAiB,IAAIA,iBAAiB,CAACna,MAAM,GAAG,CAAC,IAAI,CAACma,iBAAiB,CAACnO,QAAQ,CAACmP,OAAO,CAAC,EAAE;QAC7F;MACF;MACA,MAAM8L,YAAY,GAAG,IAAI,CAAC3sB,IAAI,CAACwI,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAACxI,IAAI,CAACwI,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAACxI,IAAI,CAACwI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;MACnF,MAAMuY,WAAW,GAAG,IAAI9gB,UAAU,CAAC,IAAI,CAACD,IAAI,CAAC4sB,MAAM,CAACA,MAAM,EAAE/L,OAAO,GAAG8L,YAAY,EAAEA,YAAY,CAAC;MACjG,MAAM7Y,KAAK,GAAGyJ,iEAAY,CAACwD,WAAW,CAAC;MACvC;MACApB,MAAM,CAAC,CAACkB,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE,CAACE,WAAW,CAAC,EAAE,CAACjN,KAAK,CAAC,CAAC;IACtD;IAEA,OAAOiO,OAAO,CAAC4D,OAAO,CAAC,CAAC;EAC1B;AACF;;;;;;;;;;;;;;;;;;;;;;ACjJkC;AAC8B;AAOpC;AACoD;AACiB;AACpC;AAI7D,SAASoH,UAAUA,CAACC,GAAW,EAAU;EACvC;EACA;EACA,MAAMC,IAAI,GAAG,YAAY;EACzB,OAAOD,GAAG,CAAC9C,IAAI,CAAC,CAAC,CAACjK,OAAO,CAACgN,IAAI,EAAE,EAAE,CAAC,CAAC/C,IAAI,CAAC,CAAC;AAC5C;AAEA,SAASgD,MAAMA,CAACF,GAAW,EAAW;EACpC,MAAMG,MAAM,GAAG,IAAIC,SAAS,CAAC,CAAC;EAC9B,IAAI;IACF,MAAMC,MAAM,GAAGF,MAAM,CAACG,eAAe,CAACN,GAAG,EAAE,UAAU,CAAC;IACtD,OAAOK,MAAM,CAACE,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EAC9C,CAAC,CAAC,OAAO9lB,CAAC,EAAE;IACV,MAAM,IAAI0b,gEAAe,CAAC,0CAA0C,EAAE;MACpEoE,IAAI,EAAEnE,oEAAmB,CAACoE,gBAAgB;MAC1CgG,KAAK,EAAE/lB;IACT,CAAC,CAAC;EACJ;AACF;AAEA,MAAMgmB,OAAO,CAAC;EACZC,KAAK,GAAG,CAAC;EACTC,KAAK,GAAG,CAAC;EACTC,KAAK,GAAG,CAAC;EACTC,KAAK,GAAG,CAAC;EACTC,KAAK,GAAG,CAAC;EACTlS,IAAI,GAAG,EAAE;EACTmS,SAAS,GAAG,EAAE;EACdC,cAAc,GAAG,EAAE;EACnBC,UAAU,GAAG,CAAC;EACdC,UAAU,GAAG,CAAC;EACdC,UAAU,GAAG,CAAC;EACdC,YAAY,GAAa,EAAE;AAC7B;AAEA,SAASC,QAAQA,CAACC,YAAoB,EAAc;EAClD,MAAMC,OAAmC,GAAG;IAC1CC,KAAK,EAAE,OAAO;IACdC,MAAM,EAAE,QAAQ;IAChBC,MAAM,EAAE,QAAQ;IAChBC,IAAI,EAAE,MAAM;IACZC,KAAK,EAAE,OAAO;IACdC,KAAK,EAAE,OAAO;IACdC,KAAK,EAAE;EACT,CAAC;EACD,MAAMhvB,KAAK,GAAGyuB,OAAO,CAACD,YAAY,CAAC;EACnC,IAAIxuB,KAAK,KAAK0S,SAAS,EAAE;IACvBnP,OAAO,CAACC,IAAI,CAAC,8BAA8BgrB,YAAY,uBAAuB,CAAC;IAC/E,OAAO,OAAO;EAChB;EACA,OAAOxuB,KAAK;AACd;AAqBA,SAASivB,mBAAmBA,CAACC,EAAW,EAAEC,IAAY,EAAU;EAC9D,MAAM3sB,GAAG,GAAG0sB,EAAE,CAACE,YAAY,CAACD,IAAI,CAAC;EACjC,IAAI3sB,GAAG,KAAK,IAAI,EAAE;IAChB,MAAM,IAAI6gB,gEAAe,CAAC,qBAAqB8L,IAAI,uBAAuB,EAAE;MAC1E1H,IAAI,EAAEnE,oEAAmB,CAACoE;IAC5B,CAAC,CAAC;EACJ;EACA,OAAOllB,GAAG;AACZ;AAEA,SAAS6sB,UAAUA,CAACC,OAAgB,EAAW;EAC7C,MAAMvuB,IAAI,GAAG,IAAI4sB,OAAO,CAAC,CAAC;EAE1B,MAAM4B,QAAQ,GAAGD,OAAO,CAAC7B,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;EAC1D1sB,IAAI,CAAC6sB,KAAK,GAAG4B,MAAM,CAACP,mBAAmB,CAACM,QAAQ,EAAE,OAAO,CAAC,CAAC;EAC3DxuB,IAAI,CAAC8sB,KAAK,GAAG2B,MAAM,CAACP,mBAAmB,CAACM,QAAQ,EAAE,OAAO,CAAC,CAAC;EAC3DxuB,IAAI,CAAC+sB,KAAK,GAAG0B,MAAM,CAACD,QAAQ,CAACH,YAAY,CAAC,OAAO,CAAC,CAAC;EACnDruB,IAAI,CAACgtB,KAAK,GAAGyB,MAAM,CAACD,QAAQ,CAACH,YAAY,CAAC,OAAO,CAAC,CAAC;EACnDruB,IAAI,CAACitB,KAAK,GAAGwB,MAAM,CAACD,QAAQ,CAACH,YAAY,CAAC,OAAO,CAAC,CAAC;EACnDruB,IAAI,CAAC+a,IAAI,GAAGyT,QAAQ,CAACH,YAAY,CAAC,mBAAmB,CAAC,IAAI,EAAE;EAC5DruB,IAAI,CAACktB,SAAS,GAAGsB,QAAQ,CAACH,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE;EACpDruB,IAAI,CAACmtB,cAAc,GAAGqB,QAAQ,CAACH,YAAY,CAAC,gBAAgB,CAAC,IAAI,OAAO;EACxEruB,IAAI,CAACotB,UAAU,GAAGqB,MAAM,CAACD,QAAQ,CAACH,YAAY,CAAC,eAAe,CAAC,CAAC;EAChEruB,IAAI,CAACqtB,UAAU,GAAGoB,MAAM,CAACD,QAAQ,CAACH,YAAY,CAAC,eAAe,CAAC,CAAC;EAChEruB,IAAI,CAACstB,UAAU,GAAGmB,MAAM,CAACD,QAAQ,CAACH,YAAY,CAAC,eAAe,CAAC,CAAC;EAChE,MAAMK,WAAW,GAAGF,QAAQ,CAAC9B,oBAAoB,CAAC,SAAS,CAAC;EAC5D,KAAK,IAAI9rB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8tB,WAAW,CAAC7pB,MAAM,EAAE,EAAEjE,CAAC,EAAE;IAC3C,MAAM7B,IAAI,GAAG2vB,WAAW,CAAC9tB,CAAC,CAAC,CAACytB,YAAY,CAAC,MAAM,CAAC;IAChD,MAAMM,EAAE,GAAGD,WAAW,CAAC9tB,CAAC,CAAC,CAACytB,YAAY,CAAC,IAAI,CAAC;IAC5CruB,IAAI,CAACutB,YAAY,CAAC5hB,IAAI,CAAC5M,IAAI,GAAGA,IAAI,GAAG4vB,EAAE,GAAGA,EAAE,GAAG,SAAS,GAAG/tB,CAAC,CAAC;EAC/D;EAEA,OAAOZ,IAAI;AACb;AAEA,MAAM4uB,iBAAiB,GAAIlI,IAAY,IAAcA,IAAI,KAAK,OAAO,GAAG,CAAC,GAAGA,IAAI,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAE;;AAEtG;AACA;AACA,MAAMmI,UAAU,SAASvT,qEAAsB,CAAC;EAI9Cxc,WAAWA,CAACglB,GAAW,EAAE;IACvB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,GAAG,GAAGA,GAAG;EAChB;EAEA,MAAcgL,WAAWA,CAAA,EAAqB;IAC5C,IAAI,CAAC,IAAI,CAAC9uB,IAAI,EAAE;MACd,MAAM+uB,IAAI,GAAG,MAAM/C,gDAAO,CAAC,IAAI,CAAClI,GAAG,EAAE;QAAEkL,aAAa,EAAE;MAAK,CAAC,CAAC,CAAC5K,KAAK,CACjE5B,wEAAmB,CAAC,+BAA+B,IAAI,CAACsB,GAAG,EAAE,EAAEvB,oEAAmB,CAAC8B,SAAS,CAC9F,CAAC;MACD;MACA;MACA;MACA,MAAMxjB,KAAK,GAAG,MAAMkuB,IAAI,CACrBE,QAAQ,CAAC,CAAC,CACV7K,KAAK,CAAC5B,wEAAmB,CAAC,2BAA2B,EAAED,oEAAmB,CAAC8B,SAAS,CAAC,CAAC;MAEzF,MAAM6K,WAAW,GAAGhD,UAAU,CAACrrB,KAAK,CAACsuB,gBAAgB,CAAC,CAAC,CAACC,gBAAgB,CAAC;MACzE,MAAMC,KAAK,GAAGhD,MAAM,CAAC6C,WAAW,CAAC;MAEjC,MAAMI,QAAQ,GAAGD,KAAK,CAAC3C,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;MACvD,IAAI,CAAC1sB,IAAI,GAAGsuB,UAAU,CAACgB,QAAQ,CAAC;IAClC;IACA,OAAO,IAAI,CAACtvB,IAAI;EAClB;EAEA,MAAMwR,QAAQA,CAACqa,SAAmB,EAAyB;IACzD,MAAM7rB,IAAI,GAAG,MAAM,IAAI,CAAC8uB,WAAW,CAAC,CAAC;IAErC,MAAMtS,SAAS,GAAGiF,6EAAsB,CAACzhB,IAAI,CAAC+sB,KAAK,EAAE/sB,IAAI,CAAC6sB,KAAK,EAAE7sB,IAAI,CAAC8sB,KAAK,CAAC;IAC5E;IACA,MAAMyC,UAAU,GAAGlhB,iEAAc;IACjC,MAAMmhB,SAAS,GAAG1tB,IAAI,CAACC,KAAK,CAACwtB,UAAU,GAAG/S,SAAS,CAACnb,CAAC,CAAC;IACtD,MAAMouB,SAAS,GAAG3tB,IAAI,CAACC,KAAK,CAACwtB,UAAU,GAAG/S,SAAS,CAAClb,CAAC,CAAC;IAEtD,MAAMud,CAAa,GAAG;MACpBlX,KAAK,EAAE,CAAC3H,IAAI,CAACitB,KAAK,EAAEjtB,IAAI,CAACgtB,KAAK,EAAEhtB,IAAI,CAAC+sB,KAAK,EAAE0C,SAAS,EAAED,SAAS,CAAC;MACjE5nB,OAAO,EAAE,CACP,CAAC,EACD,CAAC,EACD5H,IAAI,CAACstB,UAAU,EACdttB,IAAI,CAACqtB,UAAU,GAAGrtB,IAAI,CAAC8sB,KAAK,GAAI2C,SAAS,EACzCzvB,IAAI,CAACotB,UAAU,GAAGptB,IAAI,CAAC6sB,KAAK,GAAI2C,SAAS,CAC3C;MACD3nB,SAAS,EAAE7H,IAAI,CAAC+a,IAAI,GAAG/a,IAAI,CAAC+a,IAAI,GAAG,QAAQ;MAC3CzY,QAAQ,EAAEkrB,QAAQ,CAACxtB,IAAI,CAACktB,SAAS,CAAC;MAClCplB,QAAQ,EAAE;IACZ,CAAC;IACD,OAAO,CAAC+W,CAAC,CAAC;EACZ;EAEA,MAAM9C,eAAeA,CAAC8P,SAAmB,EAA6B;IACpE,MAAM7rB,IAAI,GAAG,MAAM,IAAI,CAAC8uB,WAAW,CAAC,CAAC;IACrC;IACA;IACA;;IAEA;IACA;IACA,MAAMtS,SAAS,GAAGiF,6EAAsB,CAACzhB,IAAI,CAAC+sB,KAAK,EAAE/sB,IAAI,CAAC6sB,KAAK,EAAE7sB,IAAI,CAAC8sB,KAAK,CAAC;IAC5E;IACA,MAAMyC,UAAU,GAAGlhB,iEAAc;IACjC,MAAMmhB,SAAS,GAAG1tB,IAAI,CAACC,KAAK,CAACwtB,UAAU,GAAG/S,SAAS,CAACnb,CAAC,CAAC;IACtD,MAAMouB,SAAS,GAAG3tB,IAAI,CAACC,KAAK,CAACwtB,UAAU,GAAG/S,SAAS,CAAClb,CAAC,CAAC;;IAEtD;;IAEA,MAAMgnB,OAAkB,GAAG;MACzBvpB,IAAI,EAAE,MAAM;MAEZqI,aAAa,EAAE,CAACoV,SAAS,CAACnb,CAAC,EAAEmb,SAAS,CAAClb,CAAC,CAAC;MACzCsB,aAAa,EAAE,CAAC4sB,SAAS,EAAEC,SAAS,EAAEzvB,IAAI,CAAC+sB,KAAK,CAAC;MACjD1lB,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC1BC,mBAAmB,EAAEtH,IAAI,CAACgtB,KAAK;MAC/BzlB,YAAY,EAAEvH,IAAI,CAACutB,YAAY;MAC/B9lB,eAAe,EAAE,CAAC;MAClBC,mBAAmB,EAAE,CACnB;QACEC,KAAK,EAAE,CAAC3H,IAAI,CAACitB,KAAK,EAAEjtB,IAAI,CAACgtB,KAAK,EAAEhtB,IAAI,CAAC+sB,KAAK,EAAE0C,SAAS,EAAED,SAAS,CAAC;QACjE5nB,OAAO,EAAE,CACP,CAAC,EACD,CAAC,EACD5H,IAAI,CAACstB,UAAU,EACdttB,IAAI,CAACqtB,UAAU,GAAGrtB,IAAI,CAAC8sB,KAAK,GAAI2C,SAAS,EACzCzvB,IAAI,CAACotB,UAAU,GAAGptB,IAAI,CAAC6sB,KAAK,GAAI2C,SAAS,CAC3C;QACD3nB,SAAS,EAAE7H,IAAI,CAAC+a,IAAI,IAAI,EAAE;QAC1BjT,QAAQ,EAAE,EAAE;QACZxF,QAAQ,EAAEkrB,QAAQ,CAACxtB,IAAI,CAACktB,SAAS;MACnC,CAAC,CACF;MAEDnlB,SAAS,EAAE;QACTC,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACtBC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACnBC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;MACjB;IACF,CAAC;;IAED;IACA,OAAO;MAAEE,SAAS,EAAEkgB,OAAO;MAAE9Z,QAAQ,EAAE,IAAIJ,uDAAQ,CAAC;IAAE,CAAC;EACzD;EAEA,MAAMqO,kBAAkBA,CACtBrU,SAAoB,EACpByjB,SAAmB,EACnB6D,iBAA6B,EAC7B5Q,MAA8B,EACf;IACf,MAAM9e,IAAI,GAAG,MAAM,IAAI,CAAC8uB,WAAW,CAAC,CAAC;;IAErC;IACA,MAAMa,UAAU,GAAG,IAAIxnB,qDAAU,CAACC,SAAS,CAAC;IAC5C,MAAMrB,UAAU,GAAG4oB,UAAU,CAAC5oB,UAAU;IAExC,MAAM6oB,YAA6B,GAAG,EAAE;IACxC;IACA,KAAK,IAAI7f,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG3H,SAAS,CAACd,mBAAmB,EAAE,EAAEyI,OAAO,EAAE;MACxE,MAAM8f,eAAe,GAAG,IAAI3O,OAAO,CAAO,CAAC4D,OAAO,EAAEgL,MAAM,KAAK;QAC7D,MAAMC,MAAwB,GAAG;UAC/BhgB,OAAO,EAAEA,OAAO;UAChB;UACA;UACAyf,SAAS,EAAEzoB,UAAU,CAAC1F,CAAC;UACvBouB,SAAS,EAAE1oB,UAAU,CAACzF,CAAC;UACvB0rB,KAAK,EAAE5kB,SAAS,CAACd,mBAAmB;UACpCylB,KAAK,EAAEhmB,UAAU,CAACxF,CAAC;UACnByuB,cAAc,EAAEhwB,IAAI,CAACmtB,cAAc;UACnC8C,cAAc,EAAErB,iBAAiB,CAAC5uB,IAAI,CAACktB,SAAS,CAAC;UACjDpJ,GAAG,EAAE,IAAI,CAACA;QACZ,CAAC;QAED,MAAMoM,MAAM,GAAG,IAAIC,MAAM,CAAC,IAAIC,GAAG,CAAC,0HAA6C,CAAC,CAAC;QACjFF,MAAM,CAACK,SAAS,GAAI3pB,CAAuE,IAAK;UAC9F,IAAIA,CAAC,CAACzH,IAAI,CAACqxB,OAAO,EAAE;YAClBV,MAAM,CAAC7D,iEAAgB,CAACrlB,CAAC,CAACzH,IAAI,CAACoW,KAAK,CAAC,CAAC;YACtC;UACF;UACA,MAAM;YAAEpW,IAAI;YAAEF,KAAK;YAAE8Q,OAAO;YAAEkD;UAAM,CAAC,GAAGrM,CAAC,CAACzH,IAAI;UAC9C2f,MAAM,CAAC,CAAC/O,OAAO,CAAC,EAAE,CAAC9Q,KAAK,CAAC,EAAE,CAACE,IAAI,CAAC,EAAE,CAAC8T,KAAK,CAAC,CAAC;UAC3Cid,MAAM,CAACO,SAAS,CAAC,CAAC;UAClB3L,OAAO,CAAC,CAAC;QACX,CAAC;QAEDoL,MAAM,CAACQ,WAAW,CAACX,MAAM,CAAC;MAC5B,CAAC,CAAC;MAEFH,YAAY,CAACjkB,IAAI,CAACkkB,eAAe,CAAC;IACpC;;IAEA;IACA,MAAM3O,OAAO,CAACC,GAAG,CAACyO,YAAY,CAAC;EACjC;AACF;;;;;;;;;;;;;;;;;;;;AC3RoD;AACQ;AAC5D;;AAEA;AACO,IAAWrN,mBAAmB,0BAAnBA,mBAAmB;EAAnBA,mBAAmB;EAAnBA,mBAAmB;EAAnBA,mBAAmB;EAAnBA,mBAAmB;EAAnBA,mBAAmB;EAAnBA,mBAAmB;EAAA,OAAnBA,mBAAmB;AAAA;AAS9B,MAAMD,eAAe,SAASsJ,KAAK,CAAC;EAGzC9sB,WAAWA,CAACgyB,OAAgB,EAAE5J,OAAyD,EAAE;IACvF,KAAK,CAAC4J,OAAO,EAAE5J,OAAO,CAAC;IACvB,IAAI,CAACnoB,IAAI,GAAG,iBAAiB;IAC7B,IAAI,CAAC2nB,IAAI,GAAGQ,OAAO,EAAER,IAAI,IAAInE,mBAAmB,CAACwO,OAAO;EAC1D;AACF;;AAEA;AACA;AACAJ,uDAAiB,CAAChwB,GAAG,CAAC,mBAAmB,EAAEiwB,4DAAqC,CAAC;AACjFD,uDAAiB,CAAChwB,GAAG,CAAC,UAAU,EAAEkwB,mDAA4B,CAAC;AAC/DF,uDAAiB,CAAChwB,GAAG,CAAC,iBAAiB,EAAE2hB,eAA8C,CAAC;;AAExF;AACO,SAASE,mBAAmBA,CACjCsO,OAAO,GAAG,kDAAkD,EAC5DpK,IAAI,GAAGnE,mBAAmB,CAACwO,OAAO,EAClCC,MAAgB,EACH;EACb,OAAQpqB,CAAI,IAAK;IACf,IAAIoqB,MAAM,KAAKrf,SAAS,IAAI/K,CAAC,KAAKoqB,MAAM,EAAE;MACxC,OAAOpqB,CAAC;IACV;IACA,IAAIA,CAAC,YAAY0b,eAAe,EAAE;MAChC,MAAM1b,CAAC;IACT;IACApE,OAAO,CAACqB,GAAG,CAAC,8BAA8B+C,CAAC,EAAE,CAAC;IAC9C,MAAM,IAAI0b,eAAe,CAACwO,OAAO,EAAE;MAAEpK,IAAI;MAAEiG,KAAK,EAAE/lB;IAAE,CAAC,CAAC;EACxD,CAAC;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9C+C;AAEc;AAGtD,MAAMyH,cAAc,GAAG,IAAI;;AAElC;AACA,MAAM4iB,YAAY,GAAG;EACnBC,QAAQ,EAAE,GAAG;EACbC,GAAG,EAAE,GAAG;EACRC,IAAI,EAAE,IAAI;EACVC,IAAI,EAAE,GAAG;EACTC,IAAI,EAAE,IAAI;EACVC,KAAK,EAAE,GAAG;EACVC,MAAM,EAAE,IAAI;EACZC,IAAI,EAAE,IAAI;EACVC,MAAM,EAAE,KAAK;EACbC,MAAM,EAAE,IAAI;EACZ5jB,MAAM,EAAE,GAAG;EACX6jB,IAAI,EAAE;AACR,CAAC;;AAED;AACA,MAAMC,QAAuC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC;;AAEnE;AACA,MAAMC,eAAe,GAAG;EACtBC,KAAK,EAAE,GAAG;EACVC,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACO,SAASpQ,gBAAgBA,CAACqQ,QAAiB,EAAiB;EACjE,IAAIA,QAAQ,KAAKtgB,SAAS,EAAE;IAC1B,OAAO,IAAI;EACb;EAEA,IAAIsf,YAAY,CAACgB,QAAQ,CAAC,EAAE;IAC1B,OAAOhB,YAAY,CAACgB,QAAQ,CAAC;EAC/B;EAEA,MAAMC,cAAc,GAAGL,QAAQ,CAACM,IAAI,CAAEC,MAAM,IAAKH,QAAQ,CAACpJ,QAAQ,CAACuJ,MAAM,CAAC,CAAC;EAC3E,IAAIF,cAAc,EAAE;IAClB,MAAMlc,MAAM,GAAGic,QAAQ,CAACI,SAAS,CAAC,CAAC,EAAEJ,QAAQ,CAACptB,MAAM,GAAGqtB,cAAc,CAACrtB,MAAM,CAAC;IAE7E,IAAIitB,eAAe,CAAC9b,MAAM,CAAC,EAAE;MAC3B;MACA,OAAO8b,eAAe,CAAC9b,MAAM,CAAC,GAAGib,YAAY,CAACiB,cAAc,CAAC;IAC/D;;IAEA;IACA,MAAMI,UAAU,GAAGtc,MAAM,CAAC6S,QAAQ,CAAC,GAAG,CAAC;IACvC,MAAM0J,UAAU,GAAGD,UAAU,GAAGtc,MAAM,CAAC,CAAC,CAAC,CAACwc,WAAW,CAAC,CAAC,GAAGxc,MAAM,CAAC,CAAC,CAAC;IACnE,OAAOuc,UAAU,GAAGtB,YAAY,CAACiB,cAAc,CAAC;EAClD;EAEA,OAAO,IAAI;AACb;;AAEA;AACA;AACO,SAASzQ,sBAAsBA,CAAClgB,CAAS,EAAEkxB,EAAU,EAAE/rB,EAAU,EAAW;EACjF,IAAIgsB,QAAQ,GAAG,CAAC;EAChB,IAAIC,QAAQ,GAAGpxB,CAAC;EAChB,IAAIqxB,KAAK,GAAID,QAAQ,GAAGF,EAAE,IAAKC,QAAQ,GAAGhsB,EAAE,CAAC;EAC7C,IAAImsB,KAAK,GAAGH,QAAQ;EACpB,IAAII,KAAK,GAAGH,QAAQ;EACpB,OAAOC,KAAK,GAAG,CAAC,EAAE;IAChBC,KAAK,GAAGH,QAAQ;IAChBI,KAAK,GAAGH,QAAQ;IAChBA,QAAQ,IAAI,CAAC;IACbD,QAAQ,GAAG5wB,IAAI,CAACuL,IAAI,CAAC9L,CAAC,GAAGoxB,QAAQ,CAAC;IAClCC,KAAK,GAAID,QAAQ,GAAGF,EAAE,IAAKC,QAAQ,GAAGhsB,EAAE,CAAC;EAC3C;EACA,OAAO,IAAIQ,0CAAO,CAAC2rB,KAAK,EAAEC,KAAK,CAAC;AAClC;AAEA,SAASC,8BAA8BA,CACrCC,aAAuC,EACvCrkB,YAAY,GAAGN,cAAc,EACpB;EACT;EACA,MAAMhN,CAAC,GAAG2xB,aAAa,CAAC,CAAC,CAAC;EAC1B,MAAM1xB,CAAC,GAAG0xB,aAAa,CAAC,CAAC,CAAC;EAC1B,MAAMzxB,CAAC,GAAGyxB,aAAa,CAAC,CAAC,CAAC;EAC1B,MAAMC,MAAM,GAAGnxB,IAAI,CAACC,KAAK,CAAC4M,YAAY,GAAGtN,CAAC,CAAC;EAC3C,MAAM6xB,MAAM,GAAGpxB,IAAI,CAACC,KAAK,CAAC4M,YAAY,GAAGrN,CAAC,CAAC;EAC3C,OAAO2xB,MAAM,GAAGC,MAAM,IAAI3xB,CAAC;AAC7B;;AAEA;AACO,SAAS4xB,qBAAqBA,CACnCC,cAA0C,EAC1CzkB,YAAY,GAAGN,cAAc,EACT;EACpB,IAAI+kB,cAAc,CAACvuB,MAAM,IAAI,CAAC,EAAE;IAC9B,OAAO,CAAC;EACV;EAEA,KAAK,IAAIjE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwyB,cAAc,CAACvuB,MAAM,EAAE,EAAEjE,CAAC,EAAE;IAC9C;IACA,IAAImyB,8BAA8B,CAACK,cAAc,CAACxyB,CAAC,CAAC,EAAE+N,YAAY,CAAC,EAAE;MACnE,OAAO/N,CAAC;IACV;EACF;EACA,OAAO+Q,SAAS;AAClB;AAGA,MAAM0hB,OAAO,GAAI5xB,GAAW,IAAaK,IAAI,CAACb,GAAG,CAACa,IAAI,CAACuL,IAAI,CAAC5L,GAAG,CAAC,EAAE,CAAC,CAAC;AACpE,MAAM6xB,SAAS,GAAGA,CAACzhB,IAAa,EAAE,CAACtQ,CAAC,EAAED,CAAC,EAAED,CAAC,CAAM,KAAU,CACxDgyB,OAAO,CAAC9xB,CAAC,GAAGsQ,IAAI,CAACtQ,CAAC,CAAC,EACnB8xB,OAAO,CAAC/xB,CAAC,GAAGuQ,IAAI,CAACvQ,CAAC,CAAC,EACnB+xB,OAAO,CAAChyB,CAAC,GAAGwQ,IAAI,CAACxQ,CAAC,CAAC,CACpB;AAEM,SAASkyB,oBAAoBA,CAACpkB,SAAe,EAAEnP,IAAS,EAAO;EACpE,MAAM6R,IAAI,GAAG1C,SAAS,CAACkY,OAAO,CAAC,IAAIpgB,0CAAO,CAAC,CAAC,CAAC;EAC7C,OAAOqsB,SAAS,CAACzhB,IAAI,EAAE7R,IAAI,CAAC;AAC9B;AAEO,SAASwzB,4BAA4BA,CAACrkB,SAAe,EAAEnP,IAAW,EAAS;EAChF,MAAM6R,IAAI,GAAG1C,SAAS,CAACkY,OAAO,CAAC,IAAIpgB,0CAAO,CAAC,CAAC,CAAC;EAC7C,OAAOjH,IAAI,CAACiM,GAAG,CAAE0d,GAAG,IAAK2J,SAAS,CAACzhB,IAAI,EAAE8X,GAAG,CAAC,CAAC;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASrb,uBAAuBA,CAACE,QAAkB,EAAE4kB,cAAqB,EAAU;EACzF,IAAI5kB,QAAQ,CAACiC,gBAAgB,IAAIjC,QAAQ,CAAC/G,eAAe,KAAKkK,SAAS,EAAE;IACvE;IACA,OAAO7P,IAAI,CAACb,GAAG,CAAC,CAAC,EAAEa,IAAI,CAACd,GAAG,CAACoyB,cAAc,CAACvuB,MAAM,GAAG,CAAC,EAAE2J,QAAQ,CAAC/G,eAAe,CAAC,CAAC;EACnF;EAEA,IAAI6J,WAAW,GAAG6hB,qBAAqB,CAACC,cAAc,EAAE5kB,QAAQ,CAACG,YAAY,CAAC;EAC9E;EACA,IAAI2C,WAAW,KAAKK,SAAS,EAAE;IAC7BL,WAAW,GAAGxP,IAAI,CAACb,GAAG,CAACqQ,WAAW,IAAI9C,QAAQ,CAACE,cAAc,IAAI,CAAC,CAAC,EAAEF,QAAQ,CAAC/G,eAAe,IAAI,CAAC,CAAC;IACnG6J,WAAW,GAAGxP,IAAI,CAACb,GAAG,CAAC,CAAC,EAAEa,IAAI,CAACd,GAAG,CAACoyB,cAAc,CAACvuB,MAAM,GAAG,CAAC,EAAEyM,WAAW,CAAC,CAAC;IAE3E,IAAIyhB,8BAA8B,CAACK,cAAc,CAAC9hB,WAAW,CAAC,EAAE9C,QAAQ,CAACG,YAAY,CAAC,EAAE;MACtF,OAAO2C,WAAW;IACpB;EACF;;EAEA;EACA,IAAIA,WAAW,KAAKK,SAAS,EAAE;IAC7B;IACAL,WAAW,GAAG8hB,cAAc,CAACvuB,MAAM,GAAG,CAAC;EACzC;EACA,MAAM4uB,YAAY,GAAGL,cAAc,CAAC9hB,WAAW,CAAC;EAChD9O,OAAO,CAAC+S,KAAK,CACX,0GAA0GjE,WAAW,mBAAmB,EACxImiB,YAAY,EACZ,+BAA+BjlB,QAAQ,CAACG,YAAY,GACtD,CAAC;EACDnM,OAAO,CAACqB,GAAG,CAAC,wBAAwB,EAAEuvB,cAAc,CAAC;EAErD,OAAO9hB,WAAW;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASqQ,eAAeA,CAACnT,QAAkB,EAAE4kB,cAAqB,EAAU;EACjF,MAAMM,UAAU,GAAGF,4BAA4B,CAAChlB,QAAQ,CAACW,SAAS,EAAEikB,cAAc,CAAC;EACnF,OAAO9kB,uBAAuB,CAACE,QAAQ,EAAEklB,UAAU,CAAC;AACtD;;AAEA;AACO,SAAShS,wBAAwBA,CAACiS,MAAY,EAAE9hB,IAAa,EAAQ;EAC1E,MAAM7Q,GAAG,GAAG2yB,MAAM,CAAC3yB,GAAG,CAACoO,KAAK,CAAC,CAAC,CAAC0C,QAAQ,CAACD,IAAI,CAAC,CAAC9P,KAAK,CAAC,CAAC;EACrD,MAAMd,GAAG,GAAG0yB,MAAM,CAAC1yB,GAAG,CAACmO,KAAK,CAAC,CAAC,CAAC0C,QAAQ,CAACD,IAAI,CAAC,CAACxE,IAAI,CAAC,CAAC;;EAEpD;EACA,IAAIrM,GAAG,CAACK,CAAC,KAAKJ,GAAG,CAACI,CAAC,IAAIL,GAAG,CAACK,CAAC,GAAGwQ,IAAI,CAACxQ,CAAC,EAAE;IACrCJ,GAAG,CAACI,CAAC,IAAI,CAAC;EACZ;EACA,IAAIL,GAAG,CAACM,CAAC,KAAKL,GAAG,CAACK,CAAC,IAAIN,GAAG,CAACM,CAAC,GAAGuQ,IAAI,CAACvQ,CAAC,EAAE;IACrCL,GAAG,CAACK,CAAC,IAAI,CAAC;EACZ;EACA,IAAIN,GAAG,CAACO,CAAC,KAAKN,GAAG,CAACM,CAAC,IAAIP,GAAG,CAACO,CAAC,GAAGsQ,IAAI,CAACtQ,CAAC,EAAE;IACrCN,GAAG,CAACM,CAAC,IAAI,CAAC;EACZ;EAEA,OAAO,IAAI2Z,uCAAI,CAACla,GAAG,EAAEC,GAAG,CAAC;AAC3B;;AAEA;AACA;AACA;AACA;AACO,SAASugB,gBAAgBA,CAACmS,MAAY,EAAEC,SAAe,EAAQ;EACpE,MAAM/hB,IAAI,GAAG+hB,SAAS,CAACvM,OAAO,CAAC,IAAIpgB,0CAAO,CAAC,CAAC,CAAC;EAC7C,MAAMjG,GAAG,GAAG2yB,MAAM,CAAC3yB,GAAG,CAACoO,KAAK,CAAC,CAAC,CAAC0C,QAAQ,CAACD,IAAI,CAAC,CAACO,GAAG,CAACwhB,SAAS,CAAC5yB,GAAG,CAAC;EAChE,MAAMC,GAAG,GAAG0yB,MAAM,CAAC1yB,GAAG,CAACmO,KAAK,CAAC,CAAC,CAAC0C,QAAQ,CAACD,IAAI,CAAC,CAACO,GAAG,CAACwhB,SAAS,CAAC5yB,GAAG,CAAC;EAChE,OAAO,IAAIka,uCAAI,CAACla,GAAG,EAAEC,GAAG,CAAC;AAC3B;AAEA,SAAS4yB,OAAOA,CAACC,GAAG,EAAE;EACpB,KAAK,MAAM/e,GAAG,IAAI+e,GAAG,EAAE;IACrB,IAAI/a,MAAM,CAACgb,SAAS,CAACC,cAAc,CAACC,IAAI,CAACH,GAAG,EAAE/e,GAAG,CAAC,EAAE;MAClD,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACO,SAASoG,oBAAoBA,CAAC+Y,YAAuB,EAA2B;EACrF;EACA,MAAM9rB,SAAS,GAAG,IAAID,qDAAU,CAAC+rB,YAAY,CAAC;EAC9C,MAAM1kB,YAAY,GAAGpH,SAAS,CAACrB,UAAU,CAACqI,KAAK,CAAC,CAAC,CAAC0C,QAAQ,CAAC1J,SAAS,CAACpB,iBAAiB,CAAC;EACvF,MAAMmtB,QAAQ,GAAG,CAAC,CAAC;EACnBA,QAAQ,CAAC,YAAY,CAAC,GAAG;IAAE,GAAG/rB,SAAS,CAACxF;EAAc,CAAC;EACvDuxB,QAAQ,CAAC,qBAAqB,CAAC,GAAG;IAAE,GAAG/rB,SAAS,CAACG;EAAa,CAAC;EAC/D4rB,QAAQ,CAAC,eAAe,CAAC,GAAG;IAC1B9yB,CAAC,EAAEmO,YAAY,CAACnO,CAAC,GAAG+G,SAAS,CAACI,WAAW;IACzClH,CAAC,EAAEkO,YAAY,CAAClO,CAAC,GAAG8G,SAAS,CAACI,WAAW;IACzCjH,CAAC,EAAEiO,YAAY,CAACjO,CAAC,GAAG6G,SAAS,CAACI;EAChC,CAAC;EACD2rB,QAAQ,CAAC,yBAAyB,CAAC,GAAG;IACpC9yB,CAAC,EAAE+G,SAAS,CAACpB,iBAAiB,CAAC3F,CAAC,GAAG+G,SAAS,CAACI,WAAW;IACxDlH,CAAC,EAAE8G,SAAS,CAACpB,iBAAiB,CAAC1F,CAAC,GAAG8G,SAAS,CAACI,WAAW;IACxDjH,CAAC,EAAE6G,SAAS,CAACpB,iBAAiB,CAACzF,CAAC,GAAG6G,SAAS,CAACI;EAC/C,CAAC;EACD2rB,QAAQ,CAAC,wBAAwB,CAAC,GAAGD,YAAY,CAACxsB,mBAAmB;EACrE;EACAysB,QAAQ,CAAC,UAAU,CAAC,GAAGD,YAAY,CAAC5sB,mBAAmB,CAAC,CAAC;EACzD6sB,QAAQ,CAAC,oBAAoB,CAAC,GAAG/rB,SAAS,CAACK,KAAK,IAAI,CAAC;EACrD;EACA,IAAIyrB,YAAY,CAACnW,QAAQ,IAAI,CAAC8V,OAAO,CAACK,YAAY,CAACnW,QAAQ,CAAC,EAAE;IAC5DoW,QAAQ,CAAC,WAAW,CAAC,GAAGD,YAAY,CAACnW,QAAQ;EAC/C;EACA,OAAOoW,QAAQ;AACjB;;;;;;;;;;;;;;;;;;;;;;;ACvPgF;AACjB;AACa;AAC/B;AAIa;AAEnD,IAAWE,gBAAgB,0BAAhBA,gBAAgB;EAAhBA,gBAAgB;EAAhBA,gBAAgB;EAAhBA,gBAAgB;EAAhBA,gBAAgB;EAAA,OAAhBA,gBAAgB;AAAA;;AAOlC;;AAUO,SAASC,cAAcA,CAACzP,IAAY,EAAoB;EAC7D,IAAIA,IAAI,CAACgE,QAAQ,CAAC,OAAO,CAAC,EAAE;IAC1B,OAAOwL,gBAAgB,CAACE,IAAI;EAC9B,CAAC,MAAM,IAAI1P,IAAI,CAACgE,QAAQ,CAAC,MAAM,CAAC,IAAIhE,IAAI,CAACgE,QAAQ,CAAC,OAAO,CAAC,EAAE;IAC1D,OAAOwL,gBAAgB,CAACG,IAAI;EAC9B;EACA,OAAOH,gBAAgB,CAACI,IAAI;AAC9B;AAEO,eAAeC,kBAAkBA,CACtC7P,IAAuB,EACvBqC,OAA6B,EACI;EACjC,MAAMyN,UAAU,GAAG9lB,KAAK,CAACyP,OAAO,CAACuG,IAAI,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI;EACvD,MAAM+P,QAAQ,GAAG1N,OAAO,EAAE0N,QAAQ,IAAIN,cAAc,CAACK,UAAU,CAAC;EAEhE,QAAQC,QAAQ;IACd,KAAKP,gBAAgB,CAACI,IAAI;MACxB,OAAO,MAAMxR,4DAAa,CAACK,YAAY,CACrCuB,IAAI,EACJqC,OAAO,EAAE5C,KAAK,EACd4C,OAAO,EAAE7I,KAAK,EACd6I,OAAO,EAAE1D,KAAK,EACd0D,OAAO,EAAE9D,YACX,CAAC;IACH,KAAKiR,gBAAgB,CAACE,IAAI;MACxB,OAAO,IAAIrW,wEAAmB,CAAC2G,IAAI,EAAEqC,OAAO,EAAE7I,KAAK,CAAC;IACtD,KAAKgW,gBAAgB,CAACG,IAAI;MACxB,OAAO,IAAI3F,sDAAU,CAAC8F,UAAU,CAAC;IACnC,KAAKN,gBAAgB,CAACQ,IAAI;MACxB,IAAI,CAAC3N,OAAO,EAAE4N,eAAe,EAAE;QAC7B,MAAM,IAAIlJ,KAAK,CAAC,iDAAiD,CAAC;MACpE;MACA,OAAO,IAAIH,8DAAc,CAACvE,OAAO,EAAE4N,eAAe,CAAC31B,IAAI,EAAE+nB,OAAO,EAAE4N,eAAe,CAACX,QAAQ,CAAC;EAC/F;AACF;;;;;;;;;;;;;;;AClDA,MAAMY,QAAQ,GAAOluB,GAAQ,IAAcA,GAAG,CAAC6L,KAAK,CAAEiH,CAAC,IAAKA,CAAC,KAAK9S,GAAG,CAAC,CAAC,CAAC,CAAC;AAEzE,MAAMmuB,KAAK,GAAGA,CAAInuB,GAAQ,EAAEpF,GAAM,EAAEwzB,CAAS,KAAW;EACtD,KAAK,IAAIr0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGq0B,CAAC,EAAEr0B,CAAC,EAAE,EAAE;IAC1BiG,GAAG,CAAC8E,IAAI,CAAClK,GAAG,CAAC;EACf;AACF,CAAC;AAED,MAAMyzB,gBAAgB,GAAIC,GAAsB,IAAa;EAC3D,MAAMC,MAAM,GAAGD,GAAG,IAAI,CAAC,CAAC,CAAC;EACzB,OAAOC,MAAM,GAAG3G,MAAM,CAAC2G,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;AACxC,CAAC;AAED,SAASC,YAAYA,CAAC5zB,GAAW,EAAE6zB,MAAwB,EAAQ;EACjE,IAAI7zB,GAAG,GAAG6zB,MAAM,CAAC,CAAC,CAAC,EAAE;IACnBA,MAAM,CAAC,CAAC,CAAC,GAAG7zB,GAAG;EACjB;EAEA,IAAIA,GAAG,GAAG6zB,MAAM,CAAC,CAAC,CAAC,EAAE;IACnBA,MAAM,CAAC,CAAC,CAAC,GAAG7zB,GAAG;EACjB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACe,MAAMogB,qBAAqB,CAAC;EAIzC/iB,WAAWA,CACT8qB,MAAuB,EACvB2L,qBAA2B,EAC3BC,oBAAqC,EACrCnS,kBAAwC,EACxCyG,sBAAsB,GAAG,KAAK,EAC9B;IACA;IACA,MAAM2L,OAA2B,GAAG,CAClC,CAACtnB,QAAQ,EAAE,CAACA,QAAQ,CAAC,EACrB,CAACA,QAAQ,EAAE,CAACA,QAAQ,CAAC,EACrB,CAACA,QAAQ,EAAE,CAACA,QAAQ,CAAC,EACrB,CAACA,QAAQ,EAAE,CAACA,QAAQ,CAAC,CACtB;IAED,KAAK,MAAM8b,KAAK,IAAIL,MAAM,EAAE;MAC1ByL,YAAY,CAACpL,KAAK,CAAC,CAAC,CAAC,EAAEwL,OAAO,CAAC,CAAC,CAAC,CAAC;MAClCJ,YAAY,CAACpL,KAAK,CAAC,CAAC,CAAC,EAAEwL,OAAO,CAAC,CAAC,CAAC,CAAC;MAClCJ,YAAY,CAACpL,KAAK,CAAC,CAAC,CAAC,EAAEwL,OAAO,CAAC,CAAC,CAAC,CAAC;MAClCJ,YAAY,CAACpL,KAAK,CAAC,CAAC,CAAC,EAAEwL,OAAO,CAAC,CAAC,CAAC,CAAC;IACpC;;IAEA;IACA,IAAI,CAACC,eAAe,GAAG,EAAE;IACzB,IAAI,CAACC,uBAAuB,GAAG,EAAE;;IAEjC;IACA;IACA;IACA,KAAK,MAAM,CAACC,SAAS,EAAEC,KAAK,CAAC,IAAIJ,OAAO,CAACK,IAAI,CAAC,CAAC,CAACthB,OAAO,CAAC,CAAC,EAAE;MACzD,MAAMuhB,SAAS,GAAGH,SAAS,IAAI,CAAC,CAAC,CAAC;MAClC,MAAMI,UAAU,GAAGD,SAAS,GAAGtH,MAAM,CAACsH,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC;MACxD,IAAIE,GAAsB;MAC1B,IAAIL,SAAS,GAAG,CAAC,EAAE;QACjB;QACA;QACA,MAAMM,aAAa,GAAGV,oBAAoB,CAACvpB,GAAG,CAAEkqB,SAAS,IAAK;UAC5D,OAAOr0B,IAAI,CAACd,GAAG,CAAC60B,KAAK,GAAGN,qBAAqB,CAACQ,SAAS,CAAC,EAAEI,SAAS,CAACH,UAAU,CAAC,GAAG,CAAC,CAAC;QACtF,CAAC,CAAC;;QAEF;QACA,IAAIjB,QAAQ,CAACmB,aAAa,CAAC,EAAE;UAC3BD,GAAG,GAAGC,aAAa,CAAC,CAAC,CAAC;QACxB,CAAC,MAAM;UACL;UACAD,GAAG,GAAG,EAAE;UACR,KAAK,MAAM,CAACr1B,CAAC,EAAEw1B,SAAS,CAAC,IAAIF,aAAa,CAAC1hB,OAAO,CAAC,CAAC,EAAE;YACpDwgB,KAAK,CAACiB,GAAG,EAAEG,SAAS,EAAEZ,oBAAoB,CAAC50B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;UACnD;QACF;QACA;MACF,CAAC,MAAM;QACL;QACA;QACAq1B,GAAG,GAAGn0B,IAAI,CAACb,GAAG,CAAC40B,KAAK,GAAGN,qBAAqB,CAACQ,SAAS,CAAC,EAAE,CAAC,CAAC;MAC7D;MACA,MAAMM,cAAc,GAAG;QAAET,SAAS;QAAEC,KAAK;QAAEI,GAAG;QAAErM,MAAM,EAAE;MAAG,CAAC;MAE5D,IAAIvG,kBAAkB,IAAIA,kBAAkB,CAACxS,QAAQ,CAAC+kB,SAAS,CAAC,EAAE;QAChE,IAAI,CAACD,uBAAuB,CAAChqB,IAAI,CAAC0qB,cAAc,CAAC;MACnD,CAAC,MAAM;QACL;QACA,IAAI,CAACvM,sBAAsB,EAAE;UAC3B,IAAI,CAAC4L,eAAe,CAAC/pB,IAAI,CAAC0qB,cAAc,CAAC;QAC3C;MACF;IACF;;IAEA;IACA,KAAK,MAAMpM,KAAK,IAAIL,MAAM,EAAE;MAC1B,KAAK,MAAMuL,GAAG,IAAI,IAAI,CAACO,eAAe,EAAE;QACtC,IAAIzL,KAAK,CAACiL,gBAAgB,CAACC,GAAG,CAACS,SAAS,CAAC,CAAC,KAAKT,GAAG,CAACU,KAAK,EAAE;UACxDV,GAAG,CAACvL,MAAM,CAACje,IAAI,CAACse,KAAK,CAAC;QACxB;MACF;MACA,KAAK,MAAMkL,GAAG,IAAI,IAAI,CAACQ,uBAAuB,EAAE;QAC9C,IAAI1L,KAAK,CAACiL,gBAAgB,CAACC,GAAG,CAACS,SAAS,CAAC,CAAC,KAAKT,GAAG,CAACU,KAAK,EAAE;UACxDV,GAAG,CAACvL,MAAM,CAACje,IAAI,CAACse,KAAK,CAAC;QACxB;MACF;IACF;EACF;EAEA,QAAgBqM,iBAAiBA,CAACrP,UAAoC,EAA4B;IAChG,IAAIjlB,MAAM,GAAG,CAAC;IAEd,OAAOilB,UAAU,CAACpiB,MAAM,GAAG,CAAC,EAAE;MAC5B;MACAoiB,UAAU,GAAGA,UAAU,CAAChI,MAAM,CAAEkW,GAAG,IAAK;QACtC,MAAMc,GAAG,GAAGpnB,KAAK,CAACyP,OAAO,CAAC6W,GAAG,CAACc,GAAG,CAAC,GAAGn0B,IAAI,CAACb,GAAG,CAAC,GAAGk0B,GAAG,CAACc,GAAG,CAAC,GAAGd,GAAG,CAACc,GAAG;QACnE,IAAId,GAAG,CAACS,SAAS,GAAG,CAAC,EAAE;UACrB,OAAOT,GAAG,CAACU,KAAK,GAAG7zB,MAAM,IAAIi0B,GAAG;QAClC,CAAC,MAAM;UACL,OAAOd,GAAG,CAACU,KAAK,GAAG7zB,MAAM,IAAIi0B,GAAG;QAClC;MACF,CAAC,CAAC;;MAEF;MACA,KAAK,MAAMd,GAAG,IAAIlO,UAAU,EAAE;QAC5B,MAAMsP,SAAS,GAAGv0B,MAAM,IAAImzB,GAAG,CAACS,SAAS,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QACvD,KAAK,MAAM3L,KAAK,IAAIkL,GAAG,CAACvL,MAAM,EAAE;UAC9B;UACA,IAAI/a,KAAK,CAACyP,OAAO,CAAC6W,GAAG,CAACc,GAAG,CAAC,IAAIhM,KAAK,CAACiL,gBAAgB,CAACC,GAAG,CAACS,SAAS,CAAC,CAAC,GAAGW,SAAS,GAAGpB,GAAG,CAACc,GAAG,CAAChM,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;YACpG;UACF;UACA,MAAMuM,QAAQ,GAAGvM,KAAK,CAAC/a,KAAK,CAAC,CAAkB;UAC/CsnB,QAAQ,CAACtB,gBAAgB,CAACC,GAAG,CAACS,SAAS,CAAC,CAAC,IAAIW,SAAS;UACtD,MAAMC,QAAQ;QAChB;MACF;MAEAx0B,MAAM,IAAI,CAAC;IACb;EACF;EAEA,EAAEy0B,MAAM,CAACC,QAAQ,IAA6B;IAC5C;IACA,IAAI,IAAI,CAACf,uBAAuB,CAAC9wB,MAAM,GAAG,CAAC,EAAE;MAC3C,KAAK,MAAMolB,KAAK,IAAIpI,qBAAqB,CAACyU,iBAAiB,CAAC,IAAI,CAACX,uBAAuB,CAAC,EAAE;QACzF,MAAM1L,KAAK;MACb;IACF;;IAEA;IACA,KAAK,MAAMA,KAAK,IAAIpI,qBAAqB,CAACyU,iBAAiB,CAAC,IAAI,CAACZ,eAAe,CAAC,EAAE;MACjF,MAAMzL,KAAK;IACb;EACF;AACF;;;;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA,MAAMnI,YAAY,CAAkG;EAClHhjB,WAAWA,CAAS63B,SAAY,EAAUtY,KAAmB,EAAUmF,KAAgC,EAAE;IAAA,KAArFmT,SAAY,GAAZA,SAAY;IAAA,KAAUtY,KAAmB,GAAnBA,KAAmB;IAAA,KAAUmF,KAAgC,GAAhCA,KAAgC;EAAG;EAC1G;EACA7iB,GAAGA,CAACi2B,IAAkB,EAAEC,MAAkB,EAAiB;IACzD,OAAO3V,OAAO,CAAC4D,OAAO,CAAC,CAAC;EAC1B;EAEA,MAAcgS,WAAWA,CAAC/hB,GAAiB,EAAEgiB,QAAgB,EAAE7L,IAAW,EAAmC;IAC3G,MAAMrV,MAAM,GAAG,MAAM,IAAI,CAAC8gB,SAAS,CAAC7gB,GAAG,CAACf,GAAG,EAAEmW,IAAI,CAAC;IAClD,IAAI,IAAI,CAAC7M,KAAK,IAAIxI,MAAM,EAAE;MACxB,IAAI,CAACwI,KAAK,CAAC5I,MAAM,CAACshB,QAAQ,EAAElhB,MAAM,CAAC;IACrC;IACA,OAAOA,MAAM;EACf;EAEA,MAAMC,GAAGA,CAACf,GAAiB,EAAEmW,IAAyC,EAAmC;IACvG,MAAM8L,SAAS,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,CAAC;IAChE,IAAI,CAAC,IAAI,CAAC3Y,KAAK,IAAI2Y,SAAS,CAACpmB,IAAI,CAAE8I,CAAC,IAAK3E,GAAG,CAAC8T,QAAQ,CAACnP,CAAC,CAAC,CAAC,EAAE;MACzD,OAAO,IAAI,CAACid,SAAS,CAAC7gB,GAAG,CAACf,GAAG,EAAEmW,IAAI,EAAEhE,OAAO,CAAC;IAC/C;IACA,IAAIgE,IAAI,EAAED,SAAS,EAAE;MACnBC,IAAI,CAACD,SAAS,CAAClW,GAAG,EAAEmW,IAAI,CAACvC,UAAU,CAAC;IACtC;IAEA,IAAIsO,SAAS,GAAI,IAAI,CAACN,SAAS,CAAgB7S,GAAG,IAAI,EAAE;IACxD,IAAImT,SAAS,KAAK,EAAE,IAAI,EAAEA,SAAS,YAAY7G,GAAG,CAAC,IAAI,CAAC6G,SAAS,CAACpO,QAAQ,CAAC,GAAG,CAAC,EAAE;MAC/EoO,SAAS,IAAI,GAAG;IAClB;IAEA,MAAMC,OAAO,GAAGD,SAAS,GAAGliB,GAAG,CAAC7F,KAAK,CAAC,CAAC,CAAC;;IAExC;IACA,MAAM+Q,WAAW,GAAG,IAAI,CAAC5B,KAAK,CAACvI,GAAG,CAACohB,OAAO,CAAC;IAC3C,IAAIjX,WAAW,EAAE;MACf,OAAO,IAAI7gB,UAAU,CAAC6gB,WAAW,CAAC;IACpC;;IAEA;IACA,IAAI,IAAI,CAACuD,KAAK,IAAI0H,IAAI,EAAE;MACtB,OAAO,IAAI,CAAC1H,KAAK,CAAC2T,UAAU,CAC1BD,OAAO,EACPhM,IAAI,CAACvC,UAAU,EACf,MAAM,IAAI,CAACmO,WAAW,CAAC/hB,GAAG,EAAEmiB,OAAO,EAAEhM,IAAI,EAAEhE,OAAO,CAAC,EACnDgE,IAAI,CAACnC,UACP,CAAC;IACH,CAAC,MAAM;MACL;MACA,OAAO,IAAI,CAAC+N,WAAW,CAAC/hB,GAAG,EAAEmiB,OAAO,EAAEhM,IAAI,EAAEhE,OAAO,CAAC;IACtD;EACF;AACF;AAEA,iEAAepF,YAAY;;;;;;;;;;;;;;;AC/D3B;AACA;AACA;AACA;AACA;AACA;AACA;AACO,IAAWsS,iBAAiB,0BAAjBA,iBAAiB;EAAjBA,iBAAiB,CAAjBA,iBAAiB;EAAjBA,iBAAiB,CAAjBA,iBAAiB;EAAjBA,iBAAiB,CAAjBA,iBAAiB;EAAjBA,iBAAiB,CAAjBA,iBAAiB;EAAjBA,iBAAiB,CAAjBA,iBAAiB;EAAjBA,iBAAiB,CAAjBA,iBAAiB;EAAjBA,iBAAiB,CAAjBA,iBAAiB;EAAjBA,iBAAiB,CAAjBA,iBAAiB;EAAA,OAAjBA,iBAAiB;AAAA;;AA0CnC;;AAWA;;AA4BA;;;;;;;;;;;;;;;;;;;;;;AChG6E;AAW7E;AACO,SAASnS,qBAAqBA,CAAC6E,GAAe,EAAY;EAC/D,IAAIA,GAAG,CAAC5B,aAAa,EAAEtW,QAAQ,EAAE;IAC/B,OAAOkY,GAAG,CAAC5B,aAAa,CAACtW,QAAQ,CAAC3C,GAAG,CAAC,CAAC;MAAEmrB;IAAM,CAAC,EAAEpoB,GAAG,KAAKooB,KAAK,IAAI,WAAWpoB,GAAG,GAAG8X,GAAG,CAAC3B,aAAa,EAAE,CAAC;EAC1G;EACA,MAAMtgB,MAAM,GAAGiiB,GAAG,CAAC/B,WAAW,CAAC,CAAC,CAAC,CAACpd,KAAK,CAACmf,GAAG,CAAC9B,SAAS,CAAC,CAAC,CAAC,CAAC;EACzD,OAAOnW,KAAK,CAACC,IAAI,CAAC;IAAEjK;EAAO,CAAC,EAAE,CAAC6lB,CAAC,EAAE1b,GAAG,KAAK,WAAWA,GAAG,GAAG8X,GAAG,CAAC3B,aAAa,EAAE,CAAC;AACjF;;AAEA;AACO,MAAMpD,iBAAiB,GAAGA,CAAC,CAAC7H,CAAC,EAAE3G,CAAC,EAAEhS,CAAC,CAAgB,KAAK,CAAC,GAAGktB,MAAM,CAACvU,CAAC,GAAG,CAAC,CAAC,CAAC,GAAGuU,MAAM,CAAClb,CAAC,GAAG,CAAC,CAAC,CAAC,GAAGkb,MAAM,CAACltB,CAAC,GAAG,CAAC,CAAC,CAAC;AAE5G,SAAS8gB,gBAAgBA,CAAC4C,IAAe,EAAiB;EAC/D,MAAMD,SAAwB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACrD,MAAMqS,SAAS,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;EAE3CpS,IAAI,CAAC7U,OAAO,CAAC,CAACknB,IAAI,EAAEtoB,GAAG,KAAK;IAC1B,MAAMuoB,OAAO,GAAGF,SAAS,CAACnjB,OAAO,CAACojB,IAAI,CAACv4B,IAAI,CAAC;IAC5C,IAAIw4B,OAAO,GAAG,CAAC,CAAC,EAAE;MAChBvS,SAAS,CAACuS,OAAO,CAAC,GAAGvoB,GAAG;IAC1B,CAAC,MAAM;MACL,MAAM,IAAIsT,gEAAe,CAAC,8BAA8BgV,IAAI,CAACv4B,IAAI,EAAE,EAAE;QACnE2nB,IAAI,EAAEnE,oEAAmB,CAACoE;MAC5B,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;;EAEF;EACA,MAAM6Q,OAAO,GAAGxS,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;EACnC,IAAIwS,OAAO,IAAIxS,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;IAClC,MAAM,IAAI1C,gEAAe,CAAC,gBAAgBkV,OAAO,GAAG,MAAM,GAAG,KAAK,eAAe,EAAE;MACjF9Q,IAAI,EAAEnE,oEAAmB,CAACoE;IAC5B,CAAC,CAAC;EACJ;EAEA,OAAO3B,SAAS;AAClB;;AAEA;AACO,SAAS7C,gBAAgBA,CAAI6D,SAAmB,EAAEyR,UAAyB,EAAO;EACvF,MAAMC,OAAO,GAAG3V,iBAAiB,CAAC0V,UAAU,CAAC;EAC7C,MAAM5hB,MAAW,GAAGhH,KAAK,CAAC6oB,OAAO,CAAC;EAElCD,UAAU,CAACrnB,OAAO,CAAC,CAAC3O,GAAG,EAAEuN,GAAG,KAAK;IAC/B,IAAIvN,GAAG,IAAI,CAAC,EAAE;MACZ,IAAIA,GAAG,IAAIi2B,OAAO,EAAE;QAClB,MAAM,IAAIpV,gEAAe,CAAC,kCAAkC7gB,GAAG,EAAE,EAAE;UACjEilB,IAAI,EAAEnE,oEAAmB,CAACoE;QAC5B,CAAC,CAAC;MACJ;MACA9Q,MAAM,CAACpU,GAAG,CAAC,GAAGukB,SAAS,CAAChX,GAAG,CAAC;IAC9B;EACF,CAAC,CAAC;EAEF,OAAO6G,MAAM;AACf;;AAEA;AACO,SAASuM,YAAYA,CAAI8D,aAAkB,EAAEuR,UAAyB,EAAEtR,YAAe,EAAY;EACxG,MAAMtQ,MAAgB,GAAG,CAACsQ,YAAY,EAAEA,YAAY,EAAEA,YAAY,EAAEA,YAAY,EAAEA,YAAY,CAAC;EAE/FsR,UAAU,CAACrnB,OAAO,CAAC,CAAC3O,GAAG,EAAEuN,GAAG,KAAK;IAC/B,IAAIvN,GAAG,IAAI,CAAC,EAAE;MACZ,IAAIA,GAAG,IAAIykB,aAAa,CAACrhB,MAAM,EAAE;QAC/B,MAAM,IAAIyd,gEAAe,CAAC,kCAAkC7gB,GAAG,EAAE,EAAE;UACjEilB,IAAI,EAAEnE,oEAAmB,CAACoE;QAC5B,CAAC,CAAC;MACJ;MACA9Q,MAAM,CAAC7G,GAAG,CAAC,GAAGkX,aAAa,CAACzkB,GAAG,CAAC;IAClC;EACF,CAAC,CAAC;EAEF,OAAOoU,MAAM;AACf;;AAEA;AACO,SAASmM,QAAQA,CAAC2V,OAAmC,EAAEF,UAAyB,EAAiB;EACtG,MAAMG,UAAU,GAAGD,OAAO,CAACE,yBAAyB;EAEpD,IAAID,UAAU,KAAKjmB,SAAS,EAAE;IAC5BnP,OAAO,CAACC,IAAI,CAAC,wEAAwE,CAAC;IACtF,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACxB;;EAEA;EACA,MAAMq1B,gBAAgB,GAAI5d,CAA8B,IACtDA,CAAC,CAACwM,IAAI,KAAK,OAAO;;EAEpB;EACA;EACA,MAAMqR,cAAc,GAAGH,UAAU,CAACzF,IAAI,CAAC2F,gBAAgB,CAAC;EACxD,IAAI,CAACC,cAAc,EAAE;IACnBv1B,OAAO,CAACC,IAAI,CAAC,uFAAuF,CAAC;IACrG,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACxB;EAEA,MAAMyF,KAAK,GAAG6vB,cAAc,CAAC7vB,KAAK,CAACgH,KAAK,CAAC,CAAC;EAC1C,OAAOkT,YAAY,CAACla,KAAK,EAAEuvB,UAAU,EAAE,CAAC,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,oBAAoBA,CAC3BC,IAAsB,EACtBC,MAAqB,EACrBC,IAAsB,EACtBC,MAAqB,EACD;EACpB,MAAMC,EAAE,GAAGH,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGD,IAAI,CAACtwB,KAAK,CAACuwB,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;EACrD,MAAMI,EAAE,GAAGF,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGD,IAAI,CAACxwB,KAAK,CAACywB,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;EACrD,MAAMG,KAAK,GAAGF,EAAE,GAAGC,EAAE;EACrB,MAAME,KAAK,GAAGP,IAAI,CAACtwB,KAAK,CAACuwB,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGC,IAAI,CAACxwB,KAAK,CAACywB,MAAM,CAAC,CAAC,CAAC,CAAC;EAC3D,MAAMK,KAAK,GAAGR,IAAI,CAACtwB,KAAK,CAACuwB,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGC,IAAI,CAACxwB,KAAK,CAACywB,MAAM,CAAC,CAAC,CAAC,CAAC;EAE3D,IAAIG,KAAK,KAAK,CAAC,IAAIC,KAAK,KAAK,CAAC,IAAIC,KAAK,KAAK,CAAC,EAAE;IAC7C,OAAO,CAAC;EACV,CAAC,MAAM,IAAIF,KAAK,IAAI,CAAC,IAAIC,KAAK,IAAI,CAAC,IAAIC,KAAK,IAAI,CAAC,EAAE;IACjD,OAAO,CAAC,CAAC;EACX,CAAC,MAAM,IAAIF,KAAK,IAAI,CAAC,IAAIC,KAAK,IAAI,CAAC,IAAIC,KAAK,IAAI,CAAC,EAAE;IACjD,OAAO,CAAC;EACV,CAAC,MAAM;IACL,OAAO9mB,SAAS;EAClB;AACF;AAEA,MAAM9D,OAAO,GAAG,OAAO;AACvB,MAAM6qB,WAAW,GAAGA,CAACrvB,CAAS,EAAE1C,CAAS,KAAc7E,IAAI,CAACoM,GAAG,CAAC7E,CAAC,GAAG1C,CAAC,CAAC,GAAGkH,OAAO;AAEhF,SAAS8qB,uBAAuBA,CAACC,IAAgB,EAAEC,MAAc,EAAEC,IAAgB,EAAEC,MAAc,EAAW;EAC5G,MAAMC,MAAM,GAAGhX,QAAQ,CAAC4W,IAAI,CAAClU,kBAAkB,CAACE,QAAQ,CAACiU,MAAM,CAAC,EAAED,IAAI,CAAC5T,SAAS,CAAC;EACjF,MAAMiU,MAAM,GAAGjX,QAAQ,CAAC8W,IAAI,CAACpU,kBAAkB,CAACE,QAAQ,CAACmU,MAAM,CAAC,EAAED,IAAI,CAAC9T,SAAS,CAAC;EACjF,OAAO0T,WAAW,CAACM,MAAM,CAAC,CAAC,CAAC,EAAEC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAIP,WAAW,CAACM,MAAM,CAAC,CAAC,CAAC,EAAEC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAIP,WAAW,CAACM,MAAM,CAAC,CAAC,CAAC,EAAEC,MAAM,CAAC,CAAC,CAAC,CAAC;AACpH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS/W,sBAAsBA,CAACgB,OAAqB,EAAQ;EAClE,IAAIA,OAAO,CAACre,MAAM,GAAG,CAAC,EAAE;IACtB;EACF;;EAEA;EACA,MAAMq0B,aAAmC,GAAGrqB,KAAK,CAACC,IAAI,CAAC;IAAEjK,MAAM,EAAEqe,OAAO,CAACre;EAAO,CAAC,EAAE,MAAM,EAAE,CAAC;EAC5F,MAAMs0B,YAA4B,GAAGtqB,KAAK,CAACC,IAAI,CAAC;IAAEjK,MAAM,EAAEqe,OAAO,CAACre;EAAO,CAAC,EAAE,MAAM,EAAE,CAAC;;EAErF;EACA,MAAMu0B,YAAsB,GAAG,IAAIvqB,KAAK,CAACqU,OAAO,CAACre,MAAM,CAAC,CAACzE,IAAI,CAAC,CAAC,CAAC;EAChE,OAAOg5B,YAAY,CAAC1mB,KAAK,CAAC,CAACjR,GAAG,EAAEuN,GAAG,KAAKvN,GAAG,GAAGyhB,OAAO,CAAClU,GAAG,CAAC,CAAC+V,WAAW,CAAClgB,MAAM,CAAC,EAAE;IAC9E;IACA,IAAIkwB,QAAQ,GAAG,IAAI;IACnB,IAAIsE,WAAW,GAAG,CAAC;IACnB,IAAIC,WAAW,GAAGpW,OAAO,CAAC,CAAC,CAAC;IAC5B,IAAIqW,WAAW,GAAGD,WAAW,CAACvU,WAAW,CAACqU,YAAY,CAAC,CAAC,CAAC,CAAC;IAC1D,KAAK,IAAII,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGtW,OAAO,CAACre,MAAM,EAAE20B,UAAU,EAAE,EAAE;MAClE,MAAMC,UAAU,GAAGvW,OAAO,CAACsW,UAAU,CAAC;MACtC,MAAME,UAAU,GAAGD,UAAU,CAAC1U,WAAW,CAACqU,YAAY,CAACI,UAAU,CAAC,CAAC;MAEnE,MAAMG,QAAQ,GAAG3B,oBAAoB,CAACuB,WAAW,EAAED,WAAW,CAACtU,SAAS,EAAE0U,UAAU,EAAED,UAAU,CAACzU,SAAS,CAAC;MAC3G,IAAI,CAAC2U,QAAQ,EAAE;QACb;QACA,IAAIA,QAAQ,KAAKhoB,SAAS,EAAE;UAC1B,MAAM,IAAI2Q,gEAAe,CAAC,2DAA2D,EAAE;YACrFoE,IAAI,EAAEnE,oEAAmB,CAACqX;UAC5B,CAAC,CAAC;QACJ;;QAEA;QACA;QACA,IAAI,CAACjB,uBAAuB,CAACW,WAAW,EAAEF,YAAY,CAACC,WAAW,CAAC,EAAEI,UAAU,EAAEL,YAAY,CAACI,UAAU,CAAC,CAAC,EAAE;UAC1G;UACA;UACA;UACAh3B,OAAO,CAACC,IAAI,CAAC,2FAA2F,CAAC;QAC3G;;QAEA;QACA,MAAMo3B,QAAQ,GAAGP,WAAW,CAACtU,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGuU,WAAW,CAAC5xB,KAAK,CAAC2xB,WAAW,CAACtU,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QAChG,MAAM8U,QAAQ,GAAGL,UAAU,CAACzU,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG0U,UAAU,CAAC/xB,KAAK,CAAC8xB,UAAU,CAACzU,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QAC7F,IAAI6U,QAAQ,KAAKC,QAAQ,EAAE;UACzB;UACA;UACAt3B,OAAO,CAACC,IAAI,CAAC,6DAA6Do3B,QAAQ,OAAOC,QAAQ,EAAE,CAAC;QACtG;MACF,CAAC,MAAM;QACL/E,QAAQ,GAAG,KAAK;QAChB,IAAI4E,QAAQ,GAAG,CAAC,EAAE;UAChBN,WAAW,GAAGG,UAAU;UACxBF,WAAW,GAAGG,UAAU;UACxBF,WAAW,GAAGG,UAAU;QAC1B;MACF;IACF;IAEA,IAAI3E,QAAQ,EAAE;MACZ;MACA,KAAK,IAAIn0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGw4B,YAAY,CAACv0B,MAAM,EAAEjE,CAAC,EAAE,EAAE;QAC5C,MAAM64B,UAAU,GAAGvW,OAAO,CAACtiB,CAAC,CAAC;QAC7B,MAAMm5B,iBAAiB,GAAGX,YAAY,CAACx4B,CAAC,CAAC;QACzCs4B,aAAa,CAACt4B,CAAC,CAAC,CAAC+K,IAAI,CAAC8tB,UAAU,CAAC1U,WAAW,CAACgV,iBAAiB,CAAC,CAAC;QAChEZ,YAAY,CAACv4B,CAAC,CAAC,CAAC+K,IAAI,CAAC8tB,UAAU,CAAC/U,kBAAkB,CAACE,QAAQ,CAACmV,iBAAiB,CAAC,CAAC;QAC/EX,YAAY,CAACx4B,CAAC,CAAC,IAAI,CAAC;MACtB;IACF,CAAC,MAAM;MACL;MACA,KAAK,MAAM,CAACoO,GAAG,EAAEgrB,MAAM,CAAC,IAAIZ,YAAY,CAAC5kB,OAAO,CAAC,CAAC,EAAE;QAClD,MAAMilB,UAAU,GAAGvW,OAAO,CAAClU,GAAG,CAAC;QAC/B,MAAM0qB,UAAU,GAAGD,UAAU,CAAC1U,WAAW,CAACiV,MAAM,CAAC;QACjD,MAAML,QAAQ,GAAG3B,oBAAoB,CAACuB,WAAW,EAAED,WAAW,CAACtU,SAAS,EAAE0U,UAAU,EAAED,UAAU,CAACzU,SAAS,CAAC;QAC3G,IAAI2U,QAAQ,KAAK,CAAC,EAAE;UAClBP,YAAY,CAACpqB,GAAG,CAAC,IAAI,CAAC;QACxB;MACF;IACF;EACF;EAEA,IAAIkU,OAAO,CAAC,CAAC,CAAC,CAAC6B,WAAW,CAAClgB,MAAM,KAAK,CAAC,EAAE;IACvC,MAAM,IAAIyd,gEAAe,CAAC,qFAAqF,EAAE;MAC/GoE,IAAI,EAAEnE,oEAAmB,CAACqX;IAC5B,CAAC,CAAC;EACJ;EAEA,KAAK,IAAIh5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsiB,OAAO,CAACre,MAAM,EAAEjE,CAAC,EAAE,EAAE;IACvCsiB,OAAO,CAACtiB,CAAC,CAAC,CAACmkB,WAAW,GAAGmU,aAAa,CAACt4B,CAAC,CAAC;IACzCsiB,OAAO,CAACtiB,CAAC,CAAC,CAAC8jB,kBAAkB,CAACE,QAAQ,GAAGuU,YAAY,CAACv4B,CAAC,CAAC;EAC1D;AACF;;;;;;;;;;;;;;;;ACxP6E;AAG7E,SAASq5B,gBAAgBA,CAAmBnG,GAAY,EAAEoG,IAAO,EAA6B;EAC5F,OAAO,OAAOpG,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,IAAIoG,IAAI,IAAIpG,GAAG;AAC/D;AAEA,SAASqG,qBAAqBA,CAC5BrG,GAAY,EACZoG,IAAO,EACPn7B,IAAI,GAAG,MAAM,EACsB;EACnC,IAAI,CAACk7B,gBAAgB,CAACnG,GAAG,EAAEoG,IAAI,CAAC,EAAE;IAChC,MAAM,IAAI5X,gEAAe,CAAC,GAAGvjB,IAAI,wCAAwCm7B,IAAI,GAAG,EAAE;MAChFxT,IAAI,EAAEnE,oEAAmB,CAACoE;IAC5B,CAAC,CAAC;EACJ;AACF;AAEA,SAASyT,iBAAiBA,CACxBtG,GAAuB,EACvBoG,IAAO,EACPn7B,IAAI,GAAG,MAAM,EACwB;EACrC,IAAI,CAAC8P,KAAK,CAACyP,OAAO,CAACwV,GAAG,CAACoG,IAAI,CAAC,CAAC,EAAE;IAC7B,MAAM,IAAI5X,gEAAe,CAAC,GAAGvjB,IAAI,oBAAoBm7B,IAAI,mBAAmB,EAAE;MAC5ExT,IAAI,EAAEnE,oEAAmB,CAACoE;IAC5B,CAAC,CAAC;EACJ;AACF;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASlE,uBAAuBA,CACrCtjB,IAAa,EACbk7B,aAAa,GAAG,CAAC,EACjBt7B,IAAI,GAAG,MAAM,EACoB;EACjC;EACAo7B,qBAAqB,CAACh7B,IAAI,EAAE,aAAa,EAAEJ,IAAI,CAAC;EAChDq7B,iBAAiB,CAACj7B,IAAI,EAAE,aAAa,EAAEJ,IAAI,CAAC;;EAE5C;EACA,MAAMu7B,cAAc,GAAGn7B,IAAI,CAACqlB,WAAW,CAAC6V,aAAa,CAAC;EACtD,IAAI,CAACC,cAAc,EAAE;IACnB,MAAM,IAAIhY,gEAAe,CAAC,GAAGvjB,IAAI,sDAAsDs7B,aAAa,EAAE,EAAE;MACtG3T,IAAI,EAAEnE,oEAAmB,CAACoE;IAC5B,CAAC,CAAC;EACJ;EAEA,MAAM4T,kBAAkB,GAAGN,gBAAgB,CAACK,cAAc,EAAE,MAAM,CAAC,GAAG,MAAMA,cAAc,CAACv7B,IAAI,GAAG,GAAG,EAAE;EACvG,MAAMy7B,cAAc,GAAG,GAAGz7B,IAAI,eAAes7B,aAAa,GAAGE,kBAAkB,EAAE;;EAEjF;EACAJ,qBAAqB,CAACG,cAAc,EAAE,MAAM,EAAEE,cAAc,CAAC;EAC7DJ,iBAAiB,CAACE,cAAc,EAAE,MAAM,EAAEE,cAAc,CAAC;EACzDF,cAAc,CAACrV,IAAI,CAAC7U,OAAO,CAAC,CAACknB,IAAI,EAAE12B,CAAC,KAAKu5B,qBAAqB,CAAC7C,IAAI,EAAE,MAAM,EAAE,GAAGkD,cAAc,SAAS55B,CAAC,EAAE,CAAC,CAAC;;EAE5G;EACAu5B,qBAAqB,CAACG,cAAc,EAAE,UAAU,EAAEv7B,IAAI,CAAC;EACvDq7B,iBAAiB,CAACE,cAAc,EAAE,UAAU,EAAEv7B,IAAI,CAAC;EACnDu7B,cAAc,CAAC1V,QAAQ,CAACxU,OAAO,CAAC,CAACjR,IAAI,EAAEyB,CAAC,KAAKu5B,qBAAqB,CAACh7B,IAAI,EAAE,MAAM,EAAE,GAAGq7B,cAAc,YAAY55B,CAAC,EAAE,CAAC,CAAC;AACrH;;;;;;;;;;;;;;;;;;;;;;;AC1DA;AACA;;AAkCO,MAAMhC,kBAAkB,GAAG;EAChCkvB,IAAI,EAAE2M,SAAS;EACf1M,KAAK,EAAE2M,UAAU;EACjB1M,KAAK,EAAE2M,UAAU;EACjBC,KAAK,EAAEC,UAAU,CAACC,aAAa;EAC/BnN,KAAK,EAAEvuB,UAAU;EACjBwuB,MAAM,EAAEmN,WAAW;EACnBlN,MAAM,EAAEppB,WAAW;EACnBu2B,MAAM,EAAEH,UAAU,CAACI,cAAc;EACjCC,OAAO,EAAErY,YAAY;EACrBsY,OAAO,EAAEC;AACX,CAAC;AASD;AACO,MAAMC,uBAAuB,GAAG,CAAC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAYO,IAAKC,UAAU,0BAAVA,UAAU;EAAVA,UAAU,CAAVA,UAAU;EAAVA,UAAU,CAAVA,UAAU;EAAVA,UAAU,CAAVA,UAAU;EAAA,OAAVA,UAAU;AAAA;;AAMtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAmBO,MAAMC,oBAAoB,GAAIC,GAAW,IAC9CA,GAAG,IAAKA,GAAG,CAAwBD,oBAAoB;AAElD,MAAME,mBAAmB,GAAID,GAAW,IAC7CA,GAAG,IAAKA,GAAG,CAAuBC,mBAAmB;AAEhD,IAAWC,cAAc,0BAAdA,cAAc;EAAdA,cAAc;EAAdA,cAAc;EAAdA,cAAc;EAAdA,cAAc;EAAA,OAAdA,cAAc;AAAA;AAMzB,MAAMC,KAAK,GAAIC,MAAsB,IAC1CA,MAAM,KAAKF,cAAc,CAACG,QAAQ,IAAID,MAAM,KAAKF,cAAc,CAACI,SAAS;AACpE,MAAMC,OAAO,GAAIH,MAAsB,IAC5CA,MAAM,KAAKF,cAAc,CAACI,SAAS,IAAIF,MAAM,KAAKF,cAAc,CAACM,YAAY;AAExE,MAAMC,eAAiC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;;;;;;;;;;;;;;;;ACzJzD;;AAMO,MAAMC,6BAA6B,GAAG,mBAAmB;;AAEhE;AACA;AACA;;AAgBA;AACA;AACA;AACA;AACA;AACe,MAAMC,YAAY,CAAC;EAChC;AACF;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;;EAGE;;EAGA;;EAGA;;EAGA;;EAGA;AACF;AACA;AACA;AACA;AACA;EACEr9B,WAAWA,CAACs9B,iBAAiB,GAAG,EAAE,EAAEC,sBAAsB,GAAG,CAAC,EAAE;IAC9D,IAAI,CAACC,WAAW,GAAG,IAAI7nB,GAAG,CAAC,CAAC;IAC5B,IAAI,CAAC8nB,cAAc,GAAG,IAAI9hB,GAAG,CAAC,CAAC;IAC/B,IAAI,CAAC+I,KAAK,GAAG,EAAE;IACf,IAAI,CAACgZ,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACJ,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACC,sBAAsB,GAAGv6B,IAAI,CAACd,GAAG,CAACo7B,iBAAiB,EAAEC,sBAAsB,CAAC;EACnF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACUI,eAAeA,CAAI1nB,GAAW,EAAE2nB,aAA+B,EAAkB;IACvF;IACA;IACA;IACA,IAAIC,cAAc,EAAEC,aAAa;IACjC,MAAMC,OAAO,GAAG,IAAI3b,OAAO,CAAI,CAAC4D,OAAO,EAAEgL,MAAM,KAAK;MAClD6M,cAAc,GAAG7X,OAAO;MACxB8X,aAAa,GAAG9M,MAAM;IACxB,CAAC,CAAC;IACF;IACA,MAAMgN,WAAW,GAAG;MAClB/nB,GAAG,EAAEA,GAAG;MACRgoB,MAAM,EAAEL,aAAa;MACrB5X,OAAO,EAAE6X,cAAc;MACvB7M,MAAM,EAAE8M,aAAa;MACrBC;IACF,CAAC;IACD,IAAI,CAACP,WAAW,CAAC37B,GAAG,CAACoU,GAAG,EAAE+nB,WAAW,CAAC;IACtC,OAAOA,WAAW;EACpB;;EAEA;AACF;AACA;AACA;AACA;EACUE,iBAAiBA,CAACjoB,GAAW,EAAEkoB,WAAqB,EAAQ;IAClE;IACA,IAAI,IAAI,CAACX,WAAW,CAACrhB,GAAG,CAAClG,GAAG,CAAC,EAAE;MAC7B;MACA,MAAM+nB,WAAW,GAAG,IAAI,CAACR,WAAW,CAACxmB,GAAG,CAACf,GAAG,CAAC;MAC7C,IAAI+nB,WAAW,IAAIA,WAAW,CAACI,SAAS,EAAE;QACxCC,YAAY,CAACL,WAAW,CAACI,SAAS,CAAC;QACnCJ,WAAW,CAACI,SAAS,GAAGvrB,SAAS;MACnC;MACA,IAAI,CAAC,IAAI,CAAC6R,KAAK,CAAC3S,QAAQ,CAACkE,GAAG,CAAC,IAAI,CAAC,IAAI,CAACynB,gBAAgB,CAAC3rB,QAAQ,CAACkE,GAAG,CAAC,EAAE;QACrE;QACA,IAAIkoB,WAAW,EAAE;UACf,IAAI,CAACT,gBAAgB,CAAC7wB,IAAI,CAACoJ,GAAG,CAAC;QACjC,CAAC,MAAM;UACL,IAAI,CAACyO,KAAK,CAAC7X,IAAI,CAACoJ,GAAG,CAAC;QACtB;QACA,IAAI,CAACqoB,OAAO,CAAC,CAAC;MAChB;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACSjG,UAAUA,CAAIpiB,GAAW,EAAE2nB,aAA+B,EAAEO,WAAW,GAAG,KAAK,EAAEI,OAAO,GAAG,CAAC,EAAc;IAC/G,IAAI,CAAC,IAAI,CAACf,WAAW,CAACrhB,GAAG,CAAClG,GAAG,CAAC,EAAE;MAC9B;MACA,MAAM+nB,WAAW,GAAG,IAAI,CAACL,eAAe,CAAC1nB,GAAG,EAAE2nB,aAAa,CAAC;MAC5D;MACA,IAAIW,OAAO,GAAG,CAAC,EAAE;QACf,MAAMH,SAAS,GAAGI,UAAU,CAAC,MAAM,IAAI,CAACN,iBAAiB,CAACjoB,GAAG,EAAEkoB,WAAW,CAAC,EAAEI,OAAO,CAAC;QACrF;QACAP,WAAW,CAACI,SAAS,GAAGA,SAAS;MACnC,CAAC,MAAM;QACL;QACA,IAAI,CAACF,iBAAiB,CAACjoB,GAAG,EAAEkoB,WAAW,CAAC;MAC1C;IACF,CAAC,MAAM;MACL,MAAMM,gBAAgB,GAAG,IAAI,CAACf,gBAAgB,CAACtoB,OAAO,CAACa,GAAG,CAAC;MAC3D,IAAIwoB,gBAAgB,GAAG,CAAC,CAAC,IAAI,CAACN,WAAW,EAAE;QACzC;QACA;QACA,IAAI,CAACT,gBAAgB,CAACroB,MAAM,CAACopB,gBAAgB,EAAE,CAAC,CAAC;QACjD,IAAI,CAACP,iBAAiB,CAACjoB,GAAG,CAAC;MAC7B,CAAC,MAAM,IAAIsoB,OAAO,IAAI,CAAC,EAAE;QACvB;QACA;QACA,IAAI,CAACL,iBAAiB,CAACjoB,GAAG,EAAEkoB,WAAW,CAAC;MAC1C;IACF;IAEA,MAAMJ,OAAO,GAAG,IAAI,CAACP,WAAW,CAACxmB,GAAG,CAACf,GAAG,CAAC,EAAE8nB,OAAO;IAClD,IAAI,CAACA,OAAO,EAAE;MACZ,MAAM,IAAIjR,KAAK,CAAC,8DAA8D,CAAC;IACjF;IACA,OAAOiR,OAAO;EAChB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACSW,WAAWA,CAAIC,QAAsB,EAAER,WAAW,GAAG,KAAK,EAAEI,OAAO,GAAG,EAAE,EAAsB;IACnG,MAAMK,QAA4B,GAAG,EAAE;IACvC,KAAK,IAAI98B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG68B,QAAQ,CAAC54B,MAAM,EAAEjE,CAAC,EAAE,EAAE;MACxC,MAAMkG,IAAI,GAAG22B,QAAQ,CAAC78B,CAAC,CAAC;MACxB,MAAMi8B,OAAO,GAAG,IAAI,CAAC1F,UAAU,CAACrwB,IAAI,CAACiO,GAAG,EAAEjO,IAAI,CAAC41B,aAAa,EAAEO,WAAW,EAAEI,OAAO,GAAGz8B,CAAC,CAAC;MACvF88B,QAAQ,CAAC/xB,IAAI,CAACkxB,OAAO,CAAC;IACxB;IACA,OAAOa,QAAQ;EACjB;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAcN,OAAOA,CAAA,EAAkB;IACrC,MAAMO,WAAW,GAAG,IAAI,CAACpB,cAAc,CAAC1qB,IAAI;IAC5C,IACE8rB,WAAW,IAAI,IAAI,CAACvB,iBAAiB,IACpC,IAAI,CAAC5Y,KAAK,CAAC3e,MAAM,KAAK,CAAC,KAAK84B,WAAW,IAAI,IAAI,CAACtB,sBAAsB,IAAI,IAAI,CAACG,gBAAgB,CAAC33B,MAAM,KAAK,CAAC,CAAE,EAC/G;MACA;IACF;IAEA,MAAM+4B,UAAU,GAAG,IAAI,CAACpa,KAAK,CAACqa,KAAK,CAAC,CAAC,IAAI,IAAI,CAACrB,gBAAgB,CAACqB,KAAK,CAAC,CAAC;IACtE,IAAI,CAACD,UAAU,EAAE;MACf;IACF;IACA,IAAI,IAAI,CAACrB,cAAc,CAACthB,GAAG,CAAC2iB,UAAU,CAAC,EAAE;MACvC;MACA,IAAI,CAACR,OAAO,CAAC,CAAC;MACd;IACF;IAEA,MAAMN,WAAW,GAAG,IAAI,CAACR,WAAW,CAACxmB,GAAG,CAAC8nB,UAAU,CAAC;IACpD,IAAI,CAACd,WAAW,EAAE;MAChB;IACF;IAEA,MAAM/nB,GAAG,GAAG+nB,WAAW,CAAC/nB,GAAG;IAC3B;IACA,IAAI,CAACwnB,cAAc,CAACnqB,GAAG,CAAC2C,GAAG,CAAC;IAE5B,MAAM+nB,WAAW,CAACC,MAAM,CAAC,CAAC,CAACe,IAAI,CAAChB,WAAW,CAAChY,OAAO,EAAEgY,WAAW,CAAChN,MAAM,CAAC;IACxE,IAAI,CAACyM,cAAc,CAACznB,MAAM,CAACC,GAAG,CAAC;IAC/B,IAAI,CAACunB,WAAW,CAACxnB,MAAM,CAACC,GAAG,CAAC;IAC5B,IAAI,CAACqoB,OAAO,CAAC,CAAC;EAChB;;EAEA;AACF;AACA;AACA;AACA;EACSW,aAAaA,CAAChpB,GAAW,EAAEipB,YAAqB,GAAG9B,6BAA6B,EAAQ;IAC7F,IAAI,CAAC,IAAI,CAACI,WAAW,CAACrhB,GAAG,CAAClG,GAAG,CAAC,EAAE;MAC9B;IACF;IACA,MAAM+nB,WAAW,GAAG,IAAI,CAACR,WAAW,CAACxmB,GAAG,CAACf,GAAG,CAAC;IAC7C,IAAI+nB,WAAW,EAAE;MACf,IAAIA,WAAW,CAACI,SAAS,EAAE;QACzB;QACAC,YAAY,CAACL,WAAW,CAACI,SAAS,CAAC;MACrC;MACA;MACAJ,WAAW,CAAChN,MAAM,CAACkO,YAAY,CAAC;IAClC;IACA,MAAMC,UAAU,GAAG,IAAI,CAACza,KAAK,CAACtP,OAAO,CAACa,GAAG,CAAC;IAC1C,IAAIkpB,UAAU,GAAG,CAAC,CAAC,EAAE;MACnB,IAAI,CAACza,KAAK,CAACrP,MAAM,CAAC8pB,UAAU,EAAE,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,MAAMV,gBAAgB,GAAG,IAAI,CAACf,gBAAgB,CAACtoB,OAAO,CAACa,GAAG,CAAC;MAC3D,IAAIwoB,gBAAgB,GAAG,CAAC,CAAC,EAAE;QACzB,IAAI,CAACf,gBAAgB,CAACroB,MAAM,CAACopB,gBAAgB,EAAE,CAAC,CAAC;MACnD;IACF;IACA,IAAI,CAACjB,WAAW,CAACxnB,MAAM,CAACC,GAAG,CAAC;IAC5B,IAAI,CAACwnB,cAAc,CAACznB,MAAM,CAACC,GAAG,CAAC;EACjC;;EAEA;AACF;AACA;AACA;EACSmpB,iBAAiBA,CAACF,YAAqB,GAAG9B,6BAA6B,EAAQ;IACpF;IACA,IAAI,CAAC1Y,KAAK,GAAG,EAAE;IACf,IAAI,CAACgZ,gBAAgB,GAAG,EAAE;IAC1B,KAAK,MAAMznB,GAAG,IAAI,IAAI,CAACunB,WAAW,CAACtjB,IAAI,CAAC,CAAC,EAAE;MACzC,IAAI,CAAC+kB,aAAa,CAAChpB,GAAG,EAAEipB,YAAY,CAAC;IACvC;EACF;;EAEA;AACF;AACA;AACA;AACA;EACSG,UAAUA,CAACppB,GAAW,EAAW;IACtC,OAAO,IAAI,CAACunB,WAAW,CAACrhB,GAAG,CAAClG,GAAG,CAAC;EAClC;;EAEA;AACF;AACA;AACA;AACA;EACSqpB,cAAcA,CAACrpB,GAAW,EAAW;IAC1C,OAAO,IAAI,CAACwnB,cAAc,CAACthB,GAAG,CAAClG,GAAG,CAAC;EACrC;AACF;;;;;;;;;;;;;;;;AC1S6C;;AAE7C;;AAUA;AACA;AACA;AACA;AACe,MAAMwM,wBAAwB,CAAC;EAG5C;;EAEA;AACF;AACA;AACA;;EAEE;;EAGA;AACF;AACA;AACA;;EAGEziB,WAAWA,CAACs9B,iBAAyC,EAAEC,sBAA+B,EAAE;IACtF,IAAI,OAAOD,iBAAiB,KAAK,QAAQ,IAAIA,iBAAiB,KAAKzqB,SAAS,EAAE;MAC5E,IAAI,CAAC6R,KAAK,GAAG,IAAI2Y,wDAAY,CAACC,iBAAiB,EAAEC,sBAAsB,CAAC;IAC1E,CAAC,MAAM;MACL,IAAI,CAAC7Y,KAAK,GAAG4Y,iBAAiB;IAChC;IACA,IAAI,CAACiC,gBAAgB,GAAG,CAAC;IACzB,IAAI,CAACC,WAAW,GAAG,IAAI7pB,GAAG,CAAC,CAAC;IAC5B,IAAI,CAACgpB,QAAQ,GAAG,IAAIhpB,GAAG,CAAC,CAAC;EAC3B;;EAEA;EACQ8pB,UAAUA,CAAIxpB,GAAW,EAAE1P,KAAQ,EAAQ;IACjD,MAAMo4B,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC3nB,GAAG,CAACf,GAAG,CAAC;IACvC,IAAI0oB,QAAQ,EAAE;MACZ,KAAK,MAAM;QAAE3Y,OAAO;QAAE0Z;MAAa,CAAC,IAAIf,QAAQ,EAAE;QAChD3Y,OAAO,CAACzf,KAAK,CAAC;QACd,IAAI,CAACi5B,WAAW,CAACxoB,GAAG,CAAC0oB,YAAY,CAAC,EAAE1pB,MAAM,CAACC,GAAG,CAAC;MACjD;MACA,IAAI,CAAC0oB,QAAQ,CAAC3oB,MAAM,CAACC,GAAG,CAAC;IAC3B;EACF;;EAEA;EACQ0pB,SAASA,CAAC1pB,GAAW,EAAE2pB,MAAe,EAAQ;IACpD,MAAMjB,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAC3nB,GAAG,CAACf,GAAG,CAAC;IACvC,IAAI0oB,QAAQ,EAAE;MACZ,KAAK,MAAM;QAAE3N,MAAM;QAAE0O;MAAa,CAAC,IAAIf,QAAQ,EAAE;QAC/C3N,MAAM,CAAC4O,MAAM,CAAC;QACd,IAAI,CAACJ,WAAW,CAACxoB,GAAG,CAAC0oB,YAAY,CAAC,EAAE1pB,MAAM,CAACC,GAAG,CAAC;MACjD;MACA,IAAI,CAAC0oB,QAAQ,CAAC3oB,MAAM,CAACC,GAAG,CAAC;IAC3B;EACF;;EAEA;EACAgV,aAAaA,CAAA,EAAW;IACtB,MAAMyU,YAAY,GAAG,IAAI,CAACH,gBAAgB;IAC1C,IAAI,CAACA,gBAAgB,EAAE;IACvB,IAAI,CAACC,WAAW,CAAC39B,GAAG,CAAC69B,YAAY,EAAE,IAAI/pB,GAAG,CAAC,CAAC,CAAC;IAC7C,OAAO+pB,YAAY;EACrB;;EAEA;AACF;AACA;AACA;AACA;EACErH,UAAUA,CACRpiB,GAAW,EACXypB,YAAoB,EACpB9B,aAA+B,EAC/BO,WAAqB,EACrBI,OAAgB,EACJ;IACZ;IACA,IAAI,CAAC7Z,KAAK,CACP2T,UAAU,CAACpiB,GAAG,EAAE2nB,aAAa,EAAEO,WAAW,EAAEI,OAAO,CAAC,CACpDS,IAAI,CAAEz4B,KAAK,IAAK,IAAI,CAACk5B,UAAU,CAACxpB,GAAG,EAAE1P,KAAK,CAAC,CAAC,CAC5C+e,KAAK,CAAEsa,MAAM,IAAK,IAAI,CAACD,SAAS,CAAC1pB,GAAG,EAAE2pB,MAAM,CAAC,CAAC;IAEjD,IAAI,CAAC,IAAI,CAACjB,QAAQ,CAACxiB,GAAG,CAAClG,GAAG,CAAC,EAAE;MAC3B,IAAI,CAAC0oB,QAAQ,CAAC98B,GAAG,CAACoU,GAAG,EAAE,EAAE,CAAC;IAC5B;;IAEA;IACA,IAAIypB,YAAY,IAAI,IAAI,CAACH,gBAAgB,IAAIG,YAAY,GAAG,CAAC,EAAE;MAC7D,MAAM,IAAI5S,KAAK,CAAC,2CAA2C4S,YAAY,0BAA0B,CAAC;IACpG;IACA,MAAM7V,UAAU,GAAG,IAAI,CAAC2V,WAAW,CAACxoB,GAAG,CAAC0oB,YAAY,CAAC;IACrD,IAAI,CAAC7V,UAAU,EAAE;MACf,MAAM,IAAIiD,KAAK,CAAC,2CAA2C4S,YAAY,mBAAmB,CAAC;IAC7F;;IAEA;IACA,OAAO,IAAItd,OAAO,CAAI,CAAC4D,OAAO,EAAEgL,MAAM,KAAK;MACzC,IAAI,CAAC2N,QAAQ,CAAC3nB,GAAG,CAACf,GAAG,CAAC,EAAEpJ,IAAI,CAAC;QAAEmZ,OAAO;QAAEgL,MAAM;QAAE0O;MAAa,CAAC,CAAC;MAC/D,MAAM7V,UAAU,GAAG,IAAI,CAAC2V,WAAW,CAACxoB,GAAG,CAAC0oB,YAAY,CAAC;MACrD,MAAMG,eAAe,GAAGhW,UAAU,EAAE7S,GAAG,CAACf,GAAG,CAAC;MAC5C,IAAI4pB,eAAe,EAAE;QACnBA,eAAe,CAAChzB,IAAI,CAACmkB,MAAM,CAAC;MAC9B,CAAC,MAAM;QACLnH,UAAU,EAAEhoB,GAAG,CAACoU,GAAG,EAAE,CAAC+a,MAAM,CAAC,CAAC;MAChC;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;EACU8O,kBAAkBA,CAAC7pB,GAAW,EAAE+a,MAAgB,EAAEkO,YAAsB,EAAQ;IACtF;IACAlO,MAAM,CAACkO,YAAY,CAAC;;IAEpB;IACA,MAAMa,aAAa,GAAG,IAAI,CAACpB,QAAQ,CAAC3nB,GAAG,CAACf,GAAG,CAAC;IAC5C,IAAI,CAAC8pB,aAAa,EAAE;MAClB;MACA;IACF;IACA;IACA,MAAM7vB,GAAG,GAAG6vB,aAAa,CAAChY,SAAS,CAAE+D,GAAG,IAAKA,GAAG,CAACkF,MAAM,KAAKA,MAAM,CAAC;IACnE,IAAI9gB,GAAG,IAAI,CAAC,EAAE;MACZ6vB,aAAa,CAAC1qB,MAAM,CAACnF,GAAG,EAAE,CAAC,CAAC;IAC9B;;IAEA;IACA,IAAI6vB,aAAa,CAACh6B,MAAM,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC2e,KAAK,CAAC4a,cAAc,CAACrpB,GAAG,CAAC,EAAE;MAC/D,IAAI,CAACyO,KAAK,CAACua,aAAa,CAAChpB,GAAG,EAAEipB,YAAY,CAAC;MAC3C,IAAI,CAACP,QAAQ,CAAC3oB,MAAM,CAACC,GAAG,CAAC;IAC3B;EACF;;EAEA;EACAgpB,aAAaA,CAAChpB,GAAW,EAAEypB,YAAoB,EAAER,YAAsB,EAAW;IAChF,MAAMrV,UAAU,GAAG,IAAI,CAAC2V,WAAW,CAACxoB,GAAG,CAAC0oB,YAAY,CAAC;IACrD,IAAI,CAAC7V,UAAU,EAAE;MACf,OAAO,KAAK;IACd;IAEA,MAAMmW,SAAS,GAAGnW,UAAU,CAAC7S,GAAG,CAACf,GAAG,CAAC;IACrC,IAAI,CAAC+pB,SAAS,IAAI,CAACA,SAAS,CAACj6B,MAAM,EAAE;MACnC,OAAO,KAAK;IACd;IAEA,KAAK,MAAMirB,MAAM,IAAIgP,SAAS,EAAE;MAC9B,IAAI,CAACF,kBAAkB,CAAC7pB,GAAG,EAAE+a,MAAM,EAAEkO,YAAY,CAAC;IACpD;IACArV,UAAU,CAAC7T,MAAM,CAACC,GAAG,CAAC;IACtB,OAAO,IAAI;EACb;;EAEA;EACAqV,gBAAgBA,CAACoU,YAAoB,EAAER,YAAsB,EAAQ;IACnE,MAAMa,aAAa,GAAG,IAAI,CAACP,WAAW,CAACxoB,GAAG,CAAC0oB,YAAY,CAAC;IACxD,IAAIK,aAAa,EAAE;MACjB,KAAK,MAAM,CAAC9pB,GAAG,EAAE+pB,SAAS,CAAC,IAAID,aAAa,CAACrqB,OAAO,CAAC,CAAC,EAAE;QACtD,KAAK,MAAMsb,MAAM,IAAIgP,SAAS,EAAE;UAC9B,IAAI,CAACF,kBAAkB,CAAC7pB,GAAG,EAAE+a,MAAM,EAAEkO,YAAY,CAAC;QACpD;MACF;MACA,IAAI,CAACM,WAAW,CAACxpB,MAAM,CAAC0pB,YAAY,CAAC;IACvC;EACF;;EAEA;EACAL,UAAUA,CAACppB,GAAW,EAAW;IAC/B,OAAO,IAAI,CAACyO,KAAK,CAAC2a,UAAU,CAACppB,GAAG,CAAC;EACnC;;EAEA;EACAqpB,cAAcA,CAACrpB,GAAW,EAAW;IACnC,OAAO,IAAI,CAACyO,KAAK,CAAC4a,cAAc,CAACrpB,GAAG,CAAC;EACvC;;EAEA;EACAgqB,aAAaA,CAACP,YAAoB,EAAW;IAC3C,OAAO,IAAI,CAACF,WAAW,CAACrjB,GAAG,CAACujB,YAAY,CAAC;EAC3C;;EAEA;EACAQ,YAAYA,CAACR,YAAoB,EAAEzpB,GAAW,EAAW;IACvD,OAAO,IAAI,CAACupB,WAAW,CAACxoB,GAAG,CAAC0oB,YAAY,CAAC,EAAEvjB,GAAG,CAAClG,GAAG,CAAC,IAAI,KAAK;EAC9D;AACF;;;;;;;;;;;;;;;;;;;;;;ACxM+D;AACb;AAE3C,MAAMkqB,gBAAgB,GAAG,CAAC;AAEjC,MAAMC,aAAa,GAAG,IAAI;AAC1B,MAAMC,aAAa,GAAGD,aAAa,GAAG,EAAE;AACxC,MAAME,WAAW,GAAGD,aAAa,GAAG,EAAE;AACtC,MAAME,UAAU,GAAGD,WAAW,GAAG,EAAE;;AAEnC;AACA,SAASE,wBAAwBA,CAACrK,CAAS,EAAU;EACnD,MAAMsK,KAAK,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC;EACrF,OAAOhmB,MAAM,CAACimB,YAAY,CAACD,KAAK,CAACtK,CAAC,CAAC,CAAC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwK,mBAAmBA,CAACC,KAAa,EAAEC,OAAO,GAAGV,gBAAgB,EAAU;EAC9E,MAAMW,aAAa,GAAGF,KAAK,CAACG,aAAa,CAACF,OAAO,GAAG,CAAC,CAAC;EACtD,MAAM,CAACG,WAAW,EAAEC,QAAQ,CAAC,GAAGH,aAAa,CAACtW,KAAK,CAAC,GAAG,CAAC;EACxD,MAAM0W,OAAO,GAAGD,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,GAAG,GAAG,EAAE;EAC9C,MAAME,SAAS,GAAGF,QAAQ,CAAC7wB,KAAK,CAAC,CAAC,CAAC,CAACoa,KAAK,CAAC,EAAE,CAAC;EAC7C,MAAM4W,cAAc,GAAGD,SAAS,CAACh0B,GAAG,CAAEk0B,KAAK,IAAKb,wBAAwB,CAAC7Q,MAAM,CAAC0R,KAAK,CAAC,CAAC,CAAC,CAACrX,IAAI,CAAC,EAAE,CAAC;EACjG,OAAO,GAAGgX,WAAW,MAAME,OAAO,GAAGE,cAAc,EAAE;AACvD;;AAEA;AACA;AACA;AACA;AACA,SAASE,SAASA,CAAC/6B,KAAa,EAAEs6B,OAAe,EAAU;EACzD,MAAMI,QAAQ,GAAGj+B,IAAI,CAACC,KAAK,CAACD,IAAI,CAACkQ,KAAK,CAAClQ,IAAI,CAACoM,GAAG,CAAC7I,KAAK,CAAC,CAAC,CAAC;EACxD,OAAOA,KAAK,CAACg7B,OAAO,CAACv+B,IAAI,CAACb,GAAG,CAAC0+B,OAAO,GAAGI,QAAQ,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3D;;AAEA;AACA;AACA,SAASO,YAAYA,CAACC,GAAW,EAAEC,IAAY,EAAU;EACvD,IAAI5/B,CAAC,GAAG2/B,GAAG,CAAC17B,MAAM,GAAG,CAAC;EACtB,OAAO07B,GAAG,CAAC3/B,CAAC,CAAC,KAAK4/B,IAAI,EAAE;IACtB5/B,CAAC,EAAE;EACL;EACA,OAAO2/B,GAAG,CAACrxB,KAAK,CAAC,CAAC,EAAEtO,CAAC,GAAG,CAAC,CAAC;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS6/B,YAAYA,CAACp7B,KAAa,EAAEs6B,OAAO,GAAGV,gBAAgB,EAAEyB,UAAU,GAAGf,OAAO,GAAG,CAAC,EAAU;EACxG,MAAMgB,QAAQ,GAAG7+B,IAAI,CAACoM,GAAG,CAAC7I,KAAK,CAAC;EAEhC,IAAIopB,MAAM,CAACmS,SAAS,CAACv7B,KAAK,CAAC,EAAE;IAC3B;IACA,IAAIs7B,QAAQ,IAAI,MAAM,EAAE;MACtB,OAAOlB,mBAAmB,CAACp6B,KAAK,EAAEq7B,UAAU,CAAC;IAC/C;IACA;IACA,OAAOr7B,KAAK,CAACw7B,QAAQ,CAAC,CAAC;EACzB,CAAC,MAAM;IACL,MAAMC,MAAM,GAAGV,SAAS,CAAC/6B,KAAK,EAAEs6B,OAAO,CAAC;IACxC,MAAMoB,UAAU,GAAGj/B,IAAI,CAACoM,GAAG,CAACugB,MAAM,CAACqS,MAAM,CAAC,CAAC;IAC3C,IAAIC,UAAU,IAAI,MAAM,IAAIA,UAAU,GAAG,IAAI,EAAE;MAC7C,OAAOtB,mBAAmB,CAACp6B,KAAK,EAAEq7B,UAAU,CAAC;IAC/C;IACA,MAAMM,OAAO,GAAGV,YAAY,CAACQ,MAAM,EAAE,GAAG,CAAC;IACzC,OAAOE,OAAO,CAACnY,QAAQ,CAAC,GAAG,CAAC,GAAGmY,OAAO,CAAC9xB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG8xB,OAAO;EAC/D;AACF;AAEA,MAAMC,0BAA0B,GAAG;EACjC,CAAC3mB,wDAAQ,CAACE,WAAW,GAAG,CAAC;EACzB,CAACF,wDAAQ,CAACI,MAAM,GAAGwkB,aAAa;EAChC,CAAC5kB,wDAAQ,CAACK,MAAM,GAAGwkB,aAAa;EAChC,CAAC7kB,wDAAQ,CAACM,IAAI,GAAGwkB,WAAW;EAC5B,CAAC9kB,wDAAQ,CAACO,GAAG,GAAGwkB;AAClB,CAAC;AAEM,SAAS6B,kBAAkBA,CAACxwB,IAAY,EAAEqK,IAAc,EAAU;EACvE,MAAMomB,kBAAkB,GAAGF,0BAA0B,CAAClmB,IAAI,CAAC;EAC3D,IAAIomB,kBAAkB,KAAKxvB,SAAS,EAAE;IACpC,MAAM,IAAIia,KAAK,CAAC,wBAAwB,CAAC;EAC3C;EACA,OAAOlb,IAAI,GAAGywB,kBAAkB;AAClC;;AAEA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAAC/7B,KAAa,EAAER,MAAc,EAAEw8B,SAAkB,EAAU;EACnF,OAAOA,SAAS,GAAGh8B,KAAK,CAACw7B,QAAQ,CAAC,CAAC,CAACS,QAAQ,CAACz8B,MAAM,EAAE,GAAG,CAAC,GAAGQ,KAAK,CAACw7B,QAAQ,CAAC,CAAC;AAC9E;AAEA,SAASU,eAAeA,CACtBC,MAAc,EACdta,OAMC,EACqC;EACtC,MAAM;IAAEua,KAAK;IAAEC,MAAM;IAAEC,MAAM;IAAEC,QAAQ;IAAEC;EAAQ,CAAC,GAAG3a,OAAO;EAC5D,MAAM4a,MAAgB,GAAG,EAAE;EAC3B,MAAMC,KAAe,GAAG,EAAE;EAE1B,IAAIF,OAAO,EAAE;IACX,MAAMG,IAAI,GAAGlgC,IAAI,CAACC,KAAK,CAACy/B,MAAM,GAAGnC,UAAU,CAAC;IAC5CyC,MAAM,CAACn2B,IAAI,CAACq2B,IAAI,CAACnB,QAAQ,CAAC,CAAC,CAAC;IAC5BkB,KAAK,CAACp2B,IAAI,CAAC,GAAG,CAAC;EACjB;EACA,IAAIi2B,QAAQ,EAAE;IACZ,MAAMK,KAAK,GAAGngC,IAAI,CAACC,KAAK,CAAEy/B,MAAM,GAAGnC,UAAU,GAAID,WAAW,CAAC;IAC7D;IACA;IACA0C,MAAM,CAACn2B,IAAI,CAACy1B,gBAAgB,CAACa,KAAK,EAAE,CAAC,EAAEJ,OAAO,CAAC,CAAC;IAChDE,KAAK,CAACp2B,IAAI,CAAC,GAAG,CAAC;EACjB;EACA,IAAIg2B,MAAM,EAAE;IACV,MAAMO,OAAO,GAAGpgC,IAAI,CAACC,KAAK,CAAEy/B,MAAM,GAAGpC,WAAW,GAAID,aAAa,CAAC;IAClE2C,MAAM,CAACn2B,IAAI,CAACy1B,gBAAgB,CAACc,OAAO,EAAE,CAAC,EAAEN,QAAQ,CAAC,CAAC;IACnDG,KAAK,CAACp2B,IAAI,CAAC,GAAG,CAAC;EACjB;EACA,IAAI+1B,MAAM,EAAE;IACV,MAAMS,OAAO,GAAGrgC,IAAI,CAACC,KAAK,CAAEy/B,MAAM,GAAGrC,aAAa,GAAID,aAAa,CAAC;IACpE,IAAIkD,YAAY,GAAGhB,gBAAgB,CAACe,OAAO,EAAE,CAAC,EAAER,MAAM,CAAC;IACvDI,KAAK,CAACp2B,IAAI,CAAC,GAAG,CAAC;IACf;IACA,IAAI81B,KAAK,EAAE;MACT,MAAMY,YAAY,GAAGvgC,IAAI,CAACC,KAAK,CAACy/B,MAAM,GAAGtC,aAAa,CAAC;MACvDkD,YAAY,IAAI,GAAG,GAAGC,YAAY,CAACxB,QAAQ,CAAC,CAAC,CAACS,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MAC9D;MACA;IACF;IACAQ,MAAM,CAACn2B,IAAI,CAACy2B,YAAY,CAAC;EAC3B,CAAC,MAAM,IAAIX,KAAK,EAAE;IAChB,MAAMY,YAAY,GAAGvgC,IAAI,CAACC,KAAK,CAACy/B,MAAM,GAAGtC,aAAa,CAAC;IACvD4C,MAAM,CAACn2B,IAAI,CAAC02B,YAAY,CAACxB,QAAQ,CAAC,CAAC,CAAC;IACpCkB,KAAK,CAACp2B,IAAI,CAAC,IAAI,CAAC;EAClB;EACA,OAAO;IAAE22B,SAAS,EAAER,MAAM,CAAChZ,IAAI,CAAC,GAAG,CAAC;IAAEiZ,KAAK,EAAEA,KAAK,CAACjZ,IAAI,CAAC,GAAG;EAAE,CAAC;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASyZ,YAAYA,CAAC7xB,IAAY,EAAE8xB,KAAa,EAAEznB,IAAY,EAAU;EAC9E,MAAMjT,QAAQ,GAAGgT,iEAAa,CAACC,IAAI,CAAC;EAEpC,IAAIjT,QAAQ,KAAK6J,SAAS,EAAE;IAC1B,OAAO,GAAG8uB,YAAY,CAAC/vB,IAAI,CAAC,MAAM+vB,YAAY,CAAC+B,KAAK,CAAC,IAAIznB,IAAI,EAAE;EACjE;EAEA,MAAMymB,MAAM,GAAGN,kBAAkB,CAACxwB,IAAI,EAAE5I,QAAQ,CAAC;EACjD,MAAM26B,OAAO,GAAGvB,kBAAkB,CAACsB,KAAK,EAAE16B,QAAQ,CAAC;;EAEnD;EACA;EACA,MAAMof,OAAO,GAAG;IACdua,KAAK,EAAE35B,QAAQ,IAAIwS,wDAAQ,CAACE,WAAW;IACvCknB,MAAM,EAAE55B,QAAQ,IAAIwS,wDAAQ,CAACI,MAAM,IAAK5S,QAAQ,IAAIwS,wDAAQ,CAACI,MAAM,IAAI+nB,OAAO,IAAIvD,aAAc;IAChGyC,MAAM,EAAE75B,QAAQ,IAAIwS,wDAAQ,CAACK,MAAM,IAAK7S,QAAQ,IAAIwS,wDAAQ,CAACK,MAAM,IAAI8nB,OAAO,IAAItD,aAAc;IAChGyC,QAAQ,EAAE95B,QAAQ,IAAIwS,wDAAQ,CAACM,IAAI,IAAK9S,QAAQ,IAAIwS,wDAAQ,CAACM,IAAI,IAAI6nB,OAAO,IAAIrD,WAAY;IAC5FyC,OAAO,EAAE/5B,QAAQ,IAAIwS,wDAAQ,CAACO,GAAG,IAAK/S,QAAQ,IAAIwS,wDAAQ,CAACO,GAAG,IAAI4nB,OAAO,IAAIpD;EAC/E,CAAC;EAED,MAAM;IAAEiD,SAAS;IAAEP;EAAM,CAAC,GAAGR,eAAe,CAACC,MAAM,EAAEta,OAAO,CAAC;EAC7D,MAAM;IAAEob,SAAS,EAAEI;EAAe,CAAC,GAAGnB,eAAe,CAACkB,OAAO,EAAEvb,OAAO,CAAC;EAEvE,OAAO,GAAGob,SAAS,MAAMI,cAAc,IAAIX,KAAK,EAAE;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASY,eAAeA,CAC7B7b,GAA6B,EAC7B8b,MAAgC,EAChCtL,IAAU,EACgB;EAC1B,QAAQA,IAAI;IACV,KAAK/gB,0DAAI,CAACssB,CAAC;MACT,OAAO,CAAC/b,GAAG,CAAC,CAAC,CAAC,EAAE8b,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;IACvC,KAAKrsB,0DAAI,CAACusB,CAAC;MACT,OAAO,CAACF,MAAM,CAAC,CAAC,CAAC,EAAE9b,GAAG,CAAC,CAAC,CAAC,EAAE8b,MAAM,CAAC,CAAC,CAAC,CAAC;IACvC,KAAKrsB,0DAAI,CAACwsB,CAAC;MACT,OAAO,CAACH,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EAAE9b,GAAG,CAAC,CAAC,CAAC,CAAC;IACvC;MACE,OAAO,CAAC,GAAGA,GAAG,CAAC;EACnB;AACF;AAEO,SAASpK,YAAYA,CAACvd,IAAuB,EAAoB;EACtE,IAAI6B,GAAG,GAAG7B,IAAI,CAAC,CAAC,CAAC;EACjB,IAAI8B,GAAG,GAAG9B,IAAI,CAAC,CAAC,CAAC;EACjB,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,IAAI,CAAC0F,MAAM,EAAEjE,CAAC,EAAE,EAAE;IACpCI,GAAG,GAAGc,IAAI,CAACd,GAAG,CAACA,GAAG,EAAE7B,IAAI,CAACyB,CAAC,CAAC,CAAC;IAC5BK,GAAG,GAAGa,IAAI,CAACb,GAAG,CAACA,GAAG,EAAE9B,IAAI,CAACyB,CAAC,CAAC,CAAC;EAC9B;EACA,OAAO,CAACI,GAAG,EAAEC,GAAG,CAAC;AACnB;;;;;;;;;;;;;;;;;;;;ACjPiD;AAEL;AAC+C;AAE3B;AACZ;AACwB;AAEM;AACtC;AAE5C,IAAIod,KAA8B,GAAG1M,SAAS;AAC9C,IAAI6R,KAA+B,GAAG7R,SAAS;AAC/C,IAAI0xB,iBAAuD,GAAG1xB,SAAS;AACvE,IAAIlD,MAA0C,GAAGkD,SAAS;AAC1D,IAAI2xB,WAAW,GAAG,KAAK;AACvB,IAAIC,UAAU,GAAG,KAAK;AAItB,MAAMC,eAA4D,GAAG;EACnE,CAACN,oDAAa,CAACO,IAAI,GAAG,CAAC;IAAEC,YAAY;IAAEtH,iBAAiB;IAAEC;EAAuB,CAAC,KAAK;IACrF,IAAI,CAACiH,WAAW,EAAE;MAChBjlB,KAAK,GAAG,IAAI/J,uDAAW,CAACovB,YAAY,CAAC;MACrClgB,KAAK,GAAG,IAAI2Y,8DAAY,CAACC,iBAAiB,EAAEC,sBAAsB,CAAC;MACnEgH,iBAAiB,GAAG,IAAI9hB,0EAAwB,CAACiC,KAAK,CAAC;MACvD8f,WAAW,GAAG,IAAI;IACpB;IACA,OAAOpiB,OAAO,CAAC4D,OAAO,CAAC,CAAC;EAC1B,CAAC;EAED,CAACoe,oDAAa,CAACS,aAAa,GAAG,OAAO;IAAE9e,IAAI;IAAEqC;EAAQ,CAAC,KAAK;IAC1D,MAAMyN,UAAU,GAAG9lB,KAAK,CAACyP,OAAO,CAACuG,IAAI,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI;IACvD,MAAM+P,QAAQ,GAAG1N,OAAO,EAAE0N,QAAQ,IAAIN,iEAAc,CAACK,UAAU,CAAC;IAChE4O,UAAU,GAAG3O,QAAQ,KAAKP,+DAAgB,CAACE,IAAI;IAC/C9lB,MAAM,GAAG,MAAMimB,qEAAkB,CAAC7P,IAAI,EAAE;MAAE,GAAGqC,OAAO;MAAE7I,KAAK;MAAEmF,KAAK,EAAE6f;IAAkB,CAAC,CAAC;IACxF,OAAO50B,MAAM,KAAKkD,SAAS;EAC7B,CAAC;EAED,CAACuxB,oDAAa,CAACU,aAAa,GAAG,MAAOp1B,QAAQ,IAAK;IACjD,IAAIC,MAAM,KAAKkD,SAAS,EAAE;MACxB,MAAM,IAAI2Q,wEAAe,CAAC,mBAAmB,CAAC;IAChD;IAEA,OAAO,MAAM7T,MAAM,CAACsN,eAAe,CAACqnB,yDAAe,CAAC50B,QAAQ,CAAC,CAAC;EAChE,CAAC;EAED,CAAC00B,oDAAa,CAACW,SAAS,GAAG,MAAOr1B,QAAQ,IAAK;IAC7C,IAAIC,MAAM,KAAKkD,SAAS,EAAE;MACxB,MAAM,IAAI2Q,wEAAe,CAAC,mBAAmB,CAAC;IAChD;IACA,OAAO,MAAM7T,MAAM,CAAC+C,QAAQ,CAAC4xB,yDAAe,CAAC50B,QAAQ,CAAC,CAAC;EACzD,CAAC;EAED,CAAC00B,oDAAa,CAACY,gBAAgB,GAAG,CAAC;IAAE17B,SAAS;IAAEoG,QAAQ;IAAEu1B,QAAQ;IAAEC;EAAO,CAAC,KAAK;IAC/E,IAAIv1B,MAAM,KAAKkD,SAAS,EAAE;MACxB,MAAM,IAAI2Q,wEAAe,CAAC,mBAAmB,CAAC;IAChD;IAEA,OAAO7T,MAAM,CAACgO,kBAAkB,CAC9BrU,SAAS,EACTg7B,yDAAe,CAAC50B,QAAQ,CAAC,EACzB,CAACpG,SAAS,EAAEoG,QAAQ,KAAK;MACvB,MAAMsiB,OAAsC,GAAG;QAC7CmT,cAAc,EAAEd,2DAAoB,CAACe,KAAK;QAC1CC,SAAS,EAAElB,sDAAe,CAACmB,eAAe;QAC1CL,QAAQ;QACRC,MAAM;QACN57B,SAAS;QACToG;MACF,CAAC;MACD61B,IAAI,CAAC3T,WAAW,CAACI,OAAO,CAAC;IAC3B,CAAC,EACD,CAACte,YAAY,EAAEvT,KAAK,EAAEE,IAAI,EAAEod,MAAM,EAAEC,SAAS,KAAK;MAChD,MAAMsU,OAAsC,GAAG;QAC7CmT,cAAc,EAAEd,2DAAoB,CAACe,KAAK;QAC1CC,SAAS,EAAElB,sDAAe,CAACqB,YAAY;QACvCP,QAAQ;QACRC,MAAM;QACNxxB,YAAY;QACZvT,KAAK;QACLE,IAAI;QACJod,MAAM;QACNC;MACF,CAAC;MACA6nB,IAAI,CAAuB3T,WAAW,CAACI,OAAO,EAAEyS,UAAU,GAAG,EAAE,GAAGpkC,IAAI,CAAC8M,GAAG,CAAE4S,CAAC,IAAKA,CAAC,CAACkN,MAAM,CAAC,CAAC;IAC/F,CACF,CAAC;EACH,CAAC;EAED,CAACmX,oDAAa,CAACqB,gCAAgC,GAAItd,UAAU,IAAK;IAChE;IACAxY,MAAM,EAAE8M,mBAAmB,CAAC0L,UAAU,CAAC;IACvC,OAAO/F,OAAO,CAAC4D,OAAO,CAAC,CAAC;EAC1B,CAAC;EAED,CAACoe,oDAAa,CAACsB,gCAAgC,GAAIrmB,YAAY,IAAK;IAClE1P,MAAM,EAAEgN,uBAAuB,CAAC0C,YAAY,CAAC;IAC7C,OAAO+C,OAAO,CAAC4D,OAAO,CAAC,CAAC;EAC1B,CAAC;EAED,CAACoe,oDAAa,CAACuB,oBAAoB,GAAIrhB,YAAY,IAAK;IACtD3U,MAAM,EAAEkN,kBAAkB,CAACyH,YAAY,CAAC;IACxC,OAAOlC,OAAO,CAAC4D,OAAO,CAAC,CAAC;EAC1B;AACF,CAAC;AAEDuf,IAAI,CAAC9T,SAAS,GAAG,OAAgC;EAAEpxB;AAAqC,CAAC,KAAK;EAC5F,MAAM;IAAEulC,KAAK;IAAEhe,IAAI;IAAEie;EAAQ,CAAC,GAAGxlC,IAAI;EACrC,IAAI2xB,OAA0B;EAE9B,IAAI;IACF,MAAMpS,QAAQ,GAAG,MAAM8kB,eAAe,CAAC9c,IAAI,CAAC,CAACie,OAAO,CAAC;IACrD7T,OAAO,GAAG;MAAEmT,cAAc,EAAEd,2DAAoB,CAACyB,OAAO;MAAEF,KAAK;MAAEhe,IAAI;MAAEie,OAAO,EAAEjmB;IAAS,CAAC;EAC5F,CAAC,CAAC,OAAO9X,CAAC,EAAE;IACVkqB,OAAO,GAAG;MAAEmT,cAAc,EAAEd,2DAAoB,CAAC0B,KAAK;MAAEH,KAAK;MAAEhe,IAAI;MAAEie,OAAO,EAAE3B,+DAAc,CAACp8B,CAAC;IAAE,CAAC;EACnG;EACAy9B,IAAI,CAAC3T,WAAW,CAACI,OAAO,CAAC;AAC3B,CAAC;;;;;;;;;;;;;;;;;AC9GD;AACO,IAAWoS,aAAa,0BAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAA,OAAbA,aAAa;AAAA;;AAW/B;AACO,IAAWC,oBAAoB,0BAApBA,oBAAoB;EAApBA,oBAAoB,CAApBA,oBAAoB;EAApBA,oBAAoB,CAApBA,oBAAoB;EAApBA,oBAAoB,CAApBA,oBAAoB;EAAA,OAApBA,oBAAoB;AAAA;;AAMtC;AACO,IAAWF,eAAe,0BAAfA,eAAe;EAAfA,eAAe,CAAfA,eAAe;EAAfA,eAAe,CAAfA,eAAe;EAAA,OAAfA,eAAe;AAAA;;AAOjC;;AAOA;;AAwBA;;AAYA;;AAYA;;AASA;;AAEA;;;;;;;;;;;;;;;;ACtGsC;AAGtC;AACO,SAASG,eAAeA,CAAC/nB,IAAc,EAAY;EACxD,OAAO;IACL,GAAGA,IAAI;IACPlM,SAAS,EAAE,IAAI+L,uCAAI,CAAC,IAAIjU,0CAAO,CAAC,CAAC,CAAC69B,IAAI,CAACzpB,IAAI,CAAClM,SAAS,CAACnO,GAAG,CAAC,EAAE,IAAIiG,0CAAO,CAAC,CAAC,CAAC69B,IAAI,CAACzpB,IAAI,CAAClM,SAAS,CAAClO,GAAG,CAAC;EACpG,CAAC;AACH;;;;;;;;;;ACTA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;WClCA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WClBA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,aAAa;WACb;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;;;;;WCpCA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;UENA;UACA","sources":["webpack://@aics/volume-viewer/./src/Channel.ts","webpack://@aics/volume-viewer/./src/Histogram.ts","webpack://@aics/volume-viewer/./src/ImageInfo.ts","webpack://@aics/volume-viewer/./src/Lut.ts","webpack://@aics/volume-viewer/./src/Volume.ts","webpack://@aics/volume-viewer/./src/VolumeCache.ts","webpack://@aics/volume-viewer/./src/VolumeDims.ts","webpack://@aics/volume-viewer/./src/VolumeRenderSettings.ts","webpack://@aics/volume-viewer/./src/constants/colors.ts","webpack://@aics/volume-viewer/./src/constants/time.ts","webpack://@aics/volume-viewer/./src/loaders/IVolumeLoader.ts","webpack://@aics/volume-viewer/./src/loaders/JsonImageInfoLoader.ts","webpack://@aics/volume-viewer/./src/loaders/OmeZarrLoader.ts","webpack://@aics/volume-viewer/./src/loaders/RawArrayLoader.ts","webpack://@aics/volume-viewer/./src/loaders/TiffLoader.ts","webpack://@aics/volume-viewer/./src/loaders/VolumeLoadError.ts","webpack://@aics/volume-viewer/./src/loaders/VolumeLoaderUtils.ts","webpack://@aics/volume-viewer/./src/loaders/index.ts","webpack://@aics/volume-viewer/./src/loaders/zarr_utils/ChunkPrefetchIterator.ts","webpack://@aics/volume-viewer/./src/loaders/zarr_utils/WrappedStore.ts","webpack://@aics/volume-viewer/./src/loaders/zarr_utils/types.ts","webpack://@aics/volume-viewer/./src/loaders/zarr_utils/utils.ts","webpack://@aics/volume-viewer/./src/loaders/zarr_utils/validation.ts","webpack://@aics/volume-viewer/./src/types.ts","webpack://@aics/volume-viewer/./src/utils/RequestQueue.ts","webpack://@aics/volume-viewer/./src/utils/SubscribableRequestQueue.ts","webpack://@aics/volume-viewer/./src/utils/num_utils.ts","webpack://@aics/volume-viewer/./src/workers/VolumeLoadWorker.ts","webpack://@aics/volume-viewer/./src/workers/types.ts","webpack://@aics/volume-viewer/./src/workers/util.ts","webpack://@aics/volume-viewer/ignored|/home/runner/work/volume-viewer/volume-viewer/node_modules/geotiff/dist-module/source/client|http","webpack://@aics/volume-viewer/ignored|/home/runner/work/volume-viewer/volume-viewer/node_modules/geotiff/dist-module/source/client|https","webpack://@aics/volume-viewer/ignored|/home/runner/work/volume-viewer/volume-viewer/node_modules/geotiff/dist-module/source/client|url","webpack://@aics/volume-viewer/ignored|/home/runner/work/volume-viewer/volume-viewer/node_modules/geotiff/dist-module/source|fs","webpack://@aics/volume-viewer/webpack/bootstrap","webpack://@aics/volume-viewer/webpack/runtime/chunk loaded","webpack://@aics/volume-viewer/webpack/runtime/define property getters","webpack://@aics/volume-viewer/webpack/runtime/ensure chunk","webpack://@aics/volume-viewer/webpack/runtime/get javascript chunk filename","webpack://@aics/volume-viewer/webpack/runtime/global","webpack://@aics/volume-viewer/webpack/runtime/hasOwnProperty shorthand","webpack://@aics/volume-viewer/webpack/runtime/make namespace object","webpack://@aics/volume-viewer/webpack/runtime/publicPath","webpack://@aics/volume-viewer/webpack/runtime/importScripts chunk loading","webpack://@aics/volume-viewer/webpack/runtime/startup chunk dependencies","webpack://@aics/volume-viewer/webpack/before-startup","webpack://@aics/volume-viewer/webpack/startup","webpack://@aics/volume-viewer/webpack/after-startup"],"sourcesContent":["import {\n  DataTexture,\n  LuminanceFormat,\n  RedFormat,\n  RedIntegerFormat,\n  UnsignedByteType,\n  ByteType,\n  FloatType,\n  IntType,\n  UnsignedIntType,\n  ShortType,\n  UnsignedShortType,\n  RGBAFormat,\n  LinearFilter,\n  NearestFilter,\n  UVMapping,\n  ClampToEdgeWrapping,\n  Vector3,\n  PixelFormatGPU,\n} from \"three\";\nimport Histogram from \"./Histogram.js\";\nimport { Lut, LUT_ARRAY_LENGTH } from \"./Lut.js\";\nimport { TypedArray, NumberType, ARRAY_CONSTRUCTORS } from \"./types.js\";\n\ninterface ChannelImageData {\n  /** Returns the one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255. */\n  readonly data: TypedArray<NumberType>;\n  /** Returns the actual dimensions of the data in the ImageData object, in pixels. */\n  readonly height: number;\n  /** Returns the actual dimensions of the data in the ImageData object, in pixels. */\n  readonly width: number;\n}\n\n// Data and processing for a single channel\nexport default class Channel {\n  public loaded: boolean;\n  public dtype: NumberType;\n  public imgData: ChannelImageData;\n  public volumeData: TypedArray<NumberType>;\n  public name: string;\n  public histogram: Histogram;\n  public lut: Lut;\n  public colorPalette: Uint8Array;\n  public colorPaletteAlpha: number;\n  public dims: [number, number, number];\n  public dataTexture: DataTexture;\n  public lutTexture: DataTexture;\n  public rawMin: number;\n  public rawMax: number;\n\n  constructor(name: string) {\n    this.loaded = false;\n    this.dtype = \"uint8\";\n    this.imgData = { data: new Uint8Array(), width: 0, height: 0 };\n    this.rawMin = 0;\n    this.rawMax = 255;\n\n    // on gpu\n    this.dataTexture = new DataTexture(new Uint8Array(), 0, 0);\n    this.lutTexture = new DataTexture(new Uint8Array(LUT_ARRAY_LENGTH), 256, 1, RGBAFormat, UnsignedByteType);\n    this.lutTexture.minFilter = this.lutTexture.magFilter = LinearFilter;\n    this.lutTexture.generateMipmaps = false;\n\n    this.volumeData = new Uint8Array();\n    this.name = name;\n    this.histogram = new Histogram(new Uint8Array());\n    this.dims = [0, 0, 0];\n\n    // intensity remapping lookup table\n    this.lut = new Lut().createFromMinMax(0, 255);\n\n    // per-intensity color labeling (disabled initially)\n    this.colorPalette = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n    // store in 0..1 range. 1 means fully colorPalette, 0 means fully lut.\n    this.colorPaletteAlpha = 0.0;\n  }\n\n  // rgbColor is [0..255, 0..255, 0..255]\n  public combineLuts(rgbColor: [number, number, number] | number, out?: Uint8Array): Uint8Array {\n    const ret = out ? out : new Uint8Array(LUT_ARRAY_LENGTH);\n    if (!rgbColor) {\n      return ret;\n    }\n    const rgb = [rgbColor[0] / 255.0, rgbColor[1] / 255.0, rgbColor[2] / 255.0];\n    // colorPalette*alpha + rgb*lut*(1-alpha)\n    // a tiny bit faster for the edge cases\n    if (this.colorPaletteAlpha === 1.0) {\n      ret.set(this.colorPalette);\n    } else if (this.colorPaletteAlpha === 0.0) {\n      ret.set(this.lut.lut);\n      for (let i = 0; i < LUT_ARRAY_LENGTH / 4; ++i) {\n        ret[i * 4 + 0] *= rgb[0];\n        ret[i * 4 + 1] *= rgb[1];\n        ret[i * 4 + 2] *= rgb[2];\n      }\n    } else {\n      for (let i = 0; i < LUT_ARRAY_LENGTH / 4; ++i) {\n        ret[i * 4 + 0] =\n          this.colorPalette[i * 4 + 0] * this.colorPaletteAlpha +\n          this.lut.lut[i * 4 + 0] * (1.0 - this.colorPaletteAlpha) * rgb[0];\n        ret[i * 4 + 1] =\n          this.colorPalette[i * 4 + 1] * this.colorPaletteAlpha +\n          this.lut.lut[i * 4 + 1] * (1.0 - this.colorPaletteAlpha) * rgb[1];\n        ret[i * 4 + 2] =\n          this.colorPalette[i * 4 + 2] * this.colorPaletteAlpha +\n          this.lut.lut[i * 4 + 2] * (1.0 - this.colorPaletteAlpha) * rgb[2];\n        ret[i * 4 + 3] =\n          this.colorPalette[i * 4 + 3] * this.colorPaletteAlpha +\n          this.lut.lut[i * 4 + 3] * (1.0 - this.colorPaletteAlpha);\n      }\n    }\n\n    this.lutTexture.image.data.set(ret);\n    this.lutTexture.needsUpdate = true;\n\n    return ret;\n  }\n\n  public setRawDataRange(min: number, max: number): void {\n    // remap the lut which was based on rawMin and rawMax to new min and max\n    // If either of the min/max ranges are both zero, then we have undefined behavior and should\n    // not remap the lut.  This situation can happen at first load, for example,\n    // when one channel has arrived but others haven't.\n    if (!(this.rawMin === 0 && this.rawMax === 0) && !(min === 0 && max === 0)) {\n      this.lut.remapDomains(this.rawMin, this.rawMax, min, max);\n      this.rawMin = min;\n      this.rawMax = max;\n    }\n  }\n\n  public getHistogram(): Histogram {\n    return this.histogram;\n  }\n\n  public getIntensity(x: number, y: number, z: number): number {\n    return this.volumeData[x + y * this.dims[0] + z * (this.dims[0] * this.dims[1])];\n  }\n\n  public normalizeRaw(val: number): number {\n    return (val - this.rawMin) / (this.rawMax - this.rawMin);\n  }\n\n  // how to index into tiled texture atlas\n  public getIntensityFromAtlas(x: number, y: number, z: number): number {\n    const numXtiles = this.imgData.width / this.dims[0];\n    const tilex = z % numXtiles;\n    const tiley = Math.floor(z / numXtiles);\n    const offset = tilex * this.dims[0] + x + (tiley * this.dims[1] + y) * this.imgData.width;\n    return this.imgData.data[offset];\n  }\n\n  private rebuildDataTexture(data: TypedArray<NumberType>, w: number, h: number): void {\n    if (this.dataTexture) {\n      this.dataTexture.dispose();\n    }\n    let format = LuminanceFormat;\n    let dataType = UnsignedByteType;\n    let internalFormat: PixelFormatGPU = \"LUMINANCE\";\n    switch (this.dtype) {\n      case \"uint8\":\n        dataType = UnsignedByteType;\n        format = RedIntegerFormat;\n        internalFormat = \"R8UI\";\n        break;\n      case \"int8\":\n        dataType = ByteType;\n        format = RedIntegerFormat;\n        internalFormat = \"R8I\";\n        break;\n      case \"uint16\":\n        dataType = UnsignedShortType;\n        format = RedIntegerFormat;\n        internalFormat = \"R16UI\";\n        break;\n      case \"int16\":\n        dataType = ShortType;\n        format = RedIntegerFormat;\n        internalFormat = \"R16I\";\n        break;\n      case \"uint32\":\n        dataType = UnsignedIntType;\n        format = RedIntegerFormat;\n        internalFormat = \"R32UI\";\n        break;\n      case \"int32\":\n        dataType = IntType;\n        format = RedIntegerFormat;\n        internalFormat = \"R32I\";\n        break;\n      case \"float32\":\n        dataType = FloatType;\n        format = RedFormat;\n        internalFormat = \"R32F\";\n        break;\n      default:\n        console.warn(\"unsupported dtype for channel data\", this.dtype);\n        break;\n    }\n\n    this.dataTexture = new DataTexture(\n      data,\n      w,\n      h,\n      format,\n      dataType,\n      UVMapping,\n      ClampToEdgeWrapping,\n      ClampToEdgeWrapping,\n      NearestFilter,\n      NearestFilter\n    );\n    this.dataTexture.internalFormat = internalFormat;\n    this.dataTexture.needsUpdate = true;\n  }\n\n  // give the channel fresh data and initialize from that data\n  // data is formatted as a texture atlas where each tile is a z slice of the volume\n  public setFromAtlas(\n    bitsArray: TypedArray<NumberType>,\n    w: number,\n    h: number,\n    dtype: NumberType,\n    rawMin: number,\n    rawMax: number,\n    subregionSize: Vector3\n  ): void {\n    this.dtype = dtype;\n    this.imgData = { data: bitsArray, width: w, height: h };\n\n    this.rebuildDataTexture(this.imgData.data, w, h);\n\n    this.loaded = true;\n    this.histogram = new Histogram(bitsArray);\n\n    // reuse old lut but auto-remap it to new data range\n    this.setRawDataRange(rawMin, rawMax);\n\n    this.unpackFromAtlas(subregionSize.x, subregionSize.y, subregionSize.z);\n  }\n\n  // let's rearrange this.imgData.data into a 3d array.\n  // it is assumed to be coming in as a flat Uint8Array of size x*y*z\n  // with x*y*z layout (first row of first plane is the first data in the layout,\n  // then second row of first plane, etc)\n  private unpackFromAtlas(x: number, y: number, z: number): void {\n    const volimgdata = this.imgData.data;\n\n    this.dims = [x, y, z];\n    const ctor = ARRAY_CONSTRUCTORS[this.dtype];\n    this.volumeData = new ctor(x * y * z);\n\n    const numXtiles = this.imgData.width / x;\n    const atlasrow = this.imgData.width;\n    let tilex = 0,\n      tiley = 0,\n      tileoffset = 0,\n      tilerowoffset = 0,\n      destOffset = 0;\n    for (let i = 0; i < z; ++i) {\n      // tile offset\n      tilex = i % numXtiles;\n      tiley = Math.floor(i / numXtiles);\n      tileoffset = tilex * x + tiley * y * atlasrow;\n      for (let j = 0; j < y; ++j) {\n        tilerowoffset = j * atlasrow;\n        destOffset = i * (x * y) + j * x;\n        this.volumeData.set(\n          volimgdata.subarray(tileoffset + tilerowoffset, tileoffset + tilerowoffset + x),\n          destOffset\n        );\n      }\n    }\n  }\n\n  // give the channel fresh volume data and initialize from that data\n  public setFromVolumeData(\n    bitsArray: TypedArray<NumberType>,\n    vx: number,\n    vy: number,\n    vz: number,\n    ax: number,\n    ay: number,\n    rawMin: number,\n    rawMax: number,\n    dtype: NumberType\n  ): void {\n    this.dims = [vx, vy, vz];\n    this.volumeData = bitsArray;\n    this.dtype = dtype;\n    // TODO FIXME performance hit for shuffling the data and storing 2 versions of it (could do this in worker at least?)\n    this.packToAtlas(vx, vy, vz, ax, ay);\n    this.loaded = true;\n    // update from current histogram?\n    this.setRawDataRange(rawMin, rawMax);\n    this.histogram = new Histogram(this.volumeData);\n  }\n\n  // given this.volumeData, let's unpack it into a flat textureatlas and fill up this.imgData.\n  private packToAtlas(vx: number, vy: number, vz: number, ax: number, ay: number): void {\n    // big assumptions:\n    // atlassize is a perfect multiple of volumesize in both x and y\n    // ax % vx == 0\n    // ay % vy == 0\n    // and num slices <= num possible slices in atlas.\n    // (ax/vx) * (ay/vy) >= vz\n    if (ax % vx !== 0 || ay % vy !== 0 || (ax / vx) * (ay / vy) < vz) {\n      console.log(\"ERROR - atlas and volume dims are inconsistent\");\n      console.log(ax, ay, vx, vy, vz);\n    }\n\n    const ctor = ARRAY_CONSTRUCTORS[this.dtype];\n    this.imgData = {\n      width: ax,\n      height: ay,\n      data: new ctor(ax * ay),\n    };\n    this.imgData.data.fill(0);\n\n    // deposit slices one by one into the imgData.data from volData.\n    const volimgdata = this.imgData.data;\n\n    const x = vx,\n      y = vy,\n      z = vz;\n\n    const numXtiles = this.imgData.width / x;\n    const atlasrow = this.imgData.width;\n    let tilex = 0,\n      tiley = 0,\n      tileoffset = 0,\n      tilerowoffset = 0,\n      sourceOffset = 0;\n    for (let i = 0; i < z; ++i) {\n      // tile offset\n      tilex = i % numXtiles;\n      tiley = Math.floor(i / numXtiles);\n      tileoffset = tilex * x + tiley * y * atlasrow;\n      for (let j = 0; j < y; ++j) {\n        tilerowoffset = j * atlasrow;\n        sourceOffset = i * (x * y) + j * x;\n        volimgdata.set(this.volumeData.subarray(sourceOffset, sourceOffset + x), tileoffset + tilerowoffset);\n      }\n    }\n\n    this.rebuildDataTexture(this.imgData.data, ax, ay);\n  }\n\n  public setLut(lut: Lut): void {\n    this.lut = lut;\n  }\n\n  // palette should be an uint8array of 256*4 elements (256 rgba8 values)\n  public setColorPalette(palette: Uint8Array): void {\n    this.colorPalette = palette;\n  }\n\n  public setColorPaletteAlpha(alpha: number): void {\n    this.colorPaletteAlpha = alpha;\n  }\n}\n","import type { TypedArray, NumberType } from \"./types.js\";\n\nconst NBINS = 256;\n\ntype HistogramData = {\n  bins: Uint32Array;\n  min: number;\n  max: number;\n  binSize: number;\n};\n\n/**\n * Builds a histogram with 256 bins from a data array. Assume data is 8 bit single channel grayscale.\n * @class\n * @param {Array.<number>} data\n */\nexport default class Histogram {\n  // no more than 2^32 pixels of any one intensity in the data!?!?!\n  private bins: Uint32Array;\n  /** Min value in the original raw data. */\n  private min: number;\n  /** Max value in the original raw data. */\n  private max: number;\n  /** Size of each histogram bin in the scale of the original data. */\n  private binSize: number;\n  /** Index of the first bin (other than 0) with at least 1 value. */\n  private dataMinBin: number;\n  /** Index of the last bin (other than 0) with at least 1 value. */\n  private dataMaxBin: number;\n  private pixelCount: number;\n  public maxBin: number;\n\n  constructor(data: TypedArray<NumberType>) {\n    this.dataMinBin = 0;\n    this.dataMaxBin = 0;\n    this.maxBin = 0;\n    this.bins = new Uint32Array();\n    this.min = 0;\n    this.max = 0;\n    this.binSize = 0;\n\n    // build up the histogram\n    const hinfo = Histogram.calculateHistogram(data, NBINS);\n    this.bins = hinfo.bins;\n    this.min = hinfo.min;\n    this.max = hinfo.max;\n    this.binSize = hinfo.binSize;\n\n    // TODO: These should always return 0 and NBINS - 1, respectively. Test if these\n    // can be removed.\n    for (let i = 0; i < this.bins.length; i++) {\n      if (this.bins[i] > 0) {\n        this.dataMinBin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 0; i--) {\n      if (this.bins[i] > 0) {\n        this.dataMaxBin = i;\n        break;\n      }\n    }\n\n    this.pixelCount = data.length;\n\n    // get the bin with the most frequently occurring NONZERO value\n    this.maxBin = 1;\n    let max = this.bins[1];\n    for (let i = 1; i < this.bins.length; i++) {\n      if (this.bins[i] > max) {\n        this.maxBin = i;\n        max = this.bins[i];\n      }\n    }\n  }\n\n  // return the bin index of the given data value\n  public static findBin(dataValue: number, dataMin: number, binSize: number, numBins: number): number {\n    let binIndex = Math.floor((dataValue - dataMin) / binSize);\n    // for values that lie exactly on last bin we need to subtract one\n    if (binIndex === numBins) {\n      binIndex--;\n    }\n    return binIndex;\n  }\n\n  // return the bin index of the given data value\n  public findBinOfValue(value: number): number {\n    return Histogram.findBin(value, this.min, this.binSize, NBINS);\n  }\n\n  /**\n   * Return the min data value\n   * @return {number}\n   */\n  getDataMin(): number {\n    return this.min;\n  }\n\n  /**\n   * Return the max data value\n   * @return {number}\n   */\n  getDataMax(): number {\n    return this.max;\n  }\n\n  /**\n   * Returns the first bin index with at least 1 value, other than the 0th bin.\n   * @return {number}\n   */\n  getMin(): number {\n    return this.dataMinBin;\n  }\n\n  /**\n   * Returns the last bin index with at least 1 value, other than the 0th bin.\n   * @return {number}\n   */\n  getMax(): number {\n    // Note that this will always return `NBINS - 1`.\n    return this.dataMaxBin;\n  }\n\n  getNumBins(): number {\n    return this.bins.length;\n  }\n\n  getBin(i: number): number {\n    return this.bins[i];\n  }\n\n  getBinRange(i: number): [number, number] {\n    return [this.min + i * this.binSize, this.min + (i + 1) * this.binSize];\n  }\n\n  /**\n   * Find the bin that contains the percentage of pixels below it\n   * @return {number}\n   * @param {number} pct\n   */\n  findBinOfPercentile(pct: number): number {\n    const limit = this.pixelCount * pct;\n\n    let i = 0;\n    let count = 0;\n    for (i = 0; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    return i;\n  }\n\n  // Find bins at 10th / 90th percentile\n  findBestFitBins(): [number, number] {\n    const pixcount = this.pixelCount;\n    //const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n\n    let i = 0;\n    let count = 0;\n    for (i = 1; i < this.bins.length; ++i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmin = i;\n\n    count = 0;\n    for (i = this.bins.length - 1; i >= 1; --i) {\n      count += this.bins[i];\n      if (count > limit) {\n        break;\n      }\n    }\n    const hmax = i;\n\n    return [hmin, hmax];\n  }\n\n  // Find min and max bins attempting to replicate ImageJ's \"Auto\" button\n  findAutoIJBins(): [number, number] {\n    // note that consecutive applications of this should modify the auto threshold. see:\n    // https://github.com/imagej/ImageJ/blob/7746fcb0f5744a7a7758244c5dcd2193459e6e0e/ij/plugin/frame/ContrastAdjuster.java#L816\n    const AUTO_THRESHOLD = 5000;\n    const pixcount = this.pixelCount;\n    //  const pixcount = this.imgData.data.length;\n    const limit = pixcount / 10;\n    const threshold = pixcount / AUTO_THRESHOLD;\n\n    // this will skip the \"zero\" bin which contains pixels of zero intensity.\n    let hmin = this.bins.length - 1;\n    let hmax = 1;\n    for (let i = 1; i < this.bins.length; ++i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmin = i;\n        break;\n      }\n    }\n    for (let i = this.bins.length - 1; i >= 1; --i) {\n      if (this.bins[i] > threshold && this.bins[i] <= limit) {\n        hmax = i;\n        break;\n      }\n    }\n\n    if (hmax < hmin) {\n      hmin = 0;\n      hmax = 255;\n    }\n\n    return [hmin, hmax];\n  }\n\n  // Find min and max bins using a percentile of the most commonly occurring value\n  findAutoMinMax(): [number, number] {\n    // simple linear mapping cutting elements with small appearence\n    // get 10% threshold\n    const PERCENTAGE = 0.1;\n    const th = Math.floor(this.bins[this.maxBin] * PERCENTAGE);\n    let b = 0;\n    let e = this.bins.length - 1;\n    for (let x = 1; x < this.bins.length; ++x) {\n      if (this.bins[x] > th) {\n        b = x;\n        break;\n      }\n    }\n    for (let x = this.bins.length - 1; x >= 1; --x) {\n      if (this.bins[x] > th) {\n        e = x;\n        break;\n      }\n    }\n    return [b, e];\n  }\n\n  private static calculateHistogram(arr: TypedArray<NumberType>, numBins = 1): HistogramData {\n    if (numBins < 1) {\n      numBins = 1;\n    }\n\n    // calculate min and max of arr\n    // TODO See convertChannel, which will also compute min and max!\n    // We could save a whole extra loop over the data, or have convertChannel compute the whole histogram.\n    // need to be careful about computing over chunks or whole ready-to-display volume\n\n    let min = arr[0];\n    let max = arr[0];\n    for (let i = 1; i < arr.length; i++) {\n      if (arr[i] < min) {\n        min = arr[i];\n      } else if (arr[i] > max) {\n        max = arr[i];\n      }\n    }\n\n    const bins = new Uint32Array(numBins).fill(0);\n\n    const binSize = (max - min) / numBins === 0 ? 1 : (max - min) / numBins;\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i];\n\n      const binIndex = Histogram.findBin(item, min, binSize, numBins);\n      bins[binIndex]++;\n    }\n\n    return { bins, min, max, binSize };\n  }\n}\n","import { type VolumeDims, volumeSize, physicalPixelSize } from \"./VolumeDims.js\";\nimport { Vector3, Vector2 } from \"three\";\n\nexport type ImageInfo = Readonly<{\n  name: string;\n\n  /**\n   * XY dimensions of the texture atlas used by `RayMarchedAtlasVolume` and `Atlas2DSlice`, in number of z-slice\n   * tiles (not pixels). Chosen by the loader to lay out the 3D volume in the squarest possible 2D texture atlas.\n   */\n  atlasTileDims: [number, number];\n  /** Size of the currently loaded subregion, in pixels, in XYZ order */\n  subregionSize: [number, number, number];\n  /** Offset of the loaded subregion into the total volume, in pixels, in XYZ order */\n  subregionOffset: [number, number, number];\n\n  /** Number of channels in the image, accounting for convergence of multiple sources.\n   * Because of multiple sources, which is not accounted for in ImageInfo,\n   * that this could be different than the number of channels in the multiscaleLevelDims.\n   * NOTE Currently there is one ImageInfo per Volume, not per source.\n   */\n  combinedNumChannels: number;\n  /** The names of each channel */\n  channelNames: string[];\n  /** Optional overrides to default channel colors, in 0-255 range, RGB order */\n  channelColors?: [number, number, number][];\n\n  /** Dimensions of each scale level, at original size, from the first data source */\n  multiscaleLevelDims: VolumeDims[];\n\n  /** The scale level from which this image was loaded, between `0` and `numMultiscaleLevels-1` */\n  multiscaleLevel: number;\n\n  /**\n   * An *optional* transform which may be supplied by image metadata. It is *not* applied by\n   * default, but may be read and fed to `View3d` methods: `setVolumeTransform`,\n   * `setVolumeRotation`, `setVolumeScale`.\n   */\n  transform: {\n    /** Translation of the volume from the center of space, in volume voxels in XYZ order */\n    translation: [number, number, number];\n    /** Rotation of the volume in Euler angles, applied in XYZ order */\n    rotation: [number, number, number];\n    /** Scale of the volume relative to its size as derived from `multiscaleLevelDims`, in XYZ order */\n    scale: [number, number, number];\n  };\n\n  /** Arbitrary additional metadata not captured by other `ImageInfo` properties */\n  userData?: Record<string, unknown>;\n}>;\n\nexport function defaultImageInfo(): ImageInfo {\n  return {\n    name: \"\",\n    atlasTileDims: [1, 1],\n    subregionSize: [1, 1, 1],\n    subregionOffset: [0, 0, 0],\n    combinedNumChannels: 1,\n    channelNames: [\"0\"],\n    channelColors: [[255, 255, 255]],\n    multiscaleLevel: 0,\n    multiscaleLevelDims: [\n      {\n        shape: [1, 1, 1, 1, 1],\n        spacing: [1, 1, 1, 1, 1],\n        spaceUnit: \"\",\n        timeUnit: \"\",\n        dataType: \"uint8\",\n      },\n    ],\n    transform: {\n      translation: [0, 0, 0],\n      rotation: [0, 0, 0],\n      scale: [1, 1, 1],\n    },\n  };\n}\n\nexport class CImageInfo {\n  imageInfo: ImageInfo;\n\n  constructor(imageInfo?: ImageInfo) {\n    this.imageInfo = imageInfo || defaultImageInfo();\n  }\n\n  get currentLevelDims(): VolumeDims {\n    return this.imageInfo.multiscaleLevelDims[this.imageInfo.multiscaleLevel];\n  }\n\n  /** Number of channels in the image */\n  get numChannels(): number {\n    return this.imageInfo.combinedNumChannels;\n  }\n\n  /** XYZ size of the *original* (not downsampled) volume, in pixels */\n  get originalSize(): Vector3 {\n    return volumeSize(this.imageInfo.multiscaleLevelDims[0]);\n  }\n\n  /** Size of the volume, in pixels */\n  get volumeSize(): Vector3 {\n    return volumeSize(this.currentLevelDims);\n  }\n\n  /** Size of a single *original* (not downsampled) pixel, in spatial units */\n  get physicalPixelSize(): Vector3 {\n    return physicalPixelSize(this.imageInfo.multiscaleLevelDims[0]);\n  }\n\n  /** Symbol of physical spatial unit used by `physicalPixelSize` */\n  get spatialUnit(): string {\n    return this.imageInfo.multiscaleLevelDims[0].spaceUnit;\n  }\n\n  /** Number of timesteps in the time series, or 1 if the image is not a time series */\n  get times(): number {\n    // 0 is T\n    return this.currentLevelDims.shape[0];\n  }\n\n  /** Size of each timestep in temporal units */\n  get timeScale(): number {\n    // 0 is T\n    return this.currentLevelDims.spacing[0];\n  }\n\n  /** Symbol of physical time unit used by `timeScale` */\n  get timeUnit(): string {\n    return this.currentLevelDims.timeUnit;\n  }\n\n  /** Number of scale levels available for this volume */\n  get numMultiscaleLevels(): number {\n    return this.imageInfo.multiscaleLevelDims.length;\n  }\n\n  /** The names of each channel */\n  get channelNames(): string[] {\n    return this.imageInfo.channelNames;\n  }\n\n  /** Optional overrides to default channel colors, in 0-255 range */\n  get channelColors(): [number, number, number][] | undefined {\n    return this.imageInfo.channelColors;\n  }\n\n  /** Size of the currently loaded subregion, in pixels */\n  get subregionSize(): Vector3 {\n    return new Vector3(...this.imageInfo.subregionSize);\n  }\n\n  /** Offset of the loaded subregion into the total volume, in pixels */\n  get subregionOffset(): Vector3 {\n    return new Vector3(...this.imageInfo.subregionOffset);\n  }\n\n  get multiscaleLevel(): number {\n    return this.imageInfo.multiscaleLevel;\n  }\n\n  /**\n   * XY dimensions of the texture atlas used by `RayMarchedAtlasVolume` and `Atlas2DSlice`, in number of z-slice\n   * tiles (not pixels). Chosen by the loader to lay out the 3D volume in the squarest possible 2D texture atlas.\n   */\n  get atlasTileDims(): Vector2 {\n    return new Vector2(...this.imageInfo.atlasTileDims);\n  }\n\n  get transform(): { translation: Vector3; rotation: Vector3; scale: Vector3 } {\n    return {\n      translation: new Vector3(...this.imageInfo.transform.translation),\n      rotation: new Vector3(...this.imageInfo.transform.rotation),\n      scale: new Vector3(...this.imageInfo.transform.scale),\n    };\n  }\n}\n\nexport function computeAtlasSize(imageInfo: ImageInfo): [number, number] {\n  const { atlasTileDims } = imageInfo;\n  const volDims = imageInfo.multiscaleLevelDims[imageInfo.multiscaleLevel];\n  // TCZYX: 4 = x, 3 = y\n  return [atlasTileDims[0] * volDims.shape[4], atlasTileDims[1] * volDims.shape[3]];\n}\n","import { getColorByChannelIndex } from \"./constants/colors.js\";\nimport Histogram from \"./Histogram.js\";\n\nfunction clamp(val: number, cmin: number, cmax: number): number {\n  return Math.min(Math.max(cmin, val), cmax);\n}\n\nfunction lerp(xmin, xmax, a) {\n  return a * (xmax - xmin) + xmin;\n}\n\n// We have an intensity value that is in the range of valueMin to valueMax.\n// This domain is assumed to have been remapped from oldMin to oldMax.\n// We now wish to find the intensity value that corresponds to the same relative position in the new domain of newMin to newMax.\n// For our Luts valueMin will always be 0, and valueMax will always be 255.\n// oldMin and oldMax will be the domain of the original raw data intensities.\n// newMin and newMax will be the domain of the new raw data intensities.\nfunction remapDomain(\n  value: number,\n  valueMin: number,\n  valueMax: number,\n  oldMin: number,\n  oldMax: number,\n  newMin: number,\n  newMax: number\n): number {\n  const pctOfRange = (value - valueMin) / (valueMax - valueMin);\n  const newValue = (newMax - newMin) * pctOfRange + newMin;\n  // now locate this value as a relative index in the old range\n  const pctOfOldRange = (newValue - oldMin) / (oldMax - oldMin);\n  const remapped = valueMin + pctOfOldRange * (valueMax - valueMin);\n  return remapped;\n}\n\n// We have an intensity value that is in the range of valueMin to valueMax.\n// The input value range is assumed to represent absolute intensity range oldMin to oldMax.\n// We now wish to find the new position of this intensity value\n// when the valueMin-valueMax represents absolute range newMin to newMax\n// After the remapping, the intensity value will be in the range of valueMin to valueMax.\n// For our Luts valueMin will always be 0, and valueMax will always be 255.\n// oldMin and oldMax will be the domain of the original raw data intensities.\n// newMin and newMax will be the domain of the new raw data intensities.\nfunction remapDomainForCP(\n  value: number,\n  valueMin: number,\n  valueMax: number,\n  oldMin: number,\n  oldMax: number,\n  newMin: number,\n  newMax: number\n): number {\n  const pctOfRange = (value - valueMin) / (valueMax - valueMin);\n  // find abs intensity from old range\n  const iOld = (oldMax - oldMin) * pctOfRange + oldMin;\n  // now locate this value as a relative index in the new range\n  const pctOfNewRange = (iOld - newMin) / (newMax - newMin);\n  const remapped = valueMin + pctOfNewRange * (valueMax - valueMin);\n  return remapped;\n}\n\nexport const LUT_ENTRIES = 256;\nexport const LUT_ARRAY_LENGTH = LUT_ENTRIES * 4;\n\n// @param {ControlPoint[]} controlPoints - array of {x:number 0..255, opacity:number 0..1, color:array of 3 numbers 0..255}\n// @return {Uint8Array} array of length len*4 representing the rgba values of the gradient\nfunction arrayFromControlPoints(controlPoints: ControlPoint[]): Uint8Array {\n  // current assumption is that control point X values are in the range 0-255\n  // and they will be used directly as indices into the LUT.\n  // therefore the lut must have 256 entries.  Anything else and we have to remap the control points.\n  // TODO allow luts that have more or less entries.\n  const len = LUT_ENTRIES;\n\n  const lut = new Uint8Array(len * 4).fill(0);\n\n  if (controlPoints.length === 0) {\n    return lut;\n  }\n\n  // ensure they are sorted in ascending order of x\n  controlPoints.sort((a, b) => a.x - b.x);\n\n  // special case only one control point.\n  if (controlPoints.length === 1) {\n    const rgba = controlPointToRGBA(controlPoints[0]);\n    // lut was already filled with zeros\n    // copy val from x to 255.\n    const startx = clamp(controlPoints[0].x, 0, 255);\n    for (let x = startx; x < len; ++x) {\n      lut[x * 4 + 0] = rgba[0];\n      lut[x * 4 + 1] = rgba[1];\n      lut[x * 4 + 2] = rgba[2];\n      lut[x * 4 + 3] = rgba[3];\n    }\n    return lut;\n  }\n\n  let c0 = controlPoints[0];\n  let c1 = controlPoints[1];\n  let color0 = controlPointToRGBA(c0);\n  let color1 = controlPointToRGBA(c1);\n  let lastIndex = 1;\n  let a = 0;\n  for (let i = 0; i < len; ++i) {\n    // find the two control points that i is between\n    while (i > c1.x) {\n      // advance control points\n      c0 = c1;\n      color0 = color1;\n      lastIndex++;\n      if (lastIndex >= controlPoints.length) {\n        // if the last control point is before 255, then we want to continue its value all the way to 255.\n        c1 = { x: 255, color: c1.color, opacity: c1.opacity };\n      } else {\n        c1 = controlPoints[lastIndex];\n      }\n      color1 = controlPointToRGBA(c1);\n    }\n    // find the lerp amount between the two control points\n    if (c1.x === c0.x) {\n      // use c1\n      a = 1.0;\n    } else {\n      a = (i - c0.x) / (c1.x - c0.x);\n    }\n    lut[i * 4 + 0] = clamp(lerp(color0[0], color1[0], a), 0, 255);\n    lut[i * 4 + 1] = clamp(lerp(color0[1], color1[1], a), 0, 255);\n    lut[i * 4 + 2] = clamp(lerp(color0[2], color1[2], a), 0, 255);\n    lut[i * 4 + 3] = clamp(lerp(color0[3], color1[3], a), 0, 255);\n  }\n  return lut;\n}\n\n/**\n * @typedef {Object} ControlPoint Used for the TF (transfer function) editor GUI.\n * Need to be converted to LUT for rendering.\n * @property {number} x The X Coordinate: an intensity value, normalized to the 0-255 range\n * @property {number} opacity The Opacity, from 0 to 1\n * @property {Array.<number>} color The Color, 3 numbers from 0-255 for r,g,b\n */\nexport type ControlPoint = {\n  x: number;\n  opacity: number;\n  color: [number, number, number];\n};\n\nfunction controlPointToRGBA(controlPoint) {\n  return [controlPoint.color[0], controlPoint.color[1], controlPoint.color[2], Math.floor(controlPoint.opacity * 255)];\n}\n\n// the intensity range will be 0-255,\n// which currently represents the range of the raw data. (not the dtype range)\nconst createFullRangeControlPoints = (opacityMin = 0, opacityMax = 1): [ControlPoint, ControlPoint] => [\n  { x: 0, opacity: opacityMin, color: [255, 255, 255] },\n  { x: 255, opacity: opacityMax, color: [255, 255, 255] },\n];\n\n/**\n * @typedef {Object} Lut Used for rendering. The start and end of the Lut represent the min and max of the data.\n * @property {Array.<number>} lut LUT_ARRAY_LENGTH element lookup table as array\n * (maps scalar intensity to a rgb color plus alpha, with each value from 0-255)\n * @property {Array.<ControlPoint>} controlPoints\n */\nexport class Lut {\n  public lut: Uint8Array;\n  public controlPoints: ControlPoint[];\n\n  constructor() {\n    this.lut = new Uint8Array(LUT_ARRAY_LENGTH);\n    this.controlPoints = [];\n    this.createFullRange();\n  }\n\n  /**\n   * Generate a piecewise linear lookup table that ramps up from 0 to 1 over the b to e domain.\n   * If e === b, then we use a step function with f(b) = 0 and f(b + 1) = 1\n   *  |\n   * 1|               +---------+-----\n   *  |              /\n   *  |             /\n   *  |            /\n   *  |           /\n   *  |          /\n   * 0+=========+---------------+-----\n   *  0         b    e         255\n   * @return {Lut}\n   * @param {number} b\n   * @param {number} e\n   */\n  createFromMinMax(b: number, e: number): Lut {\n    if (e < b) {\n      // swap\n      const tmp = e;\n      e = b;\n      b = tmp;\n    }\n\n    // Edge case: b and e are both out of bounds\n    if (b < 0 && e < 0) {\n      this.controlPoints = createFullRangeControlPoints(1, 1);\n      return this.createFromControlPoints(this.controlPoints);\n    }\n    if (b >= 255 && e >= 255) {\n      this.controlPoints = createFullRangeControlPoints(0, 0);\n      return this.createFromControlPoints(this.controlPoints);\n    }\n\n    // Generate 2 to 4 control points for a minMax LUT, from left to right\n    const controlPoints: ControlPoint[] = [];\n\n    // Add starting point at x = 0\n    let startVal = 0;\n    if (b < 0) {\n      startVal = -b / (e - b);\n    }\n    controlPoints.push({ x: 0, opacity: startVal, color: [255, 255, 255] });\n\n    // If b > 0, add another point at (b, 0)\n    if (b > 0) {\n      controlPoints.push({ x: b, opacity: 0, color: [255, 255, 255] });\n    }\n\n    // If e < 255, Add another point at (e, 1)\n    if (e < 255) {\n      if (e === b) {\n        // Use b + 0.5 as x value instead of e to create a near-vertical ramp\n        controlPoints.push({ x: b + 0.5, opacity: 1, color: [255, 255, 255] });\n      } else {\n        controlPoints.push({ x: e, opacity: 1, color: [255, 255, 255] });\n      }\n    }\n\n    // Add ending point at x = 255\n    let endVal = 1;\n    if (e > 255) {\n      endVal = (255 - b) / (e - b);\n    }\n    controlPoints.push({ x: 255, opacity: endVal, color: [255, 255, 255] });\n\n    return this.createFromControlPoints(controlPoints);\n  }\n\n  // basically, the identity LUT with respect to opacity\n  createFullRange(): Lut {\n    this.controlPoints = createFullRangeControlPoints();\n    return this.createFromControlPoints(this.controlPoints);\n  }\n\n  /**\n   * Generate a Window/level lookup table\n   * @return {Lut}\n   * @param {number} wnd in 0..1 range\n   * @param {number} lvl in 0..1 range\n   */\n  createFromWindowLevel(wnd: number, lvl: number): Lut {\n    // simple linear mapping for actual range\n    const b = lvl - wnd * 0.5;\n    const e = lvl + wnd * 0.5;\n    return this.createFromMinMax(b * 255, e * 255);\n  }\n\n  // @param {Object[]} controlPoints - array of {x:number 0..255, opacity:number 0..1, color:array of 3 numbers 0..255}\n  // @return {Uint8Array} array of length 256*4 representing the rgba values of the gradient\n  createFromControlPoints(controlPoints: ControlPoint[]): Lut {\n    this.lut = arrayFromControlPoints(controlPoints);\n    this.controlPoints = controlPoints;\n    return this;\n  }\n\n  /**\n   * Generate an \"equalized\" lookup table\n   * @return {Lut}\n   */\n  createFromEqHistogram(histogram: Histogram): Lut {\n    // TODO need to reconcile this if number of histogram bins is not equal to LUT_ENTRIES?\n\n    const map: number[] = [];\n    for (let i = 0; i < histogram.getNumBins(); ++i) {\n      map[i] = 0;\n    }\n\n    // summed area table?\n    map[0] = histogram.getBin(0);\n    for (let i = 1; i < histogram.getNumBins(); ++i) {\n      map[i] = map[i - 1] + histogram.getBin(i);\n    }\n\n    const div = map[map.length - 1] - map[0];\n    if (div > 0) {\n      // compute lut and track control points for the piecewise linear sections\n      const lutControlPoints: ControlPoint[] = [{ x: 0, opacity: 0, color: [255, 255, 255] }];\n      let slope = 0;\n      let lastSlope = 0;\n      let opacity = 0;\n      let lastOpacity = 0;\n      for (let i = 1; i < LUT_ENTRIES; ++i) {\n        lastOpacity = opacity;\n        opacity = clamp(Math.round(255 * (map[i] - map[0])), 0, 255);\n\n        slope = opacity - lastOpacity;\n        // if map[i]-map[i-1] is the same as map[i+1]-map[i] then we are in a linear segment and do not need a new control point\n        if (slope != lastSlope) {\n          lutControlPoints.push({ x: i - 1, opacity: lastOpacity / 255.0, color: [255, 255, 255] });\n          lastSlope = slope;\n        }\n      }\n\n      lutControlPoints.push({ x: 255, opacity: 1, color: [255, 255, 255] });\n\n      return this.createFromControlPoints(lutControlPoints);\n    } else {\n      // just reset to whole range in this case...?\n      return this.createFullRange();\n    }\n  }\n\n  /**\n   * Generate a lookup table with a different color per intensity value.\n   * This translates to a unique color per histogram bin with more than zero pixels.\n   * TODO THIS IS NOT THE EFFECT WE WANT.  Colorize should operate on actual data values, not histogram bins.\n   * @return {Lut}\n   */\n  createLabelColors(histogram: Histogram): Lut {\n    const lut = new Uint8Array(LUT_ARRAY_LENGTH).fill(0);\n    const controlPoints: ControlPoint[] = [];\n    // assume zero is No Label\n    controlPoints.push({ x: 0, opacity: 0, color: [0, 0, 0] });\n    let lastr = 0;\n    let lastg = 0;\n    let lastb = 0;\n    let lasta = 0;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n\n    // assumes exactly one color per bin\n    for (let i = 1; i < LUT_ENTRIES; ++i) {\n      const ibin = Math.floor((i / (LUT_ENTRIES - 1)) * (histogram.getNumBins() - 1));\n      if (histogram.getBin(ibin) > 0) {\n        const rgb = getColorByChannelIndex(ibin);\n\n        lut[i * 4 + 0] = rgb[0];\n        lut[i * 4 + 1] = rgb[1];\n        lut[i * 4 + 2] = rgb[2];\n        lut[i * 4 + 3] = 255;\n\n        r = rgb[0];\n        g = rgb[1];\n        b = rgb[2];\n        a = 1;\n      } else {\n        // add a zero control point?\n        r = 0;\n        g = 0;\n        b = 0;\n        a = 0;\n        // lut was initialized to 0 so no need to set it here.\n      }\n      // if current control point is same as last one don't add it\n      if (r !== lastr || g !== lastg || b !== lastb || a !== lasta) {\n        if (lasta === 0) {\n          controlPoints.push({ x: i - 0.5, opacity: lasta, color: [lastr, lastg, lastb] });\n        }\n        controlPoints.push({ x: i, opacity: a, color: [r, g, b] });\n        lastr = r;\n        lastg = g;\n        lastb = b;\n        lasta = a;\n      }\n    }\n\n    this.lut = lut;\n    this.controlPoints = controlPoints;\n    return this;\n  }\n\n  // since this is not a \"create\" function, it doesn't need to return the object.\n  remapDomains(oldMin: number, oldMax: number, newMin: number, newMax: number) {\n    // no attempt is made here to ensure that lut and controlPoints are internally consistent.\n    // if they start out consistent, they should end up consistent. And vice versa.\n    this.lut = remapLut(this.lut, oldMin, oldMax, newMin, newMax);\n    this.controlPoints = remapControlPoints(this.controlPoints, oldMin, oldMax, newMin, newMax);\n  }\n}\n\n// If the new max is greater than the old max, then\n// the lut's max end will move inward to the left.\n// This is another way of saying that the new max's index is greater than 255 in the old lut\n// If the new min is less than the old min, then\n// the lut's min end will move inward to the right.\n// This is another way of saying that the new min's index is less than 0 in the old lut\nexport function remapLut(lut: Uint8Array, oldMin: number, oldMax: number, newMin: number, newMax: number): Uint8Array {\n  const newLut = new Uint8Array(LUT_ARRAY_LENGTH);\n\n  // we will find what intensity is at each index in the new range,\n  // and then try to sample the pre-existing lut as if it spans the old range.\n  // Build new lut by sampling from old lut.\n  for (let i = 0; i < LUT_ENTRIES; ++i) {\n    let iOld = remapDomain(i, 0, LUT_ENTRIES - 1, oldMin, oldMax, newMin, newMax);\n    if (iOld < 0) {\n      iOld = 0;\n    }\n    if (iOld > LUT_ENTRIES - 1) {\n      iOld = LUT_ENTRIES - 1;\n    }\n    // find the indices above and below for interpolation\n    const i0 = Math.floor(iOld);\n    const i1 = Math.ceil(iOld);\n    const pct = iOld - i0;\n\n    //console.log(`interpolating ${iOld}: ${lut[i0 * 4 + 3]}, ${lut[i1 * 4 + 3]}, ${pct}`);\n    newLut[i * 4 + 0] = Math.round(lerp(lut[i0 * 4 + 0], lut[i1 * 4 + 0], pct));\n    newLut[i * 4 + 1] = Math.round(lerp(lut[i0 * 4 + 1], lut[i1 * 4 + 1], pct));\n    newLut[i * 4 + 2] = Math.round(lerp(lut[i0 * 4 + 2], lut[i1 * 4 + 2], pct));\n    newLut[i * 4 + 3] = Math.round(lerp(lut[i0 * 4 + 3], lut[i1 * 4 + 3], pct));\n  }\n\n  return newLut;\n}\n\nexport function remapControlPoints(\n  controlPoints: ControlPoint[],\n  oldMin: number,\n  oldMax: number,\n  newMin: number,\n  newMax: number,\n  nudgeEndPoints = true\n): ControlPoint[] {\n  if (controlPoints.length === 0) {\n    return controlPoints;\n  }\n\n  const newControlPoints: ControlPoint[] = [];\n\n  // Save the current position of control points at the ends of the list\n  const oldFirstX = controlPoints[0].x;\n  const oldLastX = controlPoints[controlPoints.length - 1].x;\n\n  // assume control point x domain 0-255 is mapped to oldMin-oldMax\n\n  // remap all cp x values.\n  // interpolate all new colors and opacities\n  // Do not clip values outside of 0-255. This is important to\n  // preserve information for remapping many consecutive times.\n  for (let i = 0; i < controlPoints.length; ++i) {\n    const cp = controlPoints[i];\n    const iOld = remapDomainForCP(cp.x, 0, LUT_ENTRIES - 1, oldMin, oldMax, newMin, newMax);\n    const newCP: ControlPoint = {\n      x: iOld,\n      opacity: cp.opacity,\n      color: [cp.color[0], cp.color[1], cp.color[2]],\n    };\n    newControlPoints.push(newCP);\n  }\n\n  return nudgeEndPoints ? nudgeRemappedEndControlPoints(newControlPoints, oldFirstX, oldLastX) : newControlPoints;\n}\n\n/**\n * Attempts to keep the first and last control points in a remapped list in a sensible place if they were previously on\n * or outside the edge of the range.\n *\n * Commonly (e.g. in the output of nearly all the factory methods in `Lut`), the very first and last control points\n * just define a line of constant opacity out to the upper/lower edge of the range. Remapping these points naively\n * means that the range of the transfer function no longer matches the actual range of intensities. This isn't a\n * problem for producing a lut, but it does make things look weird. If it is possible to do so without losing\n * information, we should try to keep these points in place.\n *\n * In addition to a list of control points, this function requires the x coordinate of the end points _before_\n * remapping, to determine whether the points used to be at or outside the edges of the range.\n */\nfunction nudgeRemappedEndControlPoints(controlPoints: ControlPoint[], oldFirstX: number, oldLastX: number) {\n  const EPSILON = 0.0001;\n  const first = controlPoints[0];\n  const second = controlPoints[1];\n  const secondLast = controlPoints[controlPoints.length - 2];\n  const last = controlPoints[controlPoints.length - 1];\n\n  if (Math.abs(first.opacity - (second?.opacity ?? Infinity)) < EPSILON) {\n    if (first.x < 0) {\n      // control point is now out of bounds - clamp it to 0 (or as close as we can get without losing information)\n      first.x = Math.min(0, second.x - 1);\n    } else if (oldFirstX < EPSILON) {\n      // control point was at or below 0 and has moved inward - snap it to 0 to cover the full range\n      first.x = 0;\n    }\n  }\n\n  if (Math.abs(last.opacity - (secondLast?.opacity ?? Infinity)) < EPSILON) {\n    if (last.x > 255) {\n      // control point is now out of bounds - clamp it to 255 (or as close as we can get without losing information)\n      last.x = Math.max(255, secondLast.x + 1);\n    } else if (oldLastX > 255 - EPSILON) {\n      // control point was at or above 255 and has moved inward - snap it to 255 to cover the full range\n      last.x = 255;\n    }\n  }\n\n  return controlPoints;\n}\n","import { Vector3 } from \"three\";\n\nimport Channel from \"./Channel.js\";\nimport Histogram from \"./Histogram.js\";\nimport { Lut } from \"./Lut.js\";\nimport { getColorByChannelIndex } from \"./constants/colors.js\";\nimport { type IVolumeLoader, LoadSpec, type PerChannelCallback } from \"./loaders/IVolumeLoader.js\";\nimport { MAX_ATLAS_EDGE, pickLevelToLoadUnscaled } from \"./loaders/VolumeLoaderUtils.js\";\nimport type { NumberType, TypedArray } from \"./types.js\";\nimport { type ImageInfo, CImageInfo, defaultImageInfo } from \"./ImageInfo.js\";\nimport type { VolumeDims } from \"./VolumeDims.js\";\n\ninterface VolumeDataObserver {\n  onVolumeData: (vol: Volume, batch: number[]) => void;\n  onVolumeChannelAdded: (vol: Volume, idx: number) => void;\n  onVolumeLoadError: (vol: Volume, error: unknown) => void;\n}\n\n/**\n * A renderable multichannel volume image with 8-bits per channel intensity values.\n * @class\n * @param {ImageInfo} imageInfo\n */\nexport default class Volume {\n  public imageInfo: CImageInfo;\n  public loadSpec: Required<LoadSpec>;\n  public loader?: IVolumeLoader;\n  /** `LoadSpec` representing the minimum data required to display what's in the viewer (subregion, channels, etc.).\n   * Used to intelligently issue load requests whenever required by a state change. Modify with `updateRequiredData`.\n   */\n  public loadSpecRequired: Required<LoadSpec>;\n  public channelLoadCallback?: PerChannelCallback;\n  public imageMetadata: Record<string, unknown>;\n  public name: string;\n\n  public channels: Channel[];\n  public numChannels: number;\n  public channelNames: string[];\n  public channelColorsDefault: [number, number, number][];\n\n  /** The maximum of the measurements of 3 axes in physical units (pixels*physicalSize) */\n  public physicalScale: number;\n  /** The physical size of a voxel in the original level 0 volume */\n  public physicalPixelSize: Vector3;\n  /** The physical dims of the whole volume (not accounting for subregion) */\n  public physicalSize: Vector3;\n  /** Normalized physical size of the whole volume (not accounting for subregion) */\n  public normPhysicalSize: Vector3;\n  public normRegionSize: Vector3;\n  public normRegionOffset: Vector3;\n  public physicalUnitSymbol: string;\n  public tickMarkPhysicalLength: number;\n\n  private volumeDataObservers: VolumeDataObserver[];\n  private loaded: boolean;\n\n  constructor(imageInfo: ImageInfo = defaultImageInfo(), loadSpec: LoadSpec = new LoadSpec(), loader?: IVolumeLoader) {\n    this.loaded = false;\n    this.imageInfo = new CImageInfo(imageInfo);\n    // TODO: use getter?\n    this.name = imageInfo.name;\n    this.loadSpec = {\n      // Fill in defaults for optional properties\n      multiscaleLevel: 0,\n      scaleLevelBias: 0,\n      maxAtlasEdge: MAX_ATLAS_EDGE,\n      channels: Array.from({ length: this.imageInfo.numChannels }, (_val, idx) => idx),\n      ...loadSpec,\n    };\n    this.loadSpecRequired = {\n      ...this.loadSpec,\n      channels: this.loadSpec.channels.slice(),\n      subregion: this.loadSpec.subregion.clone(),\n    };\n    this.loader = loader;\n    // imageMetadata to be filled in by Volume Loaders\n    this.imageMetadata = {};\n\n    this.normRegionSize = new Vector3(1, 1, 1);\n    this.normRegionOffset = new Vector3(0, 0, 0);\n    this.physicalSize = new Vector3(1, 1, 1);\n    this.physicalScale = 1;\n    this.normPhysicalSize = new Vector3(1, 1, 1);\n    this.physicalPixelSize = this.imageInfo.physicalPixelSize;\n    this.tickMarkPhysicalLength = 1;\n    this.setVoxelSize(this.physicalPixelSize);\n\n    this.numChannels = this.imageInfo.numChannels;\n    this.channelNames = this.imageInfo.channelNames.slice();\n    this.channelColorsDefault = this.imageInfo.channelColors\n      ? this.imageInfo.channelColors.slice()\n      : this.channelNames.map((name, index) => getColorByChannelIndex(index));\n    // fill in gaps\n    if (this.channelColorsDefault.length < this.imageInfo.numChannels) {\n      for (let i = this.channelColorsDefault.length - 1; i < this.imageInfo.numChannels; ++i) {\n        this.channelColorsDefault[i] = getColorByChannelIndex(i);\n      }\n    }\n\n    this.channels = [];\n    for (let i = 0; i < this.imageInfo.numChannels; ++i) {\n      const channel = new Channel(this.channelNames[i]);\n      this.channels.push(channel);\n      // TODO pass in channel constructor...\n      channel.dims = this.imageInfo.subregionSize.toArray();\n    }\n\n    this.physicalUnitSymbol = this.imageInfo.spatialUnit;\n\n    this.volumeDataObservers = [];\n  }\n\n  private setUnloaded() {\n    this.loaded = false;\n    this.channels.forEach((channel) => {\n      channel.loaded = false;\n    });\n  }\n\n  isLoaded(): boolean {\n    return this.loaded;\n  }\n\n  updateDimensions() {\n    const { volumeSize, subregionSize, subregionOffset } = this.imageInfo;\n\n    this.setVoxelSize(this.physicalPixelSize);\n\n    this.normRegionSize = subregionSize.clone().divide(volumeSize);\n    this.normRegionOffset = subregionOffset.clone().divide(volumeSize);\n  }\n\n  /** Returns `true` iff differences between `loadSpec` and `loadSpecRequired` indicate new data *must* be loaded. */\n  private mustLoadNewData(): boolean {\n    return (\n      this.loadSpec.useExplicitLevel !== this.loadSpecRequired.useExplicitLevel || // explicit vs automatic level changed\n      this.loadSpec.time !== this.loadSpecRequired.time || // time point changed\n      !this.loadSpec.subregion.containsBox(this.loadSpecRequired.subregion) || // new subregion not contained in old\n      this.loadSpecRequired.channels.some((channel) => !this.loadSpec.channels.includes(channel)) // new channel(s)\n    );\n  }\n\n  /**\n   * Returns `true` iff differences between `loadSpec` and `loadSpecRequired` indicate a new load *may* get a\n   * different scale level than is currently loaded.\n   *\n   * This checks for changes in properties that *can*, but do not *always*, change the scale level the loader picks.\n   * For example, a smaller `subregion` *may* mean a higher scale level will fit within memory constraints, or it may\n   * not. A higher `scaleLevelBias` *may* nudge the volume into a higher scale level, or we may already be at the max\n   * imposed by `multiscaleLevel`.\n   */\n  private mayLoadNewScaleLevel(): boolean {\n    return (\n      !this.loadSpec.subregion.equals(this.loadSpecRequired.subregion) ||\n      this.loadSpecRequired.maxAtlasEdge !== this.loadSpec.maxAtlasEdge ||\n      this.loadSpecRequired.multiscaleLevel !== this.loadSpec.multiscaleLevel ||\n      this.loadSpecRequired.scaleLevelBias !== this.loadSpec.scaleLevelBias\n    );\n  }\n\n  /** Call on any state update that may require new data to be loaded (subregion, enabled channels, time, etc.) */\n  async updateRequiredData(required: Partial<LoadSpec>, onChannelLoaded?: PerChannelCallback): Promise<void> {\n    this.loadSpecRequired = { ...this.loadSpecRequired, ...required };\n    let shouldReload = this.mustLoadNewData();\n\n    // If we're not reloading due to required data changes, check if we should load a new scale level\n    if (!shouldReload && this.mayLoadNewScaleLevel()) {\n      // Loaders should cache loaded dimensions so that this call blocks no more than once per valid `LoadSpec`.\n      const dims = await this.loadScaleLevelDims();\n      if (dims) {\n        const dimsZYX = dims.map(({ shape }): [number, number, number] => [shape[2], shape[3], shape[4]]);\n        // Determine which scale level *would* be loaded, and see if it's different than what we have\n        const levelToLoad = pickLevelToLoadUnscaled(this.loadSpecRequired, dimsZYX);\n        shouldReload = this.imageInfo.multiscaleLevel !== levelToLoad;\n      }\n    }\n\n    if (shouldReload) {\n      this.loadNewData(onChannelLoaded);\n    }\n  }\n\n  private async loadScaleLevelDims(): Promise<VolumeDims[] | undefined> {\n    try {\n      return await this.loader?.loadDims(this.loadSpecRequired);\n    } catch (e) {\n      this.volumeDataObservers.forEach((observer) => observer.onVolumeLoadError(this, e));\n      return undefined;\n    }\n  }\n\n  /**\n   * Loads new data as specified in `this.loadSpecRequired`. Clones `loadSpecRequired` into `loadSpec` to indicate\n   * that the data that *must* be loaded is now the data that *has* been loaded.\n   */\n  private async loadNewData(onChannelLoaded?: PerChannelCallback): Promise<void> {\n    this.setUnloaded();\n    this.loadSpec = {\n      ...this.loadSpecRequired,\n      subregion: this.loadSpecRequired.subregion.clone(),\n    };\n\n    try {\n      await this.loader?.loadVolumeData(this, undefined, onChannelLoaded);\n    } catch (e) {\n      this.volumeDataObservers.forEach((observer) => observer.onVolumeLoadError(this, e));\n      throw e;\n    }\n  }\n\n  // we calculate the physical size of the volume (voxels*pixel_size)\n  // and then normalize to the max physical dimension\n  // NOTE: This function MUST be called to set up some important dimensional info\n  setVoxelSize(size: Vector3): void {\n    // only set the data if it is > 0.  zero is not an allowed value.\n    size.x = size.x > 0 ? size.x : 1.0;\n    size.y = size.y > 0 ? size.y : 1.0;\n    size.z = size.z > 0 ? size.z : 1.0;\n    this.physicalPixelSize = size;\n\n    this.physicalSize = this.imageInfo.originalSize.clone().multiply(this.physicalPixelSize);\n    // Volume is scaled such that its largest physical dimension is 1 world unit - save that dimension for conversions\n    this.physicalScale = Math.max(this.physicalSize.x, this.physicalSize.y, this.physicalSize.z);\n    // Compute the volume's max extent - scaled to max dimension.\n    this.normPhysicalSize = this.physicalSize.clone().divideScalar(this.physicalScale);\n    // While we're here, pick a power of 10 that divides into our max dimension a reasonable number of times\n    // and save it to be the length of tick marks in 3d.\n    this.tickMarkPhysicalLength = 10 ** Math.floor(Math.log10(this.physicalScale / 2));\n  }\n\n  setUnitSymbol(symbol: string): void {\n    this.physicalUnitSymbol = symbol;\n  }\n\n  /** Computes the center of the volume subset */\n  getContentCenter(): Vector3 {\n    // center point: (normRegionSize / 2 + normRegionOffset - 0.5) * normPhysicalSize;\n    return this.normRegionSize\n      .clone()\n      .divideScalar(2)\n      .add(this.normRegionOffset)\n      .subScalar(0.5)\n      .multiply(this.normPhysicalSize);\n  }\n\n  cleanup(): void {\n    // no op\n  }\n\n  getChannel(channelIndex: number): Channel {\n    return this.channels[channelIndex];\n  }\n\n  onChannelLoaded(batch: number[]): void {\n    // check to see if all channels are now loaded, and fire an event(?)\n    if (this.loadSpec.channels.every((channelIndex) => this.channels[channelIndex].loaded)) {\n      this.loaded = true;\n    }\n    batch.forEach((channelIndex) => this.channelLoadCallback?.(this, channelIndex));\n    this.volumeDataObservers.forEach((observer) => observer.onVolumeData(this, batch));\n  }\n\n  /**\n   * Assign volume data via a 2d array containing the z slices as tiles across it.  Assumes that the incoming data is consistent with the image's pre-existing imageInfo tile metadata.\n   * @param {number} channelIndex\n   * @param {Uint8Array} atlasdata\n   * @param {number} atlaswidth\n   * @param {number} atlasheight\n   */\n  setChannelDataFromAtlas(\n    channelIndex: number,\n    atlasdata: TypedArray<NumberType>,\n    atlaswidth: number,\n    atlasheight: number,\n    range: [number, number],\n    dtype: NumberType = \"uint8\"\n  ): void {\n    this.channels[channelIndex].setFromAtlas(\n      atlasdata,\n      atlaswidth,\n      atlasheight,\n      dtype,\n      range[0],\n      range[1],\n      this.imageInfo.subregionSize\n    );\n    this.onChannelLoaded([channelIndex]);\n  }\n\n  // ASSUMES that this.channelData.options is already set and incoming data is consistent with it\n  /**\n   * Assign volume data as a 3d array ordered x,y,z. The xy size must be equal to tilewidth*tileheight from the imageInfo used to construct this Volume.  Assumes that the incoming data is consistent with the image's pre-existing imageInfo tile metadata.\n   * @param {number} channelIndex\n   * @param {Uint8Array} volumeData\n   */\n  setChannelDataFromVolume(\n    channelIndex: number,\n    volumeData: TypedArray<NumberType>,\n    range: [number, number],\n    dtype: NumberType = \"uint8\"\n  ): void {\n    const { subregionSize, atlasTileDims } = this.imageInfo;\n    this.channels[channelIndex].setFromVolumeData(\n      volumeData,\n      subregionSize.x,\n      subregionSize.y,\n      subregionSize.z,\n      atlasTileDims.x * subregionSize.x,\n      atlasTileDims.y * subregionSize.y,\n      range[0],\n      range[1],\n      dtype\n    );\n    this.onChannelLoaded([channelIndex]);\n  }\n\n  // TODO: decide if this should update imageInfo or not. For now, leave imageInfo alone as the \"original\" data\n  /**\n   * Add a new channel ready to receive data from one of the setChannelDataFrom* calls.\n   * Name and color will be defaulted if not provided. For now, leave imageInfo alone as the \"original\" data\n   * @param {string} name\n   * @param {Array.<number>} color [r,g,b]\n   */\n  appendEmptyChannel(name: string, color?: [number, number, number]): number {\n    const idx = this.imageInfo.numChannels;\n    const chname = name || \"channel_\" + idx;\n    const chcolor = color || getColorByChannelIndex(idx);\n    this.numChannels += 1;\n    this.channelNames.push(chname);\n    this.channelColorsDefault.push(chcolor);\n\n    this.channels.push(new Channel(chname));\n\n    for (let i = 0; i < this.volumeDataObservers.length; ++i) {\n      this.volumeDataObservers[i].onVolumeChannelAdded(this, idx);\n    }\n\n    return idx;\n  }\n\n  /**\n   * Get a value from the volume data\n   * @return {number} the intensity value from the given channel at the given xyz location\n   * @param {number} c The channel index\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  getIntensity(c: number, x: number, y: number, z: number): number {\n    return this.channels[c].getIntensity(x, y, z);\n  }\n\n  /**\n   * Get the 256-bin histogram for the given channel\n   * @return {Histogram} the histogram\n   * @param {number} c The channel index\n   */\n  getHistogram(c: number): Histogram {\n    return this.channels[c].getHistogram();\n  }\n\n  /**\n   * Set the lut for the given channel\n   * @param {number} c The channel index\n   * @param {Array.<number>} lut The lut as a 256 element array\n   */\n  setLut(c: number, lut: Lut): void {\n    this.channels[c].setLut(lut);\n  }\n\n  /**\n   * Set the color palette for the given channel\n   * @param {number} c The channel index\n   * @param {Array.<number>} palette The colors as a 256 element array * RGBA\n   */\n  setColorPalette(c: number, palette: Uint8Array): void {\n    this.channels[c].setColorPalette(palette);\n  }\n\n  /**\n   * Set the color palette alpha multiplier for the given channel.\n   * This will blend between the ordinary color lut and this colorPalette lut.\n   * @param {number} c The channel index\n   * @param {number} alpha The alpha value as a number from 0 to 1\n   */\n  setColorPaletteAlpha(c: number, alpha: number): void {\n    this.channels[c].setColorPaletteAlpha(alpha);\n  }\n\n  /**\n   * Return the intrinsic rotation associated with this volume (radians)\n   * @return {Array.<number>} the xyz Euler angles (radians)\n   */\n  getRotation(): [number, number, number] {\n    // default axis order is XYZ\n    return this.imageInfo.transform.rotation.toArray();\n  }\n\n  /**\n   * Return the intrinsic translation (pivot center delta) associated with this volume, in normalized volume units\n   * @return {Array.<number>} the xyz translation in normalized volume units\n   */\n  getTranslation(): [number, number, number] {\n    return this.voxelsToWorldSpace(this.imageInfo.transform.translation.toArray());\n  }\n\n  /**\n   * Return a translation in normalized volume units, given a translation in image voxels\n   * @return {Array.<number>} the xyz translation in normalized volume units\n   */\n  voxelsToWorldSpace(xyz: [number, number, number]): [number, number, number] {\n    // ASSUME: xyz is in original (level 0) image voxels, compatible with physicalPixelSize.\n    // account for pixel_size and normalized scaling in the threejs volume representation we're using\n    const m = 1.0 / Math.max(this.physicalSize.x, Math.max(this.physicalSize.y, this.physicalSize.z));\n    return new Vector3().fromArray(xyz).multiply(this.physicalPixelSize).multiplyScalar(m).toArray();\n  }\n\n  addVolumeDataObserver(o: VolumeDataObserver): void {\n    this.volumeDataObservers.push(o);\n  }\n\n  removeVolumeDataObserver(o: VolumeDataObserver): void {\n    if (o) {\n      const i = this.volumeDataObservers.indexOf(o);\n      if (i !== -1) {\n        this.volumeDataObservers.splice(i, 1);\n      }\n    }\n  }\n\n  removeAllVolumeDataObservers(): void {\n    this.volumeDataObservers = [];\n  }\n}\n","type MaybeCacheEntry = CacheEntry | null;\ntype CacheEntry = {\n  /** The data contained in this entry */\n  data: ArrayBuffer;\n  /** The previous entry in the LRU list (more recently used) */\n  prev: MaybeCacheEntry;\n  /** The next entry in the LRU list (less recently used) */\n  next: MaybeCacheEntry;\n  /** The key which indexes this entry */\n  key: string;\n};\n\n/** Default: 250MB. Should be large enough to be useful but safe for most any computer that can run the app */\nconst CACHE_MAX_SIZE_DEFAULT = 250_000_000;\n\nexport default class VolumeCache {\n  private entries: Map<string, CacheEntry>;\n\n  public readonly maxSize: number;\n  private currentSize: number;\n\n  // Ends of a linked list of entries, to track LRU and evict efficiently\n  private first: MaybeCacheEntry;\n  private last: MaybeCacheEntry;\n  // TODO implement some way to manage used vs unused (prefetched) entries so\n  // that prefetched entries which are never used don't get highest priority!\n\n  constructor(maxSize = CACHE_MAX_SIZE_DEFAULT) {\n    this.entries = new Map();\n    this.maxSize = maxSize;\n    this.currentSize = 0;\n\n    this.first = null;\n    this.last = null;\n  }\n\n  // Hide these behind getters so they're definitely never set from the outside\n  /** The size of all data arrays currently stored in this cache, in bytes. */\n  public get size() {\n    return this.currentSize;\n  }\n\n  /** The number of entries currently stored in this cache. */\n  public get numberOfEntries() {\n    return this.entries.size;\n  }\n\n  /**\n   * Removes an entry from a store but NOT the LRU list.\n   * Only call from a method with the word \"evict\" in it!\n   */\n  private removeEntryFromStore(entry: CacheEntry): void {\n    this.entries.delete(entry.key);\n    this.currentSize -= entry.data.byteLength;\n  }\n\n  /**\n   * Removes an entry from the LRU list but NOT its store.\n   * Entry must be replaced in list or removed from store, or it will never be evicted!\n   */\n  private removeEntryFromList(entry: CacheEntry): void {\n    const { prev, next } = entry;\n\n    if (prev) {\n      prev.next = next;\n    } else {\n      this.first = next;\n    }\n\n    if (next) {\n      next.prev = prev;\n    } else {\n      this.last = prev;\n    }\n  }\n\n  /** Adds an entry which is *not currently in the list* to the front of the list. */\n  private addEntryAsFirst(entry: CacheEntry): void {\n    if (this.first) {\n      this.first.prev = entry;\n    } else {\n      this.last = entry;\n    }\n    entry.next = this.first;\n    entry.prev = null;\n    this.first = entry;\n  }\n\n  /** Moves an entry which is *currently in the list* to the front of the list. */\n  private moveEntryToFirst(entry: CacheEntry): void {\n    if (entry === this.first) return;\n    this.removeEntryFromList(entry);\n    this.addEntryAsFirst(entry);\n  }\n\n  /** Evicts the least recently used entry from the cache. */\n  private evictLast(): void {\n    if (!this.last) {\n      console.error(\"VolumeCache: attempt to evict last entry from cache when no last entry is set\");\n      return;\n    }\n\n    this.removeEntryFromStore(this.last);\n\n    if (this.last.prev) {\n      this.last.prev.next = null;\n    }\n    this.last = this.last.prev;\n  }\n\n  /** Evicts a specific entry from the cache. */\n  private evict(entry: CacheEntry): void {\n    this.removeEntryFromStore(entry);\n    this.removeEntryFromList(entry);\n  }\n\n  /**\n   * Adds a new entry to the cache.\n   * @returns {boolean} a boolean indicating whether the insertion succeeded.\n   */\n  public insert(key: string, data: ArrayBuffer): boolean {\n    if (data.byteLength > this.maxSize) {\n      console.error(\"VolumeCache: attempt to insert a single entry larger than the cache\");\n      return false;\n    }\n\n    // Check if entry is already in cache\n    // This will move the entry to the front of the LRU list, if present\n    const getResult = this.getEntry(key);\n    if (getResult !== undefined) {\n      getResult.data = data;\n      return true;\n    }\n\n    // Add new entry to cache\n    const newEntry: CacheEntry = { data, prev: null, next: null, key };\n    this.addEntryAsFirst(newEntry);\n    this.entries.set(key, newEntry);\n    this.currentSize += data.byteLength;\n\n    // Evict until size is within limit\n    while (this.currentSize > this.maxSize) {\n      this.evictLast();\n    }\n    return true;\n  }\n\n  /** Internal implementation of `get`. Returns all entry metadata, not just the raw data. */\n  private getEntry(key: string): CacheEntry | undefined {\n    const result = this.entries.get(key);\n    if (result) {\n      this.moveEntryToFirst(result);\n    }\n    return result;\n  }\n\n  /** Attempts to get a single entry from the cache. */\n  public get(key: string): ArrayBuffer | undefined {\n    return this.getEntry(key)?.data;\n  }\n\n  /** Clears all cache entries whose keys begin with the specified prefix. */\n  public clearWithPrefix(prefix: string): void {\n    for (const [key, entry] of this.entries.entries()) {\n      if (key.startsWith(prefix)) {\n        this.evict(entry);\n      }\n    }\n  }\n\n  /** Clears all data from the cache. */\n  public clear(): void {\n    while (this.last) {\n      this.evictLast();\n    }\n  }\n}\n","import { type NumberType } from \"./types.js\";\nimport { Vector3 } from \"three\";\n\nexport type VolumeDims = {\n  // shape: [t, c, z, y, x]\n  shape: [number, number, number, number, number];\n  // spacing: [t, c, z, y, x]; generally expect 1 for non-spatial dimensions\n  spacing: [number, number, number, number, number];\n  spaceUnit: string;\n  /**\n   * Symbol of temporal unit used by `spacing[0]`, e.g. \"hr\".\n   *\n   * If units match one of the following, the viewer will automatically format\n   * timestamps to a d:hh:mm:ss.sss format, truncated as an integer of the unit specified.\n   * See https://ngff.openmicroscopy.org/latest/index.html#axes-md for a list of valid time units.\n   * - \"ms\", \"millisecond\" for milliseconds: `d:hh:mm:ss.sss`\n   * - \"s\", \"sec\", \"second\", or \"seconds\" for seconds: `d:hh:mm:ss`\n   * - \"m\", \"min\", \"minute\", or \"minutes\" for minutes: `d:hh:mm`\n   * - \"h\", \"hr\", \"hour\", or \"hours\" for hours: `d:hh`\n   * - \"d\", \"day\", or \"days\" for days: `d`\n   *\n   * The maximum timestamp value is used to determine the maximum unit shown.\n   * For example, if the time unit is in seconds, and the maximum time is 90 seconds, the timestamp\n   * will be formatted as \"{m:ss} (m:s)\", and the day and hour segments will be omitted.\n   */\n  timeUnit: string;\n  dataType: NumberType;\n};\n\nexport function defaultVolumeDims(): VolumeDims {\n  return {\n    shape: [0, 0, 0, 0, 0],\n    spacing: [1, 1, 1, 1, 1],\n    spaceUnit: \"μm\",\n    timeUnit: \"s\",\n    dataType: \"uint8\",\n  };\n}\n\nexport function volumeSize(volumeDims: VolumeDims): Vector3 {\n  return new Vector3(volumeDims.shape[4], volumeDims.shape[3], volumeDims.shape[2]);\n}\n\nexport function physicalPixelSize(volumeDims: VolumeDims): Vector3 {\n  return new Vector3(volumeDims.spacing[4], volumeDims.spacing[3], volumeDims.spacing[2]);\n}\n","import { Euler, Vector2, Vector3 } from \"three\";\n\nimport Volume from \"./Volume.js\";\nimport type { Bounds } from \"./types.js\";\n\n/**\n * Marks groups of related settings that may have changed.\n */\nexport enum SettingsFlags {\n  /** parameters: translation, rotation, scale, flipAxes */\n  TRANSFORM = 0b000000001,\n  /** parameters: gammaMin, gammaLevel, gammaMax, brightness*/\n  CAMERA = 0b000000010,\n  /** parameters: showBoundingBox, boundingBoxColor */\n  BOUNDING_BOX = 0b000000100,\n  /** parameters: bounds, zSlice */\n  ROI = 0b000001000,\n  /** parameters: maskAlpha */\n  MASK_ALPHA = 0b000010000,\n  /** parameters: density, diffuse, specular, emissive, glossiness */\n  MATERIAL = 0b000100000,\n  /** parameters: resolution, useInterpolation, pixelSamplingRate, primaryRayStepSize, secondaryRayStepSize*/\n  SAMPLING = 0b001000000,\n  /** parameters: isOrtho, orthoScale, viewAxis, visible, maxProjectMode */\n  VIEW = 0b010000000,\n  /** parameters: maskChannelIndex */\n  MASK_DATA = 0b100000000,\n  ALL = 0b1111111111,\n}\n\nexport enum Axis {\n  X = \"x\",\n  Y = \"y\",\n  Z = \"z\",\n  /** Alias for NONE, indicates 3D mode */\n  XYZ = \"\",\n  /** No current axis, indicates 3D mode */\n  NONE = \"\",\n}\n\n/**\n * Holds shared settings for configuring `VolumeRenderImpl` instances.\n */\nexport class VolumeRenderSettings {\n  // TRANSFORM\n  public translation: Vector3;\n  public rotation: Euler;\n  public scale: Vector3;\n  // TODO made redundant by `scale`?\n  public flipAxes: Vector3;\n\n  // VIEW\n  public isOrtho: boolean;\n  public orthoScale: number;\n  public viewAxis: Axis;\n  public visible: boolean;\n  public maxProjectMode: boolean;\n  // CAMERA\n  public gammaMin: number;\n  public gammaLevel: number;\n  public gammaMax: number;\n  public brightness: number;\n\n  // MASK\n  public maskChannelIndex: number;\n  public maskAlpha: number;\n\n  // MATERIAL\n  public density: number;\n  public diffuse: [number, number, number][];\n  public specular: [number, number, number][];\n  public emissive: [number, number, number][];\n  public glossiness: number[];\n\n  // ROI\n  public bounds: Bounds;\n  public zSlice: number;\n\n  // BOUNDING_BOX\n  public showBoundingBox: boolean;\n  public boundingBoxColor: [number, number, number];\n\n  // SAMPLING\n  public resolution: Vector2;\n  public useInterpolation: boolean;\n  public pixelSamplingRate: number;\n  public primaryRayStepSize: number;\n  public secondaryRayStepSize: number;\n\n  /**\n   * Creates a new VolumeRenderSettings object with default fields.\n   * @param volume Optional volume data parameter used to initialize size-dependent settings.\n   */\n  constructor(volume?: Volume) {\n    this.translation = new Vector3(0, 0, 0);\n    this.rotation = new Euler();\n    this.scale = new Vector3(1, 1, 1);\n    this.isOrtho = false;\n    this.viewAxis = Axis.NONE;\n    this.orthoScale = 1.0;\n    this.flipAxes = new Vector3(1, 1, 1);\n    this.maskChannelIndex = -1;\n    this.maskAlpha = 1.0;\n    this.gammaMin = 0.0;\n    this.gammaLevel = 1.0;\n    this.gammaMax = 1.0;\n    this.density = 0;\n    this.brightness = 0;\n    this.showBoundingBox = false;\n    this.bounds = {\n      bmin: new Vector3(-0.5, -0.5, -0.5),\n      bmax: new Vector3(0.5, 0.5, 0.5),\n    };\n    this.boundingBoxColor = [1.0, 1.0, 0.0];\n    this.primaryRayStepSize = 1.0;\n    this.secondaryRayStepSize = 1.0;\n    this.useInterpolation = true;\n    this.visible = true;\n    this.maxProjectMode = false;\n    // volume-dependent properties\n    if (volume) {\n      this.zSlice = Math.floor(volume.imageInfo.subregionSize.z / 2);\n      this.diffuse = new Array(volume.imageInfo.numChannels).fill([255, 255, 255]);\n      this.specular = new Array(volume.imageInfo.numChannels).fill([0, 0, 0]);\n      this.emissive = new Array(volume.imageInfo.numChannels).fill([0, 0, 0]);\n      this.glossiness = new Array(volume.imageInfo.numChannels).fill(0);\n    } else {\n      this.zSlice = 0;\n      this.diffuse = [[255, 255, 255]];\n      this.specular = [[0, 0, 0]];\n      this.emissive = [[0, 0, 0]];\n      this.glossiness = [0];\n    }\n    this.pixelSamplingRate = 0.75;\n    this.resolution = new Vector2(1, 1);\n  }\n\n  public resizeWithVolume(volume: Volume): void {\n    this.zSlice = Math.floor(volume.imageInfo.subregionSize.z / 2);\n    this.diffuse = new Array(volume.imageInfo.numChannels).fill([255, 255, 255]);\n    this.specular = new Array(volume.imageInfo.numChannels).fill([0, 0, 0]);\n    this.emissive = new Array(volume.imageInfo.numChannels).fill([0, 0, 0]);\n    this.glossiness = new Array(volume.imageInfo.numChannels).fill(0);\n  }\n\n  /**\n   * Recursively compares two arrays.\n   * Non-array elements are compared using strict equality comparison.\n   */\n  private static compareArray(a1: unknown[], a2: unknown[]): boolean {\n    if (a1.length !== a2.length) {\n      return false;\n    }\n    for (let i = 0; i < a1.length; i++) {\n      const elem1 = a1[i];\n      const elem2 = a2[i];\n      if (elem1 instanceof Array && elem2 instanceof Array) {\n        if (!this.compareArray(elem1, elem2)) {\n          return false;\n        }\n      } else if (elem1 !== elem2) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Compares two VolumeRenderSettings objects.\n   * @returns true if both objects have identical settings.\n   */\n  public isEqual(o2: VolumeRenderSettings): boolean {\n    for (const key of Object.keys(this)) {\n      const v1 = this[key];\n      const v2 = o2[key];\n      if (v1 instanceof Array) {\n        if (!VolumeRenderSettings.compareArray(v1, v2)) {\n          return false;\n        }\n      } else if (v1 && v1.bmin !== undefined) {\n        // Bounds object\n        const bounds1 = v1 as Bounds;\n        const bounds2 = v2 as Bounds;\n        if (!bounds1.bmin.equals(bounds2.bmin) || !bounds1.bmax.equals(bounds2.bmax)) {\n          return false;\n        }\n      } else if (v1 instanceof Vector3 || v1 instanceof Vector2 || v1 instanceof Euler) {\n        if (!v1.equals(v2)) {\n          return false;\n        }\n      } else {\n        // number, boolean, string\n        if (v1 !== v2) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Recursively creates and returns a deep copy of an array.\n   * Note: assumes values in the array are either primitives (numbers) or arrays of primitives.\n   */\n  private static deepCopyArray(a: unknown[]): unknown[] {\n    const b: unknown[] = new Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n      const val = a[i];\n      if (val instanceof Array) {\n        b[i] = this.deepCopyArray(val);\n      } else {\n        b[i] = val;\n      }\n    }\n    return b;\n  }\n\n  /**\n   * Creates a deep copy of this VolumeRenderSettings object.\n   * @param src The object to create a clone of.\n   * @returns a new VolumeRenderSettings object with identical fields that do not\n   * share references with the original settings object.\n   */\n  public clone(): VolumeRenderSettings {\n    const dst = new VolumeRenderSettings(); // initialize with empty volume\n    for (const key of Object.keys(this)) {\n      const val = this[key];\n      if (val instanceof Array) {\n        dst[key] = VolumeRenderSettings.deepCopyArray(val);\n      } else if (key === \"bounds\") {\n        // must use key string here because Bounds is a type alias and not a class\n        dst.bounds.bmax = this.bounds.bmax.clone();\n        dst.bounds.bmin = this.bounds.bmin.clone();\n      } else if (val instanceof Vector3 || val instanceof Vector2 || val instanceof Euler) {\n        dst[key] = val.clone();\n      } else if (val instanceof String) {\n        dst[key] = \"\" + val;\n      } else {\n        // boolean, number, other primitives\n        dst[key] = val;\n      }\n    }\n    return dst;\n  }\n}\n","export const defaultColors: [number, number, number][] = [\n  [255, 0, 255],\n  [255, 255, 255],\n  [0, 255, 255],\n];\n\ninterface HSVColor {\n  h: number;\n  s: number;\n  v: number;\n}\n// 0 <= (h, s, v) <= 1\n// returns 0 <= (r, g, b) <= 255 rounded to nearest integer\n// you can also pass in just one arg as an object of {h, s, v} props.\nfunction HSVtoRGB(h: number | HSVColor, s: number, v: number): [number, number, number] {\n  let r, g, b;\n  let hh = 0;\n  if (arguments.length === 1) {\n    const hsv = h as HSVColor;\n    (s = hsv.s), (v = hsv.v), (hh = hsv.h);\n  } else {\n    hh = h as number;\n  }\n  const i = Math.floor(hh * 6);\n  const f = hh * 6 - i;\n  const p = v * (1 - s);\n  const q = v * (1 - f * s);\n  const t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n    case 0:\n      (r = v), (g = t), (b = p);\n      break;\n    case 1:\n      (r = q), (g = v), (b = p);\n      break;\n    case 2:\n      (r = p), (g = v), (b = t);\n      break;\n    case 3:\n      (r = p), (g = q), (b = v);\n      break;\n    case 4:\n      (r = t), (g = p), (b = v);\n      break;\n    case 5:\n      (r = v), (g = p), (b = q);\n      break;\n  }\n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n\n// 1993 Park-Miller LCG\nfunction LCG(s) {\n  return function () {\n    s = Math.imul(48271, s) | 0 % 2147483647;\n    return (s & 2147483647) / 2147483648;\n  };\n}\n// Use it like so:\nconst myrand = LCG(123);\n\n// if index exceeds defaultColors start choosing random ones\n// returns [r,g,b] 0-255 range\nexport const getColorByChannelIndex = (index: number): [number, number, number] => {\n  if (!defaultColors[index]) {\n    defaultColors[index] = HSVtoRGB(myrand(), myrand() * 0.5 + 0.5, myrand() * 0.5 + 0.5);\n  }\n  return defaultColors[index];\n};\n","export const enum TimeUnit {\n  MILLISECOND,\n  SECOND,\n  MINUTE,\n  HOUR,\n  DAY,\n}\n\nconst recognizedTimeUnits: Record<TimeUnit, Set<string>> = {\n  [TimeUnit.MILLISECOND]: new Set([\"ms\", \"millisecond\", \"milliseconds\"]),\n  [TimeUnit.SECOND]: new Set([\"s\", \"sec\", \"second\", \"seconds\"]),\n  [TimeUnit.MINUTE]: new Set([\"m\", \"min\", \"minute\", \"minutes\"]),\n  [TimeUnit.HOUR]: new Set([\"h\", \"hr\", \"hour\", \"hours\"]),\n  [TimeUnit.DAY]: new Set([\"d\", \"day\", \"days\"]),\n};\n\n/**\n * Parses an OME-compatible time unit into a TimeUnit enum.\n * @param unit string unit\n * @returns\n * - `TimeUnit.MILLISECOND` if unit is \"ms\", \"millisecond\", or \"milliseconds\"\n * - `TimeUnit.SECOND` if unit is \"s\", \"sec\", \"second\", or \"seconds\"\n * - `TimeUnit.MINUTE` if unit is \"m\", \"min\", \"minute\", or \"minutes\"\n * - `TimeUnit.HOUR` if unit is \"h\", \"hr\", \"hour\", or \"hours\"\n * - `TimeUnit.DAY` if unit is \"d\", \"day\", or \"days\"\n * - `undefined` if unit is not recognized\n */\nexport function parseTimeUnit(unit: string): TimeUnit | undefined {\n  for (const [timeUnit, recognizedUnits] of Object.entries(recognizedTimeUnits)) {\n    if (recognizedUnits.has(unit)) {\n      return timeUnit as unknown as TimeUnit;\n    }\n  }\n}\n","import { Box3, Vector3 } from \"three\";\n\nimport Volume from \"../Volume.js\";\nimport type { VolumeDims } from \"../VolumeDims.js\";\nimport { CImageInfo, type ImageInfo } from \"../ImageInfo.js\";\nimport { TypedArray, NumberType } from \"../types.js\";\nimport { buildDefaultMetadata } from \"./VolumeLoaderUtils.js\";\nimport { PrefetchDirection } from \"./zarr_utils/types.js\";\nimport { ZarrLoaderFetchOptions } from \"./OmeZarrLoader.js\";\n\nexport class LoadSpec {\n  time = 0;\n  /** The max size of a volume atlas that may be produced by a load. Used to pick the appropriate multiscale level. */\n  maxAtlasEdge?: number;\n  /** An optional bias added to the scale level index after the optimal level is picked based on `maxAtlasEdge`. */\n  scaleLevelBias?: number;\n  /**\n   * The max scale level to load. Even when this is specified, the loader may pick a *lower* scale level based on\n   * limits imposed by `scaleLevelBias` and `maxAtlasEdge` (or their defaults if unspecified).\n   */\n  multiscaleLevel?: number;\n  /** Subregion of volume to load. If not specified, the entire volume is loaded. Specify as floats between 0-1. */\n  subregion = new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1));\n  channels?: number[];\n  /** Treat multiscaleLevel literally and don't use other constraints to change it.\n   * By default we will try to load the best level based on the maxAtlasEdge and scaleLevelBias,\n   * so this is false.\n   */\n  useExplicitLevel = false;\n}\n\nexport function loadSpecToString(spec: LoadSpec): string {\n  const { min, max } = spec.subregion;\n  return `${spec.multiscaleLevel}:${spec.time}:x(${min.x},${max.x}):y(${min.y},${max.y}):z(${min.z},${max.z})`;\n}\n\nexport type LoadedVolumeInfo = {\n  imageInfo: ImageInfo;\n  loadSpec: LoadSpec;\n};\n\n/**\n * @callback PerChannelCallback\n * @param {string} imageurl\n * @param {Volume} volume\n * @param {number} channelindex\n */\nexport type PerChannelCallback = (volume: Volume, channelIndex: number) => void;\n\n/**\n * @callback RawChannelDataCallback - allow lists of channel indices and data arrays to be passed to the callback\n * @param {number[]} channelIndex - The indices of the channels that were loaded\n * @param {NumberType[]} dtype - The data type of the data arrays\n * @param {TypedArray<NumberType>[]} data - The raw data for each channel\n * @param {[number, number][]} ranges - The min and max values for each channel in their original range\n * @param {[number, number]} atlasDims - The dimensions of the atlas, if the data is in an atlas format\n */\nexport type RawChannelDataCallback = (\n  channelIndex: number[],\n  dtype: NumberType[],\n  data: TypedArray<NumberType>[],\n  ranges: [number, number][],\n  atlasDims?: [number, number]\n) => void;\n\n/**\n * Loads volume data from a source specified by a `LoadSpec`.\n *\n * Loaders may keep state for reuse between volume creation and volume loading, and should be kept alive until volume\n * loading is complete. (See `createVolume`)\n */\nexport interface IVolumeLoader {\n  /** Use VolumeDims to further refine a `LoadSpec` for use in `createVolume` */\n  loadDims(loadSpec: LoadSpec): Promise<VolumeDims[]>;\n\n  /**\n   * Create an empty `Volume` from a `LoadSpec`, which must be passed to `loadVolumeData` to begin loading.\n   * Optionally pass a callback to respond whenever new channel data is loaded into the volume.\n   */\n  createVolume(loadSpec: LoadSpec, onChannelLoaded?: PerChannelCallback): Promise<Volume>;\n\n  /**\n   * Begin loading a volume's data, as specified in its `LoadSpec`.\n   *\n   * Pass a callback to respond when this request loads a new channel. This callback will execute after the one\n   * assigned in `createVolume`, if any.\n   *\n   * The returned `Promise` resolves once all channels load, or rejects with any error that occurs during loading.\n   */\n  // TODO make this return a promise that resolves when loading is done?\n  // TODO this is not cancellable in the sense that any async requests initiated here are not stored\n  // in a way that they can be interrupted.\n  // TODO explicitly passing a `LoadSpec` is now rarely useful. Remove?\n  loadVolumeData(volume: Volume, loadSpec?: LoadSpec, onChannelLoaded?: PerChannelCallback): Promise<void>;\n\n  /** Change which directions to prioritize when prefetching. Currently only implemented on `OMEZarrLoader`. */\n  setPrefetchPriority(directions: PrefetchDirection[]): void;\n\n  /**\n   * By default channel data can arrive out of order and at different times.\n   * This can cause the rendering to update in a way that is not visually appealing.\n   * In particular, during time series playback or Z slice playback, we would like\n   * to see all channels update at the same time.\n   * @param sync Set true to force all requested channels to load at the same time\n   */\n  syncMultichannelLoading(sync: boolean): void;\n}\n\n/** Abstract class which allows loaders to accept and return types that are easier to transfer to/from a worker. */\nexport abstract class ThreadableVolumeLoader implements IVolumeLoader {\n  /** Unchanged from `IVolumeLoader`. See that interface for details. */\n  abstract loadDims(loadSpec: LoadSpec): Promise<VolumeDims[]>;\n\n  /**\n   * Creates an `ImageInfo` object from a `LoadSpec`, which may be passed to the `Volume` constructor to create an\n   * empty volume that can accept data loaded with the given `LoadSpec`.\n   *\n   * Also returns a new `LoadSpec` that may have been modified from the input `LoadSpec` to reflect the constraints or\n   * abilities of the loader. This new `LoadSpec` should be used when constructing the `Volume`, _not_ the original.\n   */\n  abstract createImageInfo(loadSpec: LoadSpec): Promise<LoadedVolumeInfo>;\n\n  /**\n   * Begins loading per-channel data for the volume specified by `imageInfo` and `loadSpec`.\n   *\n   * This function accepts two required callbacks. The first, `onUpdateVolumeMetadata`, should be called at most once\n   * to modify the `Volume`'s `imageInfo` and/or `loadSpec` properties based on changes made by this load. Actual\n   * loaded channel data is passed to `onData` as it is loaded.\n   *\n   * Depending on the loader, the array passed to `onData` may be in simple 3d dimension order or reflect a 2d atlas.\n   * If the latter, the dimensions of the atlas are passed as the third argument to `onData`.\n   *\n   * The returned promise should resolve when all data has been loaded, or reject if any error occurs while loading.\n   */\n  abstract loadRawChannelData(\n    imageInfo: ImageInfo,\n    loadSpec: LoadSpec,\n    onUpdateVolumeMetadata: (imageInfo?: ImageInfo, loadSpec?: LoadSpec) => void,\n    onData: RawChannelDataCallback\n  ): Promise<void>;\n\n  setPrefetchPriority(_directions: PrefetchDirection[]): void {\n    // no-op by default\n  }\n\n  syncMultichannelLoading(_sync: boolean): void {\n    // default behavior is async, to update channels as they arrive, depending on each\n    // loader's implementation details.\n  }\n\n  updateFetchOptions(_options: Partial<ZarrLoaderFetchOptions>): void {\n    // no-op by default\n  }\n\n  async createVolume(loadSpec: LoadSpec, onChannelLoaded?: PerChannelCallback): Promise<Volume> {\n    const { imageInfo, loadSpec: adjustedLoadSpec } = await this.createImageInfo(loadSpec);\n    const vol = new Volume(imageInfo, adjustedLoadSpec, this);\n    vol.channelLoadCallback = onChannelLoaded;\n    vol.imageMetadata = buildDefaultMetadata(imageInfo);\n    return vol;\n  }\n\n  async loadVolumeData(\n    volume: Volume,\n    loadSpecOverride?: LoadSpec,\n    onChannelLoaded?: PerChannelCallback\n  ): Promise<void> {\n    const onUpdateMetadata = (imageInfo?: ImageInfo, loadSpec?: LoadSpec): void => {\n      if (imageInfo) {\n        volume.imageInfo = new CImageInfo(imageInfo);\n        volume.updateDimensions();\n      }\n      volume.loadSpec = { ...loadSpec, ...spec };\n    };\n\n    const onChannelData: RawChannelDataCallback = (channelIndices, dtypes, dataArrays, ranges, atlasDims) => {\n      for (let i = 0; i < channelIndices.length; i++) {\n        const channelIndex = channelIndices[i];\n        const dtype = dtypes[i];\n        const data = dataArrays[i];\n        const range = ranges[i];\n        if (atlasDims) {\n          volume.setChannelDataFromAtlas(channelIndex, data, atlasDims[0], atlasDims[1], range, dtype);\n        } else {\n          volume.setChannelDataFromVolume(channelIndex, data, range, dtype);\n        }\n        onChannelLoaded?.(volume, channelIndex);\n      }\n    };\n\n    const spec = { ...volume.loadSpec, ...loadSpecOverride };\n    return this.loadRawChannelData(volume.imageInfo.imageInfo, spec, onUpdateMetadata, onChannelData);\n  }\n}\n","import { Box3, Vector3 } from \"three\";\n\nimport {\n  ThreadableVolumeLoader,\n  type LoadSpec,\n  type RawChannelDataCallback,\n  type LoadedVolumeInfo,\n} from \"./IVolumeLoader.js\";\nimport { computeAtlasSize, type ImageInfo } from \"../ImageInfo.js\";\nimport type { VolumeDims } from \"../VolumeDims.js\";\nimport VolumeCache from \"../VolumeCache.js\";\nimport type { TypedArray, NumberType } from \"../types.js\";\nimport { getDataRange } from \"../utils/num_utils.js\";\n\ninterface PackedChannelsImage {\n  name: string;\n  channels: number[];\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\ntype JsonImageInfo = {\n  name: string;\n  version?: string;\n  images: PackedChannelsImage[];\n\n  /** X size of the *original* (not downsampled) volume, in pixels */\n  width: number;\n  /** Y size of the *original* (not downsampled) volume, in pixels */\n  height: number;\n  /** Number of rows of z-slice tiles (not pixels) in the texture atlas */\n  rows: number;\n  /** Number of columns of z-slice tiles (not pixels) in the texture atlas */\n  cols: number;\n  /** Width of a single atlas tile in pixels */\n  tile_width: number;\n  /** Height of a single atlas tile in pixels */\n  tile_height: number;\n  /** Width of the texture atlas in pixels; equivalent to `tile_width * cols` */\n  atlas_width: number;\n  /** Height of the texture atlas in pixels; equivalent to `tile_height * rows` */\n  atlas_height: number;\n  /** Number of tiles in the texture atlas (or number of z-slices in the volume segment) */\n  tiles: number;\n  /** Physical x size of a single *original* (not downsampled) pixel */\n  pixel_size_x: number;\n  /** Physical y size of a single *original* (not downsampled) pixel */\n  pixel_size_y: number;\n  /** Physical z size of a single pixel */\n  pixel_size_z: number;\n  /** Symbol of physical unit used by `pixel_size_(x|y|z)` fields */\n  pixel_size_unit?: string;\n\n  channels: number;\n  channel_names: string[];\n  channel_colors?: [number, number, number][];\n\n  times?: number;\n  time_scale?: number;\n  time_unit?: string;\n\n  // TODO should be optional?\n  transform: {\n    translation: [number, number, number];\n    rotation: [number, number, number];\n  };\n  userData?: Record<string, unknown>;\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n\nconst rescalePixelSize = (json: JsonImageInfo): [number, number, number] => {\n  // the pixel_size_x/y/z are the physical size of the original pixels represented by\n  // width and height.  We need to get a physical pixel size that is consistent\n  // with the tile_width and tile_height.\n  const px = (json.pixel_size_x * json.width) / json.tile_width;\n  const py = (json.pixel_size_y * json.height) / json.tile_height;\n  const pz = json.pixel_size_z;\n  return [px, py, pz];\n};\n\nconst convertImageInfo = (json: JsonImageInfo): ImageInfo => {\n  const [px, py, pz] = rescalePixelSize(json);\n  // translation is in pixels that are in the space of json.width, json.height.\n  // We need to convert this to the space of the tile_width and tile_height.\n  const tr: [number, number, number] = json.transform?.translation ?? [0, 0, 0];\n  tr[0] = (tr[0] * json.tile_width) / json.width;\n  tr[1] = (tr[1] * json.tile_height) / json.height;\n  return {\n    name: json.name,\n    atlasTileDims: [json.cols, json.rows],\n    subregionSize: [json.tile_width, json.tile_height, json.tiles],\n    subregionOffset: [0, 0, 0],\n    combinedNumChannels: json.channels,\n    channelNames: json.channel_names,\n    channelColors: json.channel_colors,\n    multiscaleLevel: 0,\n    multiscaleLevelDims: [\n      {\n        shape: [json.times || 1, json.channels, json.tiles, json.tile_height, json.tile_width],\n        spacing: [json.time_scale || 1, 1, pz, py, px],\n        spaceUnit: json.pixel_size_unit || \"μm\",\n        timeUnit: json.time_unit || \"s\",\n        dataType: \"uint8\",\n      },\n    ],\n\n    transform: {\n      translation: tr,\n      rotation: json.transform?.rotation ? json.transform.rotation : [0, 0, 0],\n      scale: [1, 1, 1],\n    },\n\n    userData: {\n      ...json.userData,\n      // for metadata display reasons\n      originalVolumeSize: [json.width, json.height, json.tiles],\n      originalPhysicalPixelSize: [json.pixel_size_x, json.pixel_size_y, json.pixel_size_z],\n    },\n  };\n};\n\nclass JsonImageInfoLoader extends ThreadableVolumeLoader {\n  urls: string[];\n  jsonInfo: (JsonImageInfo | undefined)[];\n  syncChannels = false;\n\n  cache?: VolumeCache;\n\n  constructor(urls: string | string[], cache?: VolumeCache) {\n    super();\n\n    if (Array.isArray(urls)) {\n      this.urls = urls;\n    } else {\n      this.urls = [urls];\n    }\n\n    this.jsonInfo = new Array(this.urls.length);\n    this.cache = cache;\n  }\n\n  private async getJsonImageInfo(time: number): Promise<JsonImageInfo> {\n    const cachedInfo = this.jsonInfo[time];\n    if (cachedInfo) {\n      return cachedInfo;\n    }\n\n    const response = await fetch(this.urls[time]);\n    const imageInfo = (await response.json()) as JsonImageInfo;\n\n    imageInfo.pixel_size_unit = imageInfo.pixel_size_unit || \"μm\";\n    imageInfo.times = imageInfo.times || this.urls.length;\n    this.jsonInfo[time] = imageInfo;\n    return imageInfo;\n  }\n\n  syncMultichannelLoading(sync: boolean): void {\n    this.syncChannels = sync;\n  }\n\n  async loadDims(loadSpec: LoadSpec): Promise<VolumeDims[]> {\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n\n    const [px, py, pz] = rescalePixelSize(jsonInfo);\n\n    const d: VolumeDims = {\n      shape: [jsonInfo.times || 1, jsonInfo.channels, jsonInfo.tiles, jsonInfo.tile_height, jsonInfo.tile_width],\n      spacing: [1, 1, pz, py, px],\n      spaceUnit: jsonInfo.pixel_size_unit ?? \"μm\",\n      dataType: \"uint8\",\n      timeUnit: jsonInfo.time_unit ?? \"s\",\n    };\n    return [d];\n  }\n\n  async createImageInfo(loadSpec: LoadSpec): Promise<LoadedVolumeInfo> {\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n    return { imageInfo: convertImageInfo(jsonInfo), loadSpec };\n  }\n\n  async loadRawChannelData(\n    imageInfo: ImageInfo,\n    loadSpec: LoadSpec,\n    onUpdateMetadata: (imageInfo: undefined, loadSpec?: LoadSpec) => void,\n    onData: RawChannelDataCallback\n  ): Promise<void> {\n    // if you need to adjust image paths prior to download,\n    // now is the time to do it.\n    // Try to figure out the urlPrefix from the LoadSpec.\n    // For this format we assume the image data is in the same directory as the json file.\n    const jsonInfo = await this.getJsonImageInfo(loadSpec.time);\n\n    let images = jsonInfo?.images;\n    if (!images) {\n      return;\n    }\n\n    const requestedChannels = loadSpec.channels;\n    if (requestedChannels) {\n      // If only some channels are requested, load only images which contain at least one requested channel\n      images = images.filter(({ channels }) => channels.some((ch) => requestedChannels.includes(ch)));\n    }\n\n    // This regex removes everything after the last slash, so the url had better be simple.\n    const urlPrefix = this.urls[loadSpec.time].replace(/[^/]*$/, \"\");\n    images = images.map((element) => ({ ...element, name: urlPrefix + element.name }));\n\n    // Update `image`'s `loadSpec` before loading\n    const adjustedLoadSpec = {\n      ...loadSpec,\n      // `subregion` and `multiscaleLevel` are unused by this loader\n      subregion: new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1)),\n      multiscaleLevel: 0,\n      // include all channels in any loaded images\n      channels: images.flatMap(({ channels }) => channels),\n    };\n    onUpdateMetadata(undefined, adjustedLoadSpec);\n\n    const [w, h] = computeAtlasSize(imageInfo);\n    const wrappedOnData = (\n      ch: number[],\n      dtype: NumberType[],\n      data: TypedArray<NumberType>[],\n      ranges: [number, number][]\n    ) => onData(ch, dtype, data, ranges, [w, h]);\n    await JsonImageInfoLoader.loadVolumeAtlasData(images, wrappedOnData, this.cache, this.syncChannels);\n  }\n\n  /**\n   * load per-channel volume data from a batch of image files containing the volume slices tiled across the images\n   * @param {Array.<{name:string, channels:Array.<number>}>} imageArray\n   * @param {RawChannelDataCallback} onData Per-channel callback. Called when each channel's atlased volume data is loaded\n   * @param {VolumeCache} cache\n   * @example loadVolumeAtlasData([{\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_0.png\",\n   *     \"channels\": [0, 1, 2]\n   * }, {\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_1.png\",\n   *     \"channels\": [3, 4, 5]\n   * }, {\n   *     \"name\": \"AICS-10_5_5.ome.tif_atlas_2.png\",\n   *     \"channels\": [6, 7, 8]\n   * }], mycallback);\n   */\n  static async loadVolumeAtlasData(\n    imageArray: PackedChannelsImage[],\n    onData: RawChannelDataCallback,\n    cache?: VolumeCache,\n    syncChannels = false\n  ): Promise<void> {\n    const resultChannelIndices: number[] = [];\n    const resultChannelDtype: NumberType[] = [];\n    const resultChannelData: TypedArray<NumberType>[] = [];\n    const resultChannelRanges: [number, number][] = [];\n\n    const imagePromises = imageArray.map(async (image) => {\n      // Because the data is fetched such that one fetch returns a whole batch,\n      // if any in batch is cached then they all should be. So if any in batch is NOT cached,\n      // then we will have to do a batch request. This logic works both ways because it's all or nothing.\n      let cacheHit = true;\n      for (let j = 0; j < Math.min(image.channels.length, 4); ++j) {\n        const chindex = image.channels[j];\n        const cacheResult = cache?.get(`${image.name}/${chindex}`);\n        if (cacheResult) {\n          // all data coming from this loader is natively 8-bit\n          const channelData = new Uint8Array(cacheResult);\n          if (syncChannels) {\n            // if we are synchronizing channels, we need to keep track of the data\n            resultChannelIndices.push(chindex);\n            resultChannelDtype.push(\"uint8\");\n            resultChannelData.push(channelData);\n            resultChannelRanges.push(getDataRange(channelData));\n          } else {\n            onData([chindex], [\"uint8\"], [channelData], [getDataRange(channelData)]);\n          }\n        } else {\n          cacheHit = false;\n          // we can stop checking because we know we are going to have to fetch the whole batch\n          break;\n        }\n      }\n\n      // if all channels were in cache then we can move on to the next\n      // image (batch) without requesting\n      if (cacheHit) {\n        return;\n      }\n\n      const response = await fetch(image.name, { mode: \"cors\" });\n      const blob = await response.blob();\n      const bitmap = await createImageBitmap(blob);\n\n      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n      const ctx = canvas.getContext(\"2d\") as OffscreenCanvasRenderingContext2D | null;\n      if (!ctx) {\n        console.log(\"Error creating canvas 2d context for \" + image.name);\n        return;\n      }\n      ctx.globalCompositeOperation = \"copy\";\n      ctx.globalAlpha = 1.0;\n      ctx.drawImage(bitmap, 0, 0);\n      const iData = ctx.getImageData(0, 0, bitmap.width, bitmap.height);\n\n      const channelsBits: Uint8Array[] = [];\n      const length = bitmap.width * bitmap.height;\n\n      // allocate channels in batch\n      for (let ch = 0; ch < Math.min(image.channels.length, 4); ++ch) {\n        channelsBits.push(new Uint8Array(length));\n      }\n\n      // extract the data\n      const channelRange: [number, number][] = [];\n      for (let j = 0; j < Math.min(image.channels.length, 4); ++j) {\n        let rawMin = Infinity;\n        let rawMax = -Infinity;\n        for (let px = 0; px < length; px++) {\n          channelsBits[j][px] = iData.data[px * 4 + j];\n          rawMin = Math.min(rawMin, channelsBits[j][px]);\n          rawMax = Math.max(rawMax, channelsBits[j][px]);\n        }\n        channelRange[j] = [rawMin, rawMax];\n      }\n\n      // done with `iData` and `canvas` now.\n\n      for (let ch = 0; ch < Math.min(image.channels.length, 4); ++ch) {\n        const chindex = image.channels[ch];\n        cache?.insert(`${image.name}/${chindex}`, channelsBits[ch]);\n        // NOTE: the atlas dimensions passed in here are currently unused by `JSONImageInfoLoader`\n        // all data coming from this loader is natively 8-bit\n        if (syncChannels) {\n          resultChannelIndices.push(chindex);\n          resultChannelDtype.push(\"uint8\");\n          resultChannelData.push(channelsBits[ch]);\n          resultChannelRanges.push(channelRange[ch]);\n        } else {\n          onData([chindex], [\"uint8\"], [channelsBits[ch]], [channelRange[ch]], [bitmap.width, bitmap.height]);\n        }\n      }\n    });\n\n    await Promise.all(imagePromises);\n    if (syncChannels) {\n      onData(resultChannelIndices, resultChannelDtype, resultChannelData, resultChannelRanges);\n    }\n  }\n}\n\nexport { JsonImageInfoLoader };\n","import { Box3, Vector3 } from \"three\";\n\nimport * as zarr from \"@zarrita/core\";\nimport { get as zarrGet, slice, Slice } from \"@zarrita/indexing\";\nimport { AbsolutePath } from \"@zarrita/storage\";\n// Importing `FetchStore` from its home subpackage (@zarrita/storage) causes errors.\n// Getting it from the top-level package means we don't get its type. This is also a bug, but it's more acceptable.\nimport { FetchStore } from \"zarrita\";\n\nimport type { ImageInfo } from \"../ImageInfo.js\";\nimport type { VolumeDims } from \"../VolumeDims.js\";\nimport VolumeCache from \"../VolumeCache.js\";\nimport SubscribableRequestQueue from \"../utils/SubscribableRequestQueue.js\";\nimport {\n  ThreadableVolumeLoader,\n  LoadSpec,\n  type RawChannelDataCallback,\n  type LoadedVolumeInfo,\n} from \"./IVolumeLoader.js\";\nimport {\n  composeSubregion,\n  computePackedAtlasDims,\n  convertSubregionToPixels,\n  pickLevelToLoad,\n  unitNameToSymbol,\n} from \"./VolumeLoaderUtils.js\";\nimport ChunkPrefetchIterator from \"./zarr_utils/ChunkPrefetchIterator.js\";\nimport WrappedStore from \"./zarr_utils/WrappedStore.js\";\nimport {\n  getDimensionCount,\n  getScale,\n  getSourceChannelNames,\n  matchSourceScaleLevels,\n  orderByDimension,\n  orderByTCZYX,\n  remapAxesToTCZYX,\n} from \"./zarr_utils/utils.js\";\nimport type {\n  OMEZarrMetadata,\n  PrefetchDirection,\n  SubscriberId,\n  TCZYX,\n  ZarrSource,\n  NumericZarrArray,\n} from \"./zarr_utils/types.js\";\nimport { VolumeLoadError, VolumeLoadErrorType, wrapVolumeLoadError } from \"./VolumeLoadError.js\";\nimport { validateOMEZarrMetadata } from \"./zarr_utils/validation.js\";\n\nconst CHUNK_REQUEST_CANCEL_REASON = \"chunk request cancelled\";\n\n// returns the converted data and the original min and max values\nfunction convertChannel(\n  channelData: zarr.TypedArray<zarr.NumberDataType>,\n  dtype: zarr.NumberDataType\n): { data: zarr.TypedArray<zarr.NumberDataType>; dtype: zarr.NumberDataType; min: number; max: number } {\n  // get min and max\n  // TODO FIXME Histogram will also compute min and max!\n  let min = channelData[0];\n  let max = channelData[0];\n  for (let i = 0; i < channelData.length; i++) {\n    const val = channelData[i];\n    if (val < min) {\n      min = val;\n    }\n    if (val > max) {\n      max = val;\n    }\n  }\n\n  if (dtype === \"float64\") {\n    // convert to float32\n    const f32 = new Float32Array(channelData.length);\n    for (let i = 0; i < channelData.length; i++) {\n      f32[i] = channelData[i];\n    }\n    dtype = \"float32\";\n    channelData = f32;\n  }\n\n  return { data: channelData, dtype, min, max };\n}\n\nexport type ZarrLoaderFetchOptions = {\n  /** The max. number of requests the loader can issue at a time. Ignored if the constructor also receives a queue. */\n  concurrencyLimit?: number;\n  /**\n   * The max. number of *prefetch* requests the loader can issue at a time. Set lower than `concurrencyLimit` to ensure\n   * that prefetching leaves room in the queue for actual loads. Ignored if the constructor also receives a queue.\n   */\n  prefetchConcurrencyLimit?: number;\n  /**\n   * The max. number of chunks to prefetch outward in either direction. E.g. if a load requests chunks with z coords 3\n   * and 4 and `maxPrefetchDistance` in z is 2, the loader will prefetch similar chunks with z coords 1, 2, 5, and 6\n   * (or until it hits `maxPrefetchChunks`). Ordered TZYX.\n   */\n  maxPrefetchDistance: [number, number, number, number];\n  /** The max. number of total chunks that can be prefetched after any load. */\n  maxPrefetchChunks: number;\n  /** The initial directions to prioritize when prefetching */\n  priorityDirections?: PrefetchDirection[];\n  /** only use priority directions */\n  onlyPriorityDirections?: boolean;\n};\n\ntype ZarrChunkFetchInfo = {\n  sourceIdx: number;\n  key: string;\n};\n\nconst DEFAULT_FETCH_OPTIONS = {\n  maxPrefetchDistance: [5, 5, 5, 5] as [number, number, number, number],\n  maxPrefetchChunks: 30,\n};\n\nclass OMEZarrLoader extends ThreadableVolumeLoader {\n  /** The ID of the subscriber responsible for \"actual loads\" (non-prefetch requests) */\n  private loadSubscriber: SubscriberId | undefined;\n  /** The ID of the subscriber responsible for prefetches, so that requests can be cancelled and reissued */\n  private prefetchSubscriber: SubscriberId | undefined;\n\n  // TODO: this property should definitely be owned by `Volume` if this loader is ever used by multiple volumes.\n  //   This may cause errors or incorrect results otherwise!\n  private maxExtent?: Box3;\n\n  private syncChannels = false;\n\n  private constructor(\n    /**\n     * Array of records, each containing the objects and metadata we need to load from one source of multiscale zarr\n     * data. See documentation on `ZarrSource` for more.\n     */\n    private sources: ZarrSource[],\n    /** Handle to a `SubscribableRequestQueue` for smart concurrency management and request cancelling/reissuing. */\n    private requestQueue: SubscribableRequestQueue,\n    /** Options to configure (pre)fetching behavior. */\n    private fetchOptions: ZarrLoaderFetchOptions = DEFAULT_FETCH_OPTIONS,\n    /** Direction(s) to prioritize when prefetching. Stored separate from `fetchOptions` since it may be mutated. */\n    private priorityDirections: PrefetchDirection[] = []\n  ) {\n    super();\n  }\n\n  /**\n   * Creates a new `OMEZarrLoader`.\n   *\n   * @param urls The URL(s) of the OME-Zarr data to load. If `urls` is an array, the loader will attempt to find scale\n   *  levels with exactly the same size in every source. If matching level(s) are available, the loader will produce a\n   *  volume containing all channels from every provided zarr in the order they appear in `urls`. If no matching sets\n   *  of scale levels are available, creation fails.\n   * @param scenes The scene(s) to load from each URL. If `urls` is an array, `scenes` may either be an array of values\n   *  corresponding to each URL, or a single value to apply to all URLs. Default 0.\n   * @param cache A cache to use for storing fetched data. If not provided, a new cache will be created.\n   * @param queue A queue to use for managing requests. If not provided, a new queue will be created.\n   * @param fetchOptions Options to configure (pre)fetching behavior.\n   */\n  static async createLoader(\n    urls: string | string[],\n    scenes: number | number[] = 0,\n    cache?: VolumeCache,\n    queue?: SubscribableRequestQueue,\n    fetchOptions?: ZarrLoaderFetchOptions\n  ): Promise<OMEZarrLoader> {\n    // Setup queue and store, get basic metadata\n    if (!queue) {\n      queue = new SubscribableRequestQueue(fetchOptions?.concurrencyLimit, fetchOptions?.prefetchConcurrencyLimit);\n    }\n    const urlsArr = Array.isArray(urls) ? urls : [urls];\n    const scenesArr = Array.isArray(scenes) ? scenes : [scenes];\n\n    // Create one `ZarrSource` per URL\n    const sourceProms = urlsArr.map(async (url, i) => {\n      const store = new WrappedStore<RequestInit>(new FetchStore(url), cache, queue);\n      const root = zarr.root(store);\n\n      const group = await zarr\n        .open(root, { kind: \"group\" })\n        .catch(wrapVolumeLoadError(`Failed to open OME-Zarr data at ${url}`, VolumeLoadErrorType.NOT_FOUND));\n\n      // Pick scene (multiscale)\n      let scene = scenesArr[Math.min(i, scenesArr.length - 1)];\n      if (scene > group.attrs.multiscales?.length) {\n        console.warn(`WARNING: OMEZarrLoader: scene ${scene} is invalid. Using scene 0.`);\n        scene = 0;\n      }\n\n      validateOMEZarrMetadata(group.attrs, scene, urlsArr.length > 1 ? `Zarr source ${i}` : \"Zarr\");\n      const { multiscales, omero } = group.attrs as OMEZarrMetadata;\n      const multiscaleMetadata = multiscales[scene];\n\n      // Open all scale levels of multiscale\n      const lvlProms = multiscaleMetadata.datasets.map(({ path }) =>\n        zarr\n          .open(root.resolve(path), { kind: \"array\" })\n          .catch(\n            wrapVolumeLoadError(\n              `Failed to open scale level ${path} of OME-Zarr data at ${url}`,\n              VolumeLoadErrorType.NOT_FOUND\n            )\n          )\n      );\n      const scaleLevels = (await Promise.all(lvlProms)) as NumericZarrArray[];\n      const axesTCZYX = remapAxesToTCZYX(multiscaleMetadata.axes);\n\n      return {\n        scaleLevels,\n        multiscaleMetadata,\n        omeroMetadata: omero,\n        axesTCZYX,\n        channelOffset: 0,\n      } as ZarrSource;\n    });\n    const sources = await Promise.all(sourceProms);\n\n    // Set `channelOffset`s so we can match channel indices to sources\n    let channelCount = 0;\n    for (const s of sources) {\n      s.channelOffset = channelCount;\n      channelCount += s.omeroMetadata?.channels.length ?? s.scaleLevels[0].shape[s.axesTCZYX[1]];\n    }\n    // Ensure the sizes of all sources' scale levels are matched up. See this function's docs for more.\n    matchSourceScaleLevels(sources);\n    // TODO: if `matchSourceScaleLevels` returned successfully, every one of these sources' `multiscaleMetadata` is the\n    // same in every field we care about, so we only ever use the first source's `multiscaleMetadata` after this point.\n    // Should we only store one `OMEMultiscale` record total, rather than one per source?\n    const priorityDirs = fetchOptions?.priorityDirections ? fetchOptions.priorityDirections.slice() : undefined;\n    return new OMEZarrLoader(sources, queue, fetchOptions, priorityDirs);\n  }\n\n  private getUnitSymbols(): [string, string] {\n    const source = this.sources[0];\n    // Assume all spatial axes in all sources have the same units - we have no means of storing per-axis unit symbols\n    const xi = source.axesTCZYX[4];\n    const spaceUnitName = source.multiscaleMetadata.axes[xi].unit;\n    const spaceUnitSymbol = unitNameToSymbol(spaceUnitName) || spaceUnitName || \"\";\n\n    const ti = source.axesTCZYX[0];\n    const timeUnitName = ti > -1 ? source.multiscaleMetadata.axes[ti].unit : undefined;\n    const timeUnitSymbol = unitNameToSymbol(timeUnitName) || timeUnitName || \"\";\n\n    return [spaceUnitSymbol, timeUnitSymbol];\n  }\n\n  private getLevelShapesZYX(): [number, number, number][] {\n    const source = this.sources[0];\n    const [z, y, x] = source.axesTCZYX.slice(-3);\n    return source.scaleLevels.map(({ shape }) => [z === -1 ? 1 : shape[z], shape[y], shape[x]]);\n  }\n\n  private getScale(level: number): TCZYX<number> {\n    return getScale(this.sources[0].multiscaleMetadata.datasets[level], this.sources[0].axesTCZYX);\n  }\n\n  private orderByDimension<T>(valsTCZYX: TCZYX<T>, sourceIdx = 0): T[] {\n    return orderByDimension(valsTCZYX, this.sources[sourceIdx].axesTCZYX);\n  }\n\n  private orderByTCZYX<T>(valsDimension: T[], defaultValue: T, sourceIdx = 0): TCZYX<T> {\n    return orderByTCZYX(valsDimension, this.sources[sourceIdx].axesTCZYX, defaultValue);\n  }\n\n  /**\n   * Converts a volume channel index to the index of its zarr source and its channel index within that zarr.\n   * e.g., if the loader has 2 sources, the first with 3 channels and the second with 2, then `matchChannelToSource(4)`\n   * returns `[1, 1]` (the second channel of the second source).\n   */\n  private matchChannelToSource(absoluteChannelIndex: number): { sourceIndex: number; channelIndexInSource: number } {\n    const lastSrcIdx = this.sources.length - 1;\n    const lastSrc = this.sources[lastSrcIdx];\n    const lastSrcNumChannels = lastSrc.scaleLevels[0].shape[lastSrc.axesTCZYX[1]];\n\n    const maxChannelIndex = lastSrc.channelOffset + lastSrcNumChannels;\n    if (absoluteChannelIndex > maxChannelIndex) {\n      throw new VolumeLoadError(\n        `Volume channel index ${absoluteChannelIndex} out of range (${maxChannelIndex} channels available)`,\n        { type: VolumeLoadErrorType.INVALID_METADATA }\n      );\n    }\n\n    const firstGreaterIdx = this.sources.findIndex((src) => src.channelOffset > absoluteChannelIndex);\n    const sourceIndex = firstGreaterIdx === -1 ? lastSrcIdx : firstGreaterIdx - 1;\n    const channelIndexInSource = absoluteChannelIndex - this.sources[sourceIndex].channelOffset;\n    return { sourceIndex, channelIndexInSource };\n  }\n\n  /**\n   * Change which directions to prioritize when prefetching. All chunks will be prefetched in these directions before\n   * any chunks are prefetched in any other directions.\n   */\n  setPrefetchPriority(directions: PrefetchDirection[]): void {\n    this.priorityDirections = directions;\n  }\n\n  syncMultichannelLoading(sync: boolean): void {\n    this.syncChannels = sync;\n  }\n\n  updateFetchOptions(options: Partial<ZarrLoaderFetchOptions>): void {\n    this.fetchOptions = { ...this.fetchOptions, ...options };\n  }\n\n  loadDims(loadSpec: LoadSpec): Promise<VolumeDims[]> {\n    const [spaceUnit, timeUnit] = this.getUnitSymbols();\n    // Compute subregion size so we can factor that in\n    const maxExtent = this.maxExtent ?? new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1));\n    const subregion = composeSubregion(loadSpec.subregion, maxExtent);\n    const regionSize = subregion.getSize(new Vector3());\n    const regionArr = [1, 1, regionSize.z, regionSize.y, regionSize.x];\n\n    const result = this.sources[0].scaleLevels.map((level, i) => {\n      const scale = this.getScale(i);\n      const dims: VolumeDims = {\n        spaceUnit: spaceUnit,\n        timeUnit: timeUnit,\n        shape: this.orderByTCZYX(level.shape, 1).map((val, idx) =>\n          Math.max(Math.ceil(val * regionArr[idx]), 1)\n        ) as TCZYX<number>,\n        spacing: this.orderByTCZYX(scale, 1),\n        dataType: level.dtype,\n      };\n      return dims;\n    });\n\n    return Promise.resolve(result);\n  }\n\n  createImageInfo(loadSpec: LoadSpec): Promise<LoadedVolumeInfo> {\n    // We ensured most info (dims, chunks, etc.) matched between sources earlier, so we can just use the first source.\n    const source0 = this.sources[0];\n    const [t, , z, y, x] = source0.axesTCZYX;\n    const hasT = t > -1;\n    const hasZ = z > -1;\n\n    const levelToLoad = pickLevelToLoad(loadSpec, this.getLevelShapesZYX());\n    const shapeLv = source0.scaleLevels[levelToLoad].shape;\n\n    const [spatialUnit, timeUnit] = this.getUnitSymbols();\n\n    // Now we care about other sources: # of channels is the `channelOffset` of the last source plus its # of channels\n    const sourceLast = this.sources[this.sources.length - 1];\n    const cLast = sourceLast.axesTCZYX[1];\n    const lastHasC = cLast > -1;\n    const numChannels = sourceLast.channelOffset + (lastHasC ? sourceLast.scaleLevels[levelToLoad].shape[cLast] : 1);\n    // we need to make sure that the corresponding matched shapes\n    // use the min size of T\n    let times = 1;\n    if (hasT) {\n      times = shapeLv[t];\n      for (let i = 0; i < this.sources.length; i++) {\n        const shape = this.sources[i].scaleLevels[levelToLoad].shape;\n        const tindex = this.sources[i].axesTCZYX[0];\n        if (shape[tindex] < times) {\n          console.warn(\"The number of time points is not consistent across sources: \", shape[tindex], times);\n          times = shape[tindex];\n        }\n      }\n    }\n\n    if (!this.maxExtent) {\n      this.maxExtent = loadSpec.subregion.clone();\n    }\n\n    // from source 0:\n    const pxDimsLv = convertSubregionToPixels(\n      loadSpec.subregion,\n      new Vector3(shapeLv[x], shapeLv[y], hasZ ? shapeLv[z] : 1)\n    );\n    const pxSizeLv = pxDimsLv.getSize(new Vector3());\n\n    const atlasTileDims = computePackedAtlasDims(pxSizeLv.z, pxSizeLv.x, pxSizeLv.y);\n\n    // Channel names is the other place where we have to check every source\n    // Track which channel names we've seen so far, so that we can rename them to avoid name collisions\n    const channelNamesMap = new Map<string, number>();\n    const channelNames = this.sources.flatMap((src) => {\n      const sourceChannelNames = getSourceChannelNames(src);\n\n      // Resolve name collisions\n      return sourceChannelNames.map((channelName) => {\n        const numMatchingChannels = channelNamesMap.get(channelName);\n\n        if (numMatchingChannels !== undefined) {\n          // If e.g. we've seen channel \"Membrane\" once before, rename this one to \"Membrane (1)\"\n          channelNamesMap.set(channelName, numMatchingChannels + 1);\n          return `${channelName} (${numMatchingChannels})`;\n        } else {\n          channelNamesMap.set(channelName, 1);\n          return channelName;\n        }\n      });\n    });\n\n    const alldims: VolumeDims[] = source0.scaleLevels.map((level, i) => {\n      const dims = {\n        spaceUnit: spatialUnit,\n        timeUnit: timeUnit,\n        shape: this.orderByTCZYX(level.shape, 1),\n        spacing: this.getScale(i),\n        dataType: level.dtype,\n      };\n      return dims;\n    });\n\n    const imgdata: ImageInfo = {\n      name: source0.omeroMetadata?.name || \"Volume\",\n\n      atlasTileDims: [atlasTileDims.x, atlasTileDims.y],\n      subregionSize: [pxSizeLv.x, pxSizeLv.y, pxSizeLv.z],\n      subregionOffset: [0, 0, 0],\n\n      combinedNumChannels: numChannels,\n      channelNames,\n      multiscaleLevel: levelToLoad,\n      multiscaleLevelDims: alldims,\n\n      transform: {\n        translation: [0, 0, 0],\n        rotation: [0, 0, 0],\n        scale: [1, 1, 1],\n      },\n    };\n\n    // The `LoadSpec` passed in at this stage should represent the subset which this loader loads, not that\n    // which the volume contains. The volume contains the full extent of the subset recognized by this loader.\n    const fullExtentLoadSpec: LoadSpec = {\n      ...loadSpec,\n      subregion: new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1)),\n    };\n\n    return Promise.resolve({ imageInfo: imgdata, loadSpec: fullExtentLoadSpec });\n  }\n\n  private async prefetchChunk(\n    scaleLevel: NumericZarrArray,\n    coords: TCZYX<number>,\n    subscriber: SubscriberId\n  ): Promise<void> {\n    const { store, path } = scaleLevel;\n    const separator = path.endsWith(\"/\") ? \"\" : \"/\";\n    const key = path + separator + this.orderByDimension(coords).join(\"/\");\n    // Calling `get` and doing nothing with the result still triggers a cache check, fetch, and insertion\n    await store\n      .get(key as AbsolutePath, { subscriber, isPrefetch: true })\n      .catch(\n        wrapVolumeLoadError(\n          `Unable to prefetch chunk with key ${key}`,\n          VolumeLoadErrorType.LOAD_DATA_FAILED,\n          CHUNK_REQUEST_CANCEL_REASON\n        )\n      );\n  }\n\n  /** Reads a list of chunk keys requested by a `loadVolumeData` call and sets up appropriate prefetch requests. */\n  private beginPrefetch(keys: ZarrChunkFetchInfo[], scaleLevel: number): void {\n    // Convert keys to arrays of coords\n    const chunkCoords = keys.map(({ sourceIdx, key }) => {\n      const numDims = getDimensionCount(this.sources[sourceIdx].axesTCZYX);\n      const coordsInDimensionOrder = key\n        .trim()\n        .split(\"/\")\n        .slice(-numDims)\n        .filter((s) => s !== \"\")\n        .map((s) => parseInt(s, 10));\n      const sourceCoords = this.orderByTCZYX(coordsInDimensionOrder, 0, sourceIdx);\n      // Convert source channel index to absolute channel index for `ChunkPrefetchIterator`'s benefit\n      // (we match chunk coordinates output from `ChunkPrefetchIterator` back to sources below)\n      sourceCoords[1] += this.sources[sourceIdx].channelOffset;\n      return sourceCoords;\n    });\n\n    // Get number of chunks per dimension in every source array\n    const chunkDimsTCZYX = this.sources.map((src) => {\n      const level = src.scaleLevels[scaleLevel];\n      const chunkDimsUnordered = level.shape.map((dim, idx) => Math.ceil(dim / level.chunks[idx]));\n      return this.orderByTCZYX(chunkDimsUnordered, 1);\n    });\n    // `ChunkPrefetchIterator` yields chunk coordinates in order of roughly how likely they are to be loaded next\n    const prefetchIterator = new ChunkPrefetchIterator(\n      chunkCoords,\n      this.fetchOptions.maxPrefetchDistance,\n      chunkDimsTCZYX,\n      this.priorityDirections,\n      this.fetchOptions.onlyPriorityDirections\n    );\n\n    const subscriber = this.requestQueue.addSubscriber();\n    let prefetchCount = 0;\n    for (const chunk of prefetchIterator) {\n      if (prefetchCount >= this.fetchOptions.maxPrefetchChunks) {\n        break;\n      }\n      // Match absolute channel coordinate back to source index and channel index\n      const { sourceIndex, channelIndexInSource } = this.matchChannelToSource(chunk[1]);\n      const sourceScaleLevel = this.sources[sourceIndex].scaleLevels[scaleLevel];\n      chunk[1] = channelIndexInSource;\n      this.prefetchChunk(sourceScaleLevel, chunk, subscriber);\n      prefetchCount++;\n    }\n\n    // Clear out old prefetch requests (requests which also cover this new prefetch will be preserved)\n    if (this.prefetchSubscriber !== undefined) {\n      this.requestQueue.removeSubscriber(this.prefetchSubscriber, CHUNK_REQUEST_CANCEL_REASON);\n    }\n    this.prefetchSubscriber = subscriber;\n  }\n\n  private updateImageInfoForLoad(imageInfo: ImageInfo, loadSpec: LoadSpec): ImageInfo {\n    // Apply `this.maxExtent` to subregion, if it exists\n    const maxExtent = this.maxExtent ?? new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1));\n    const subregion = composeSubregion(loadSpec.subregion, maxExtent);\n\n    // Pick the level to load based on the subregion size\n    const multiscaleLevel = pickLevelToLoad({ ...loadSpec, subregion }, this.getLevelShapesZYX());\n    const array0Shape = this.sources[0].scaleLevels[multiscaleLevel].shape;\n\n    // Convert subregion to volume voxels\n    const [z, y, x] = this.sources[0].axesTCZYX.slice(2);\n    const regionPx = convertSubregionToPixels(\n      subregion,\n      new Vector3(array0Shape[x], array0Shape[y], z === -1 ? 1 : array0Shape[z])\n    );\n\n    // Derive other image info properties from subregion and level to load\n    const subregionSize = regionPx.getSize(new Vector3());\n    const atlasTileDims = computePackedAtlasDims(subregionSize.z, subregionSize.x, subregionSize.y);\n\n    return {\n      ...imageInfo,\n      atlasTileDims: [atlasTileDims.x, atlasTileDims.y],\n      subregionSize: [subregionSize.x, subregionSize.y, subregionSize.z],\n      subregionOffset: [regionPx.min.x, regionPx.min.y, regionPx.min.z],\n      multiscaleLevel,\n    };\n  }\n\n  async loadRawChannelData(\n    imageInfo: ImageInfo,\n    loadSpec: LoadSpec,\n    onUpdateMetadata: (imageInfo: ImageInfo) => void,\n    onData: RawChannelDataCallback\n  ): Promise<void> {\n    // This seemingly useless line keeps a stable local copy of `syncChannels` which the async closures below capture\n    // so that changes to `this.syncChannels` don't affect the behavior of loads in progress.\n    const syncChannels = this.syncChannels;\n\n    const updatedImageInfo = this.updateImageInfoForLoad(imageInfo, loadSpec);\n    onUpdateMetadata(updatedImageInfo);\n    const { combinedNumChannels, multiscaleLevel } = updatedImageInfo;\n    const channelIndexes = loadSpec.channels ?? Array.from({ length: combinedNumChannels }, (_, i) => i);\n\n    const subscriber = this.requestQueue.addSubscriber();\n\n    // Prefetch housekeeping: we want to save keys involved in this load to prefetch later\n    const keys: ZarrChunkFetchInfo[] = [];\n    const reportKeyBase = (sourceIdx: number, key: string, sub: SubscriberId) => {\n      if (sub === subscriber) {\n        keys.push({ sourceIdx, key });\n      }\n    };\n\n    const resultChannelIndices: number[] = [];\n    const resultChannelData: zarr.TypedArray<zarr.NumberDataType>[] = [];\n    const resultChannelDtype: zarr.NumberDataType[] = [];\n    const resultChannelRanges: [number, number][] = [];\n\n    const channelPromises = channelIndexes.map(async (ch) => {\n      // Build slice spec\n      const min = new Vector3(...updatedImageInfo.subregionOffset);\n      const max = min.clone().add(new Vector3(...updatedImageInfo.subregionSize));\n      const { sourceIndex: sourceIdx, channelIndexInSource: sourceCh } = this.matchChannelToSource(ch);\n      const unorderedSpec = [loadSpec.time, sourceCh, slice(min.z, max.z), slice(min.y, max.y), slice(min.x, max.x)];\n\n      const level = this.sources[sourceIdx].scaleLevels[multiscaleLevel];\n      const sliceSpec = this.orderByDimension(unorderedSpec as TCZYX<number | Slice>, sourceIdx);\n      const reportKey = (key: string, sub: SubscriberId) => reportKeyBase(sourceIdx, key, sub);\n\n      const result = await zarrGet(level, sliceSpec, { opts: { subscriber, reportKey } }).catch(\n        wrapVolumeLoadError(\n          \"Could not load OME-Zarr volume data\",\n          VolumeLoadErrorType.LOAD_DATA_FAILED,\n          CHUNK_REQUEST_CANCEL_REASON\n        )\n      );\n\n      if (result?.data === undefined) {\n        return;\n      }\n\n      const converted = convertChannel(result.data, level.dtype);\n      if (syncChannels) {\n        resultChannelDtype.push(converted.dtype);\n        resultChannelData.push(converted.data);\n        resultChannelIndices.push(ch);\n        resultChannelRanges.push([converted.min, converted.max]);\n      } else {\n        onData([ch], [converted.dtype], [converted.data], [[converted.min, converted.max]]);\n      }\n    });\n\n    // Cancel any in-flight requests from previous loads that aren't useful to this one\n    if (this.loadSubscriber !== undefined) {\n      this.requestQueue.removeSubscriber(this.loadSubscriber, CHUNK_REQUEST_CANCEL_REASON);\n    }\n    this.loadSubscriber = subscriber;\n\n    this.beginPrefetch(keys, multiscaleLevel);\n\n    await Promise.all(channelPromises);\n\n    if (syncChannels) {\n      onData(resultChannelIndices, resultChannelDtype, resultChannelData, resultChannelRanges);\n    }\n    this.requestQueue.removeSubscriber(subscriber, CHUNK_REQUEST_CANCEL_REASON);\n  }\n}\n\nexport { OMEZarrLoader };\n","import { Box3, Vector3 } from \"three\";\n\nimport {\n  ThreadableVolumeLoader,\n  type LoadSpec,\n  type RawChannelDataCallback,\n  type LoadedVolumeInfo,\n} from \"./IVolumeLoader.js\";\nimport { computePackedAtlasDims } from \"./VolumeLoaderUtils.js\";\nimport type { ImageInfo } from \"../ImageInfo.js\";\nimport type { VolumeDims } from \"../VolumeDims.js\";\nimport { Uint8 } from \"../types.js\";\nimport { getDataRange } from \"../utils/num_utils.js\";\n\n// this is the form in which a 4D numpy array arrives as converted\n// by jupyterlab into a js object.\n// This loader does not yet support multiple time samples.\nexport type RawArrayData = {\n  // expected to be \"uint8\" always\n  dtype: Uint8;\n  // [c,z,y,x]\n  shape: [number, number, number, number];\n  // the bits (assumed uint8!!)\n  buffer: DataView;\n};\n\n// minimal metadata for visualization\nexport type RawArrayInfo = {\n  name: string;\n  sizeX: number;\n  sizeY: number;\n  sizeZ: number;\n  sizeC: number;\n  physicalPixelSize: [number, number, number];\n  spatialUnit: string;\n  channelNames: string[];\n  userData?: Record<string, unknown>;\n};\n\nexport interface RawArrayLoaderOptions {\n  data: RawArrayData;\n  metadata: RawArrayInfo;\n}\n\nconst convertImageInfo = (json: RawArrayInfo): ImageInfo => {\n  const atlasTileDims = computePackedAtlasDims(json.sizeZ, json.sizeX, json.sizeY);\n  return {\n    name: json.name,\n\n    // assumption: the data is already sized to fit in our viewer's preferred\n    // memory footprint (a tiled atlas texture as of this writing)\n    atlasTileDims: [atlasTileDims.x, atlasTileDims.y],\n    subregionSize: [json.sizeX, json.sizeY, json.sizeZ],\n    subregionOffset: [0, 0, 0],\n\n    combinedNumChannels: json.sizeC,\n    channelNames: json.channelNames,\n    channelColors: undefined,\n\n    multiscaleLevel: 0,\n    multiscaleLevelDims: [\n      {\n        shape: [1, json.sizeC, json.sizeZ, json.sizeY, json.sizeX],\n        spacing: [1, 1, json.physicalPixelSize[2], json.physicalPixelSize[1], json.physicalPixelSize[0]],\n        spaceUnit: json.spatialUnit || \"μm\",\n        timeUnit: \"s\",\n        dataType: \"uint8\",\n      },\n    ],\n\n    transform: {\n      translation: [0, 0, 0],\n      rotation: [0, 0, 0],\n      scale: [1, 1, 1],\n    },\n\n    userData: json.userData,\n  };\n};\n\nclass RawArrayLoader extends ThreadableVolumeLoader {\n  data: RawArrayData;\n  jsonInfo: RawArrayInfo;\n\n  constructor(rawData: RawArrayData, rawDataInfo: RawArrayInfo) {\n    super();\n    this.jsonInfo = rawDataInfo;\n    this.data = rawData;\n    // check consistent dims\n    if (\n      this.data.shape[0] !== this.jsonInfo.sizeC ||\n      this.data.shape[1] !== this.jsonInfo.sizeZ ||\n      this.data.shape[2] !== this.jsonInfo.sizeY ||\n      this.data.shape[3] !== this.jsonInfo.sizeX\n    ) {\n      throw new Error(\"RawArrayLoader: data shape does not match metadata\");\n    }\n  }\n\n  async loadDims(_loadSpec: LoadSpec): Promise<VolumeDims[]> {\n    const jsonInfo = this.jsonInfo;\n\n    const d: VolumeDims = {\n      shape: [1, jsonInfo.sizeC, jsonInfo.sizeZ, jsonInfo.sizeY, jsonInfo.sizeX],\n      spacing: [1, 1, jsonInfo.physicalPixelSize[2], jsonInfo.physicalPixelSize[1], jsonInfo.physicalPixelSize[0]],\n      spaceUnit: jsonInfo.spatialUnit || \"μm\",\n      dataType: \"uint8\",\n      timeUnit: \"s\", // time unit not specified\n    };\n    return [d];\n  }\n\n  async createImageInfo(loadSpec: LoadSpec): Promise<LoadedVolumeInfo> {\n    return { imageInfo: convertImageInfo(this.jsonInfo), loadSpec };\n  }\n\n  loadRawChannelData(\n    imageInfo: ImageInfo,\n    loadSpec: LoadSpec,\n    onUpdateMetadata: (imageInfo: undefined, loadSpec: LoadSpec) => void,\n    onData: RawChannelDataCallback\n  ): Promise<void> {\n    const requestedChannels = loadSpec.channels;\n\n    const adjustedLoadSpec = {\n      ...loadSpec,\n      // `subregion` and `multiscaleLevel` are unused by this loader\n      subregion: new Box3(new Vector3(0, 0, 0), new Vector3(1, 1, 1)),\n      multiscaleLevel: 0,\n    };\n    onUpdateMetadata(undefined, adjustedLoadSpec);\n\n    for (let chindex = 0; chindex < imageInfo.combinedNumChannels; ++chindex) {\n      if (requestedChannels && requestedChannels.length > 0 && !requestedChannels.includes(chindex)) {\n        continue;\n      }\n      const volSizeBytes = this.data.shape[3] * this.data.shape[2] * this.data.shape[1]; // x*y*z pixels * 1 byte/pixel\n      const channelData = new Uint8Array(this.data.buffer.buffer, chindex * volSizeBytes, volSizeBytes);\n      const range = getDataRange(channelData);\n      // all data coming from this loader is natively 8-bit\n      onData([chindex], [\"uint8\"], [channelData], [range]);\n    }\n\n    return Promise.resolve();\n  }\n}\n\nexport { RawArrayLoader };\n","import { fromUrl } from \"geotiff\";\nimport { ErrorObject, deserializeError } from \"serialize-error\";\n\nimport {\n  ThreadableVolumeLoader,\n  LoadSpec,\n  type RawChannelDataCallback,\n  type LoadedVolumeInfo,\n} from \"./IVolumeLoader.js\";\nimport { computePackedAtlasDims, MAX_ATLAS_EDGE } from \"./VolumeLoaderUtils.js\";\nimport { VolumeLoadError, VolumeLoadErrorType, wrapVolumeLoadError } from \"./VolumeLoadError.js\";\nimport { type ImageInfo, CImageInfo } from \"../ImageInfo.js\";\nimport type { VolumeDims } from \"../VolumeDims.js\";\nimport { TypedArray, NumberType } from \"../types.js\";\n\nfunction prepareXML(xml: string): string {\n  // trim trailing unicode zeros?\n  // eslint-disable-next-line no-control-regex\n  const expr = /[\\u0000]$/g;\n  return xml.trim().replace(expr, \"\").trim();\n}\n\nfunction getOME(xml: string): Element {\n  const parser = new DOMParser();\n  try {\n    const xmlDoc = parser.parseFromString(xml, \"text/xml\");\n    return xmlDoc.getElementsByTagName(\"OME\")[0];\n  } catch (e) {\n    throw new VolumeLoadError(\"Could not find OME metadata in TIFF file\", {\n      type: VolumeLoadErrorType.INVALID_METADATA,\n      cause: e,\n    });\n  }\n}\n\nclass OMEDims {\n  sizex = 0;\n  sizey = 0;\n  sizez = 1;\n  sizec = 1;\n  sizet = 1;\n  unit = \"\";\n  pixeltype = \"\";\n  dimensionorder = \"\";\n  pixelsizex = 1;\n  pixelsizey = 1;\n  pixelsizez = 1;\n  channelnames: string[] = [];\n}\n\nfunction getDtype(omepixeltype: string): NumberType {\n  const mapping: Record<string, NumberType> = {\n    uint8: \"uint8\",\n    uint16: \"uint16\",\n    uint32: \"uint32\",\n    int8: \"int8\",\n    int16: \"int16\",\n    int32: \"int32\",\n    float: \"float32\",\n  };\n  const dtype = mapping[omepixeltype];\n  if (dtype === undefined) {\n    console.warn(`Unsupported OME pixel type ${omepixeltype}; defaulting to uint8`);\n    return \"uint8\";\n  }\n  return dtype;\n}\n\nexport type TiffWorkerParams = {\n  channel: number;\n  tilesizex: number;\n  tilesizey: number;\n  sizec: number;\n  sizez: number;\n  dimensionOrder: string;\n  bytesPerSample: number;\n  url: string;\n};\n\nexport type TiffLoadResult = {\n  isError: false;\n  data: TypedArray<NumberType>;\n  dtype: NumberType;\n  channel: number;\n  range: [number, number];\n};\n\nfunction getAttributeOrError(el: Element, attr: string): string {\n  const val = el.getAttribute(attr);\n  if (val === null) {\n    throw new VolumeLoadError(`Missing attribute ${attr} in OME-TIFF metadata`, {\n      type: VolumeLoadErrorType.INVALID_METADATA,\n    });\n  }\n  return val;\n}\n\nfunction getOMEDims(imageEl: Element): OMEDims {\n  const dims = new OMEDims();\n\n  const pixelsEl = imageEl.getElementsByTagName(\"Pixels\")[0];\n  dims.sizex = Number(getAttributeOrError(pixelsEl, \"SizeX\"));\n  dims.sizey = Number(getAttributeOrError(pixelsEl, \"SizeY\"));\n  dims.sizez = Number(pixelsEl.getAttribute(\"SizeZ\"));\n  dims.sizec = Number(pixelsEl.getAttribute(\"SizeC\"));\n  dims.sizet = Number(pixelsEl.getAttribute(\"SizeT\"));\n  dims.unit = pixelsEl.getAttribute(\"PhysicalSizeXUnit\") || \"\";\n  dims.pixeltype = pixelsEl.getAttribute(\"Type\") || \"\";\n  dims.dimensionorder = pixelsEl.getAttribute(\"DimensionOrder\") || \"XYZCT\";\n  dims.pixelsizex = Number(pixelsEl.getAttribute(\"PhysicalSizeX\"));\n  dims.pixelsizey = Number(pixelsEl.getAttribute(\"PhysicalSizeY\"));\n  dims.pixelsizez = Number(pixelsEl.getAttribute(\"PhysicalSizeZ\"));\n  const channelsEls = pixelsEl.getElementsByTagName(\"Channel\");\n  for (let i = 0; i < channelsEls.length; ++i) {\n    const name = channelsEls[i].getAttribute(\"Name\");\n    const id = channelsEls[i].getAttribute(\"ID\");\n    dims.channelnames.push(name ? name : id ? id : \"Channel\" + i);\n  }\n\n  return dims;\n}\n\nconst getBytesPerSample = (type: string): number => (type === \"uint8\" ? 1 : type === \"uint16\" ? 2 : 4);\n\n// Despite the class `TiffLoader` extends, this loader is not threadable, since geotiff internally uses features that\n// aren't available on workers. It uses its own specialized workers anyways.\nclass TiffLoader extends ThreadableVolumeLoader {\n  url: string;\n  dims?: OMEDims;\n\n  constructor(url: string) {\n    super();\n    this.url = url;\n  }\n\n  private async loadOmeDims(): Promise<OMEDims> {\n    if (!this.dims) {\n      const tiff = await fromUrl(this.url, { allowFullFile: true }).catch(\n        wrapVolumeLoadError(`Could not open TIFF file at ${this.url}`, VolumeLoadErrorType.NOT_FOUND)\n      );\n      // DO NOT DO THIS, ITS SLOW\n      // const imagecount = await tiff.getImageCount();\n      // read the FIRST image\n      const image = await tiff\n        .getImage()\n        .catch(wrapVolumeLoadError(\"Failed to open TIFF image\", VolumeLoadErrorType.NOT_FOUND));\n\n      const tiffimgdesc = prepareXML(image.getFileDirectory().ImageDescription);\n      const omeEl = getOME(tiffimgdesc);\n\n      const image0El = omeEl.getElementsByTagName(\"Image\")[0];\n      this.dims = getOMEDims(image0El);\n    }\n    return this.dims;\n  }\n\n  async loadDims(_loadSpec: LoadSpec): Promise<VolumeDims[]> {\n    const dims = await this.loadOmeDims();\n\n    const atlasDims = computePackedAtlasDims(dims.sizez, dims.sizex, dims.sizey);\n    // fit tiles to max of 2048x2048?\n    const targetSize = MAX_ATLAS_EDGE;\n    const tilesizex = Math.floor(targetSize / atlasDims.x);\n    const tilesizey = Math.floor(targetSize / atlasDims.y);\n\n    const d: VolumeDims = {\n      shape: [dims.sizet, dims.sizec, dims.sizez, tilesizey, tilesizex],\n      spacing: [\n        1,\n        1,\n        dims.pixelsizez,\n        (dims.pixelsizey * dims.sizey) / tilesizey,\n        (dims.pixelsizex * dims.sizex) / tilesizex,\n      ],\n      spaceUnit: dims.unit ? dims.unit : \"micron\",\n      dataType: getDtype(dims.pixeltype),\n      timeUnit: \"s\",\n    };\n    return [d];\n  }\n\n  async createImageInfo(_loadSpec: LoadSpec): Promise<LoadedVolumeInfo> {\n    const dims = await this.loadOmeDims();\n    // compare with sizex, sizey\n    //const width = image.getWidth();\n    //const height = image.getHeight();\n\n    // TODO allow user setting of this downsampling info?\n    // TODO allow ROI selection: range of x,y,z,c for a given t\n    const atlasDims = computePackedAtlasDims(dims.sizez, dims.sizex, dims.sizey);\n    // fit tiles to max of 2048x2048?\n    const targetSize = MAX_ATLAS_EDGE;\n    const tilesizex = Math.floor(targetSize / atlasDims.x);\n    const tilesizey = Math.floor(targetSize / atlasDims.y);\n\n    // load tiff and check metadata\n\n    const imgdata: ImageInfo = {\n      name: \"TEST\",\n\n      atlasTileDims: [atlasDims.x, atlasDims.y],\n      subregionSize: [tilesizex, tilesizey, dims.sizez],\n      subregionOffset: [0, 0, 0],\n      combinedNumChannels: dims.sizec,\n      channelNames: dims.channelnames,\n      multiscaleLevel: 0,\n      multiscaleLevelDims: [\n        {\n          shape: [dims.sizet, dims.sizec, dims.sizez, tilesizey, tilesizex],\n          spacing: [\n            1,\n            1,\n            dims.pixelsizez,\n            (dims.pixelsizey * dims.sizey) / tilesizey,\n            (dims.pixelsizex * dims.sizex) / tilesizex,\n          ],\n          spaceUnit: dims.unit || \"\",\n          timeUnit: \"\",\n          dataType: getDtype(dims.pixeltype),\n        },\n      ],\n\n      transform: {\n        translation: [0, 0, 0],\n        rotation: [0, 0, 0],\n        scale: [1, 1, 1],\n      },\n    };\n\n    // This loader uses no fields from `LoadSpec`. Initialize volume with defaults.\n    return { imageInfo: imgdata, loadSpec: new LoadSpec() };\n  }\n\n  async loadRawChannelData(\n    imageInfo: ImageInfo,\n    _loadSpec: LoadSpec,\n    _onUpdateMetadata: () => void,\n    onData: RawChannelDataCallback\n  ): Promise<void> {\n    const dims = await this.loadOmeDims();\n\n    // get some size info.\n    const cimageinfo = new CImageInfo(imageInfo);\n    const volumeSize = cimageinfo.volumeSize;\n\n    const channelProms: Promise<void>[] = [];\n    // do each channel on a worker?\n    for (let channel = 0; channel < imageInfo.combinedNumChannels; ++channel) {\n      const thisChannelProm = new Promise<void>((resolve, reject) => {\n        const params: TiffWorkerParams = {\n          channel: channel,\n          // these are target xy sizes for the in-memory volume data\n          // they may or may not be the same size as original xy sizes\n          tilesizex: volumeSize.x,\n          tilesizey: volumeSize.y,\n          sizec: imageInfo.combinedNumChannels,\n          sizez: volumeSize.z,\n          dimensionOrder: dims.dimensionorder,\n          bytesPerSample: getBytesPerSample(dims.pixeltype),\n          url: this.url,\n        };\n\n        const worker = new Worker(new URL(\"../workers/FetchTiffWorker\", import.meta.url));\n        worker.onmessage = (e: MessageEvent<TiffLoadResult | { isError: true; error: ErrorObject }>) => {\n          if (e.data.isError) {\n            reject(deserializeError(e.data.error));\n            return;\n          }\n          const { data, dtype, channel, range } = e.data;\n          onData([channel], [dtype], [data], [range]);\n          worker.terminate();\n          resolve();\n        };\n\n        worker.postMessage(params);\n      });\n\n      channelProms.push(thisChannelProm);\n    }\n\n    // waiting for all channels to load allows errors to propagate to the caller via this promise\n    await Promise.all(channelProms);\n  }\n}\n\nexport { TiffLoader };\n","import { errorConstructors } from \"serialize-error\";\nimport { NodeNotFoundError, KeyError } from \"@zarrita/core\";\n// geotiff doesn't export its error types...\n\n/** Groups possible load errors into a few broad categories which we can give similar guidance to the user about. */\nexport const enum VolumeLoadErrorType {\n  UNKNOWN = \"unknown\",\n  NOT_FOUND = \"not_found\",\n  TOO_LARGE = \"too_large\",\n  LOAD_DATA_FAILED = \"load_data_failed\",\n  INVALID_METADATA = \"invalid_metadata\",\n  INVALID_MULTI_SOURCE_ZARR = \"invalid_multi_source_zarr\",\n}\n\nexport class VolumeLoadError extends Error {\n  type: VolumeLoadErrorType;\n\n  constructor(message?: string, options?: { cause?: unknown; type?: VolumeLoadErrorType }) {\n    super(message, options);\n    this.name = \"VolumeLoadError\";\n    this.type = options?.type ?? VolumeLoadErrorType.UNKNOWN;\n  }\n}\n\n// serialize-error only ever calls an error constructor with zero arguments. The required `ErrorConstructor`\n// type is a bit too restrictive - as long as the constructor can be called with no arguments it's fine.\nerrorConstructors.set(\"NodeNotFoundError\", NodeNotFoundError as ErrorConstructor);\nerrorConstructors.set(\"KeyError\", KeyError as ErrorConstructor);\nerrorConstructors.set(\"VolumeLoadError\", VolumeLoadError as unknown as ErrorConstructor);\n\n/** Curried function to re-throw an error wrapped in a `VolumeLoadError` with the given `message` and `type`. */\nexport function wrapVolumeLoadError<T>(\n  message = \"Unknown error occurred while loading volume data\",\n  type = VolumeLoadErrorType.UNKNOWN,\n  ignore?: unknown\n): (e: T) => T {\n  return (e: T) => {\n    if (ignore !== undefined && e === ignore) {\n      return e;\n    }\n    if (e instanceof VolumeLoadError) {\n      throw e;\n    }\n    console.log(`Error loading volume data: ${e}`);\n    throw new VolumeLoadError(message, { type, cause: e });\n  };\n}\n","import { Box3, Vector2, Vector3 } from \"three\";\n\nimport { CImageInfo, type ImageInfo } from \"../ImageInfo.js\";\nimport { LoadSpec } from \"./IVolumeLoader.js\";\n\nexport const MAX_ATLAS_EDGE = 4096;\n\n// Map from units to their symbols\nconst UNIT_SYMBOLS = {\n  angstrom: \"Å\",\n  day: \"d\",\n  foot: \"ft\",\n  hour: \"h\",\n  inch: \"in\",\n  meter: \"m\",\n  micron: \"μm\",\n  mile: \"mi\",\n  minute: \"min\",\n  parsec: \"pc\",\n  second: \"s\",\n  yard: \"yd\",\n};\n\n// Units which may take SI prefixes (e.g. micro-, tera-)\nconst SI_UNITS: (keyof typeof UNIT_SYMBOLS)[] = [\"meter\", \"second\"];\n\n// SI prefixes which abbreviate in nonstandard ways\nconst SI_PREFIX_ABBVS = {\n  micro: \"μ\",\n  deca: \"da\",\n};\n\n/** Converts a full spatial or temporal unit name supported by OME-Zarr to its unit symbol */\n// (see https://ngff.openmicroscopy.org/latest/#axes-md)\nexport function unitNameToSymbol(unitName?: string): string | null {\n  if (unitName === undefined) {\n    return null;\n  }\n\n  if (UNIT_SYMBOLS[unitName]) {\n    return UNIT_SYMBOLS[unitName];\n  }\n\n  const prefixedSIUnit = SI_UNITS.find((siUnit) => unitName.endsWith(siUnit));\n  if (prefixedSIUnit) {\n    const prefix = unitName.substring(0, unitName.length - prefixedSIUnit.length);\n\n    if (SI_PREFIX_ABBVS[prefix]) {\n      // \"special\" SI prefix\n      return SI_PREFIX_ABBVS[prefix] + UNIT_SYMBOLS[prefixedSIUnit];\n    }\n\n    // almost all SI prefixes are abbreviated by first letter, capitalized if prefix ends with \"a\"\n    const capitalize = prefix.endsWith(\"a\");\n    const prefixAbbr = capitalize ? prefix[0].toUpperCase() : prefix[0];\n    return prefixAbbr + UNIT_SYMBOLS[prefixedSIUnit];\n  }\n\n  return null;\n}\n\n// We want to find the most \"square\" packing of z tw by th tiles.\n// Compute number of rows and columns.\nexport function computePackedAtlasDims(z: number, tw: number, th: number): Vector2 {\n  let nextrows = 1;\n  let nextcols = z;\n  let ratio = (nextcols * tw) / (nextrows * th);\n  let nrows = nextrows;\n  let ncols = nextcols;\n  while (ratio > 1) {\n    nrows = nextrows;\n    ncols = nextcols;\n    nextcols -= 1;\n    nextrows = Math.ceil(z / nextcols);\n    ratio = (nextcols * tw) / (nextrows * th);\n  }\n  return new Vector2(nrows, ncols);\n}\n\nfunction doesSpatialDimensionFitInAtlas(\n  spatialDimZYX: [number, number, number],\n  maxAtlasEdge = MAX_ATLAS_EDGE\n): boolean {\n  // Estimate atlas size\n  const x = spatialDimZYX[2];\n  const y = spatialDimZYX[1];\n  const z = spatialDimZYX[0];\n  const xtiles = Math.floor(maxAtlasEdge / x);\n  const ytiles = Math.floor(maxAtlasEdge / y);\n  return xtiles * ytiles >= z;\n}\n\n/** Picks the largest scale level that can fit into a texture atlas with edges no longer than `maxAtlasEdge`. */\nexport function estimateLevelForAtlas(\n  spatialDimsZYX: [number, number, number][],\n  maxAtlasEdge = MAX_ATLAS_EDGE\n): number | undefined {\n  if (spatialDimsZYX.length <= 1) {\n    return 0;\n  }\n\n  for (let i = 0; i < spatialDimsZYX.length; ++i) {\n    // estimate atlas size:\n    if (doesSpatialDimensionFitInAtlas(spatialDimsZYX[i], maxAtlasEdge)) {\n      return i;\n    }\n  }\n  return undefined;\n}\n\ntype ZYX = [number, number, number];\nconst maxCeil = (val: number): number => Math.max(Math.ceil(val), 1);\nconst scaleDims = (size: Vector3, [z, y, x]: ZYX): ZYX => [\n  maxCeil(z * size.z),\n  maxCeil(y * size.y),\n  maxCeil(x * size.x),\n];\n\nexport function scaleDimsToSubregion(subregion: Box3, dims: ZYX): ZYX {\n  const size = subregion.getSize(new Vector3());\n  return scaleDims(size, dims);\n}\n\nexport function scaleMultipleDimsToSubregion(subregion: Box3, dims: ZYX[]): ZYX[] {\n  const size = subregion.getSize(new Vector3());\n  return dims.map((dim) => scaleDims(size, dim));\n}\n\n/**\n * Picks the best scale level to load based on scale level dimensions and a `LoadSpec`. This calls\n * `estimateLevelForAtlas`, then accounts for `LoadSpec`'s scale level picking properties:\n * - `multiscaleLevel` imposes a minimum scale level (or *maximum* resolution level) to load\n * - `maxAtlasEdge` sets the maximum size of the texture atlas that may be produced by a load\n * - `scaleLevelBias` offsets the scale level index after the optimal level is picked based on `maxAtlasEdge`\n *\n *  This function assumes that `spatialDimsZYX` has already been appropriately scaled to match `loadSpec`'s `subregion`.\n */\nexport function pickLevelToLoadUnscaled(loadSpec: LoadSpec, spatialDimsZYX: ZYX[]): number {\n  if (loadSpec.useExplicitLevel && loadSpec.multiscaleLevel !== undefined) {\n    // clamp to actual allowed level range\n    return Math.max(0, Math.min(spatialDimsZYX.length - 1, loadSpec.multiscaleLevel));\n  }\n\n  let levelToLoad = estimateLevelForAtlas(spatialDimsZYX, loadSpec.maxAtlasEdge);\n  // Check here for whether levelToLoad is within max atlas size?\n  if (levelToLoad !== undefined) {\n    levelToLoad = Math.max(levelToLoad + (loadSpec.scaleLevelBias ?? 0), loadSpec.multiscaleLevel ?? 0);\n    levelToLoad = Math.max(0, Math.min(spatialDimsZYX.length - 1, levelToLoad));\n\n    if (doesSpatialDimensionFitInAtlas(spatialDimsZYX[levelToLoad], loadSpec.maxAtlasEdge)) {\n      return levelToLoad;\n    }\n  }\n\n  // Level to load could not be loaded due to atlas size constraints.\n  if (levelToLoad === undefined) {\n    // No optimal level exists so choose the smallest level to report out\n    levelToLoad = spatialDimsZYX.length - 1;\n  }\n  const smallestDims = spatialDimsZYX[levelToLoad];\n  console.error(\n    `Volume is too large; no multiscale level found that fits in preferred memory footprint. Selected level ${levelToLoad}  has dimensions `,\n    smallestDims,\n    `. Max atlas edge allowed is ${loadSpec.maxAtlasEdge}.`\n  );\n  console.log(\"All available levels: \", spatialDimsZYX);\n\n  return levelToLoad;\n}\n\n/**\n * Picks the best scale level to load based on scale level dimensions and a `LoadSpec`. This calls\n * `estimateLevelForAtlas` and accounts for all properties of `LoadSpec` considered by\n * `pickLevelToLoadUnscaled`, and additionally scales the dimensions of the scale levels to account for the\n * `LoadSpec`'s `subregion` property.\n */\nexport function pickLevelToLoad(loadSpec: LoadSpec, spatialDimsZYX: ZYX[]): number {\n  const scaledDims = scaleMultipleDimsToSubregion(loadSpec.subregion, spatialDimsZYX);\n  return pickLevelToLoadUnscaled(loadSpec, scaledDims);\n}\n\n/** Given the size of a volume in pixels, convert a `Box3` in the 0-1 range to pixels */\nexport function convertSubregionToPixels(region: Box3, size: Vector3): Box3 {\n  const min = region.min.clone().multiply(size).floor();\n  const max = region.max.clone().multiply(size).ceil();\n\n  // ensure it's always valid to specify the same number at both ends and get a single slice\n  if (min.x === max.x && min.x < size.x) {\n    max.x += 1;\n  }\n  if (min.y === max.y && min.y < size.y) {\n    max.y += 1;\n  }\n  if (min.z === max.z && min.z < size.z) {\n    max.z += 1;\n  }\n\n  return new Box3(min, max);\n}\n\n/**\n * Return the subset of `container` specified by `region`, assuming that `region` contains fractional values (between 0\n * and 1). i.e. if `container`'s range on the X axis is 0-4 and `region`'s is 0.25-0.5, the result will have range 1-2.\n */\nexport function composeSubregion(region: Box3, container: Box3): Box3 {\n  const size = container.getSize(new Vector3());\n  const min = region.min.clone().multiply(size).add(container.min);\n  const max = region.max.clone().multiply(size).add(container.min);\n  return new Box3(min, max);\n}\n\nfunction isEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// currently everything needed can come from the imageInfo\n// but in the future each IVolumeLoader could have a completely separate implementation.\nexport function buildDefaultMetadata(rawImageInfo: ImageInfo): Record<string, unknown> {\n  // wrap\n  const imageInfo = new CImageInfo(rawImageInfo);\n  const physicalSize = imageInfo.volumeSize.clone().multiply(imageInfo.physicalPixelSize);\n  const metadata = {};\n  metadata[\"Dimensions\"] = { ...imageInfo.subregionSize };\n  metadata[\"Original dimensions\"] = { ...imageInfo.originalSize };\n  metadata[\"Physical size\"] = {\n    x: physicalSize.x + imageInfo.spatialUnit,\n    y: physicalSize.y + imageInfo.spatialUnit,\n    z: physicalSize.z + imageInfo.spatialUnit,\n  };\n  metadata[\"Physical size per pixel\"] = {\n    x: imageInfo.physicalPixelSize.x + imageInfo.spatialUnit,\n    y: imageInfo.physicalPixelSize.y + imageInfo.spatialUnit,\n    z: imageInfo.physicalPixelSize.z + imageInfo.spatialUnit,\n  };\n  metadata[\"Multiresolution levels\"] = rawImageInfo.multiscaleLevelDims;\n  // TODO decide???? combined or not?\n  metadata[\"Channels\"] = rawImageInfo.combinedNumChannels; //imageInfo.numChannels;\n  metadata[\"Time series frames\"] = imageInfo.times || 1;\n  // don't add User data if it's empty\n  if (rawImageInfo.userData && !isEmpty(rawImageInfo.userData)) {\n    metadata[\"User data\"] = rawImageInfo.userData;\n  }\n  return metadata;\n}\n","import { ThreadableVolumeLoader } from \"./IVolumeLoader.js\";\nimport { OMEZarrLoader, type ZarrLoaderFetchOptions } from \"./OmeZarrLoader.js\";\nimport { JsonImageInfoLoader } from \"./JsonImageInfoLoader.js\";\nimport { RawArrayLoader, RawArrayLoaderOptions } from \"./RawArrayLoader.js\";\nimport { TiffLoader } from \"./TiffLoader.js\";\nimport VolumeCache from \"../VolumeCache.js\";\nimport SubscribableRequestQueue from \"../utils/SubscribableRequestQueue.js\";\n\nexport { PrefetchDirection } from \"./zarr_utils/types.js\";\n\nexport const enum VolumeFileFormat {\n  ZARR = \"zarr\",\n  JSON = \"json\",\n  TIFF = \"tiff\",\n  DATA = \"data\",\n}\n\n// superset of all necessary loader options\nexport type CreateLoaderOptions = {\n  fileType?: VolumeFileFormat;\n  cache?: VolumeCache;\n  queue?: SubscribableRequestQueue;\n  scene?: number;\n  fetchOptions?: ZarrLoaderFetchOptions;\n  rawArrayOptions?: RawArrayLoaderOptions;\n};\n\nexport function pathToFileType(path: string): VolumeFileFormat {\n  if (path.endsWith(\".json\")) {\n    return VolumeFileFormat.JSON;\n  } else if (path.endsWith(\".tif\") || path.endsWith(\".tiff\")) {\n    return VolumeFileFormat.TIFF;\n  }\n  return VolumeFileFormat.ZARR;\n}\n\nexport async function createVolumeLoader(\n  path: string | string[],\n  options?: CreateLoaderOptions\n): Promise<ThreadableVolumeLoader> {\n  const pathString = Array.isArray(path) ? path[0] : path;\n  const fileType = options?.fileType || pathToFileType(pathString);\n\n  switch (fileType) {\n    case VolumeFileFormat.ZARR:\n      return await OMEZarrLoader.createLoader(\n        path,\n        options?.scene,\n        options?.cache,\n        options?.queue,\n        options?.fetchOptions\n      );\n    case VolumeFileFormat.JSON:\n      return new JsonImageInfoLoader(path, options?.cache);\n    case VolumeFileFormat.TIFF:\n      return new TiffLoader(pathString);\n    case VolumeFileFormat.DATA:\n      if (!options?.rawArrayOptions) {\n        throw new Error(\"Must provide RawArrayOptions for RawArrayLoader\");\n      }\n      return new RawArrayLoader(options?.rawArrayOptions.data, options?.rawArrayOptions.metadata);\n  }\n}\n","import { PrefetchDirection, TCZYX } from \"./types\";\n\ntype TZYX = [number, number, number, number];\n\ntype PrefetchDirectionState = {\n  direction: PrefetchDirection;\n  chunks: TCZYX<number>[];\n  start: number;\n  /** May be either a number for all channels or an array of ends per-channels */\n  end: number | number[];\n};\n\nconst allEqual = <T>(arr: T[]): boolean => arr.every((v) => v === arr[0]);\n\nconst pushN = <T>(arr: T[], val: T, n: number): void => {\n  for (let i = 0; i < n; i++) {\n    arr.push(val);\n  }\n};\n\nconst directionToIndex = (dir: PrefetchDirection): number => {\n  const absDir = dir >> 1; // shave off sign bit to get index in TZYX\n  return absDir + Number(absDir !== 0); // convert TZYX -> TCZYX by skipping c (index 1)\n};\n\nfunction updateMinMax(val: number, minmax: [number, number]): void {\n  if (val < minmax[0]) {\n    minmax[0] = val;\n  }\n\n  if (val > minmax[1]) {\n    minmax[1] = val;\n  }\n}\n\n/**\n * Since the user is most likely to want nearby data (in space or time) first, we should prefetch those chunks first.\n *\n * Given a list of just-loaded chunks and some bounds, `ChunkPrefetchIterator` iterates evenly outwards in T/Z/Y/X.\n */\n// NOTE: Assumes `chunks` form a rectangular prism! Will create gaps otherwise! (in practice they always should)\nexport default class ChunkPrefetchIterator {\n  directionStates: PrefetchDirectionState[];\n  priorityDirectionStates: PrefetchDirectionState[];\n\n  constructor(\n    chunks: TCZYX<number>[],\n    tzyxMaxPrefetchOffset: TZYX,\n    tczyxChunksPerSource: TCZYX<number>[],\n    priorityDirections?: PrefetchDirection[],\n    onlyPriorityDirections = false\n  ) {\n    // Get min and max chunk coordinates for T/Z/Y/X\n    const extrema: [number, number][] = [\n      [Infinity, -Infinity],\n      [Infinity, -Infinity],\n      [Infinity, -Infinity],\n      [Infinity, -Infinity],\n    ];\n\n    for (const chunk of chunks) {\n      updateMinMax(chunk[0], extrema[0]);\n      updateMinMax(chunk[2], extrema[1]);\n      updateMinMax(chunk[3], extrema[2]);\n      updateMinMax(chunk[4], extrema[3]);\n    }\n\n    // Create `PrefetchDirectionState`s for each direction\n    this.directionStates = [];\n    this.priorityDirectionStates = [];\n\n    // iterating like this: direction is the index in the flattened entries\n    // and corresponds to our +T, -T, +Z, -Z, +Y, -Y, +X, -X directions in order\n    // because extrema is in TZYX order.\n    for (const [direction, start] of extrema.flat().entries()) {\n      const dimension = direction >> 1; // shave off sign bit to get index in TZYX\n      const tczyxIndex = dimension + Number(dimension !== 0); // convert TZYX -> TCZYX by skipping c (index 1)\n      let end: number | number[];\n      if (direction & 1) {\n        // Positive direction - end is either the max coordinate in the fetched set plus the max offset in this\n        // dimension, or the max chunk coordinate in this dimension, whichever comes first\n        const endsPerSource = tczyxChunksPerSource.map((chunkDims) => {\n          return Math.min(start + tzyxMaxPrefetchOffset[dimension], chunkDims[tczyxIndex] - 1);\n        });\n\n        // Save some time: if all sources have the same end, we can just store that\n        if (allEqual(endsPerSource)) {\n          end = endsPerSource[0];\n        } else {\n          // Otherwise, expand our ends per source array to ends per channel\n          end = [];\n          for (const [i, sourceEnd] of endsPerSource.entries()) {\n            pushN(end, sourceEnd, tczyxChunksPerSource[i][1]);\n          }\n        }\n        // end = Math.min(start + tzyxMaxPrefetchOffset[dimension], tczyxChunksPerDimension[dimension] - 1);\n      } else {\n        // Negative direction - end is either the min coordinate in the fetched set minus the max offset in this\n        // dimension, or 0, whichever comes first\n        end = Math.max(start - tzyxMaxPrefetchOffset[dimension], 0);\n      }\n      const directionState = { direction, start, end, chunks: [] };\n\n      if (priorityDirections && priorityDirections.includes(direction)) {\n        this.priorityDirectionStates.push(directionState);\n      } else {\n        // we have an option setting that can let us ignore non-priority directions\n        if (!onlyPriorityDirections) {\n          this.directionStates.push(directionState);\n        }\n      }\n    }\n\n    // Fill each `PrefetchDirectionState` with chunks at the border of the fetched set\n    for (const chunk of chunks) {\n      for (const dir of this.directionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n      for (const dir of this.priorityDirectionStates) {\n        if (chunk[directionToIndex(dir.direction)] === dir.start) {\n          dir.chunks.push(chunk);\n        }\n      }\n    }\n  }\n\n  private static *iterateDirections(directions: PrefetchDirectionState[]): Generator<TCZYX<number>> {\n    let offset = 1;\n\n    while (directions.length > 0) {\n      // Remove directions in which we have reached the end (or, if per-channel ends, the end for all channels)\n      directions = directions.filter((dir) => {\n        const end = Array.isArray(dir.end) ? Math.max(...dir.end) : dir.end;\n        if (dir.direction & 1) {\n          return dir.start + offset <= end;\n        } else {\n          return dir.start - offset >= end;\n        }\n      });\n\n      // Yield chunks one chunk farther out in every remaining direction\n      for (const dir of directions) {\n        const offsetDir = offset * (dir.direction & 1 ? 1 : -1);\n        for (const chunk of dir.chunks) {\n          // Skip this chunk if this channel has a specific per-channel end and we've reached it\n          if (Array.isArray(dir.end) && chunk[directionToIndex(dir.direction)] + offsetDir > dir.end[chunk[1]]) {\n            continue;\n          }\n          const newChunk = chunk.slice() as TCZYX<number>;\n          newChunk[directionToIndex(dir.direction)] += offsetDir;\n          yield newChunk;\n        }\n      }\n\n      offset += 1;\n    }\n  }\n\n  *[Symbol.iterator](): Iterator<TCZYX<number>> {\n    // Yield all chunks in priority direction(s) first, if any\n    if (this.priorityDirectionStates.length > 0) {\n      for (const chunk of ChunkPrefetchIterator.iterateDirections(this.priorityDirectionStates)) {\n        yield chunk;\n      }\n    }\n\n    // Then yield all chunks in other directions\n    for (const chunk of ChunkPrefetchIterator.iterateDirections(this.directionStates)) {\n      yield chunk;\n    }\n  }\n}\n","import { FetchStore } from \"zarrita\";\nimport { AbsolutePath, AsyncMutable, Readable } from \"@zarrita/storage\";\n\nimport SubscribableRequestQueue from \"../../utils/SubscribableRequestQueue\";\nimport VolumeCache from \"../../VolumeCache\";\n\nimport { SubscriberId } from \"./types\";\n\ntype WrappedStoreOpts<Opts> = {\n  options?: Opts;\n  subscriber: SubscriberId;\n  reportKey?: (key: string, subscriber: SubscriberId) => void;\n  isPrefetch?: boolean;\n};\n\n/**\n * `Readable` is zarrita's minimal abstraction for any source of data.\n * `WrappedStore` wraps another `Readable` and adds (optional) connections to `VolumeCache` and `RequestQueue`.\n */\nclass WrappedStore<Opts, S extends Readable<Opts> = Readable<Opts>> implements AsyncMutable<WrappedStoreOpts<Opts>> {\n  constructor(private baseStore: S, private cache?: VolumeCache, private queue?: SubscribableRequestQueue) {}\n  // Dummy implementation to make this class easier to use in tests\n  set(_key: AbsolutePath, _value: Uint8Array): Promise<void> {\n    return Promise.resolve();\n  }\n\n  private async getAndCache(key: AbsolutePath, cacheKey: string, opts?: Opts): Promise<Uint8Array | undefined> {\n    const result = await this.baseStore.get(key, opts);\n    if (this.cache && result) {\n      this.cache.insert(cacheKey, result);\n    }\n    return result;\n  }\n\n  async get(key: AbsolutePath, opts?: WrappedStoreOpts<Opts> | undefined): Promise<Uint8Array | undefined> {\n    const ZARR_EXTS = [\".zarray\", \".zgroup\", \".zattrs\", \"zarr.json\"];\n    if (!this.cache || ZARR_EXTS.some((s) => key.endsWith(s))) {\n      return this.baseStore.get(key, opts?.options);\n    }\n    if (opts?.reportKey) {\n      opts.reportKey(key, opts.subscriber);\n    }\n\n    let keyPrefix = (this.baseStore as FetchStore).url ?? \"\";\n    if (keyPrefix !== \"\" && !(keyPrefix instanceof URL) && !keyPrefix.endsWith(\"/\")) {\n      keyPrefix += \"/\";\n    }\n\n    const fullKey = keyPrefix + key.slice(1);\n\n    // Check the cache\n    const cacheResult = this.cache.get(fullKey);\n    if (cacheResult) {\n      return new Uint8Array(cacheResult);\n    }\n\n    // Not in cache; load the chunk and cache it\n    if (this.queue && opts) {\n      return this.queue.addRequest(\n        fullKey,\n        opts.subscriber,\n        () => this.getAndCache(key, fullKey, opts?.options),\n        opts.isPrefetch\n      );\n    } else {\n      // Should we ever hit this code?  We should always have a request queue.\n      return this.getAndCache(key, fullKey, opts?.options);\n    }\n  }\n}\n\nexport default WrappedStore;\n","import * as zarr from \"@zarrita/core\";\n\nimport type WrappedStore from \"./WrappedStore.js\";\nimport type SubscribableRequestQueue from \"../../utils/SubscribableRequestQueue.js\";\n\nexport type TCZYX<T> = [T, T, T, T, T];\nexport type SubscriberId = ReturnType<SubscribableRequestQueue[\"addSubscriber\"]>;\n\n/**\n * Directions in which to move outward from the loaded set of chunks while prefetching.\n *\n * Ordered in pairs of opposite directions both because that's a sensible order in which to prefetch for our purposes,\n * and because it lets us treat the least significant bit as the sign. So `direction >> 1` gives the index of the\n * direction in TZYX-ordered arrays, and `direction & 1` gives the sign of the direction (e.g. positive vs negative Z).\n */\nexport const enum PrefetchDirection {\n  T_MINUS = 0,\n  T_PLUS = 1,\n\n  Z_MINUS = 2,\n  Z_PLUS = 3,\n\n  Y_MINUS = 4,\n  Y_PLUS = 5,\n\n  X_MINUS = 6,\n  X_PLUS = 7,\n}\n\nexport type OMECoordinateTransformation =\n  | {\n      type: \"identity\";\n    }\n  | {\n      type: \"translation\";\n      translation: number[];\n    }\n  | {\n      type: \"scale\";\n      scale: number[];\n    }\n  | {\n      type: \"translation\" | \"scale\";\n      path: string;\n    };\n\nexport type OMEAxis = {\n  name: string;\n  type?: string;\n  unit?: string;\n};\n\nexport type OMEDataset = {\n  path: string;\n  coordinateTransformations?: OMECoordinateTransformation[];\n};\n\n/** https://ngff.openmicroscopy.org/latest/#multiscale-md */\nexport type OMEMultiscale = {\n  version?: string;\n  name?: string;\n  axes: OMEAxis[];\n  datasets: OMEDataset[];\n  coordinateTransformations?: OMECoordinateTransformation[];\n  type?: string;\n  metadata?: Record<string, unknown>;\n};\n\n/** https://ngff.openmicroscopy.org/latest/#omero-md */\nexport type OmeroTransitionalMetadata = {\n  id: number;\n  name: string;\n  version: string;\n  channels: {\n    active: boolean;\n    coefficient: number;\n    color: string;\n    family: string;\n    inverted: boolean;\n    label: string;\n    window: {\n      end: number;\n      max: number;\n      min: number;\n      start: number;\n    };\n  }[];\n};\n\nexport type OMEZarrMetadata = {\n  multiscales: OMEMultiscale[];\n  omero: OmeroTransitionalMetadata;\n};\n\nexport type NumericZarrArray = zarr.Array<zarr.NumberDataType, WrappedStore<RequestInit>>;\n\n/** A record with everything we need to access and use a single remote source of multiscale OME-Zarr data. */\nexport type ZarrSource = {\n  /** Representations of each scale level in this zarr. We pick one and pass it to zarrita to load data. */\n  scaleLevels: NumericZarrArray[];\n  /**\n   * Zarr dimensions may be ordered in many ways or missing altogether (e.g. TCXYZ, TYX). `axesTCZYX` represents\n   * dimension order as a mapping from dimensions to their indices in dimension-ordered arrays for this source.\n   */\n  axesTCZYX: TCZYX<number>;\n  /** OME-specified metadata record with most useful info on the current image, e.g. sizes, axis order, etc. */\n  multiscaleMetadata: OMEMultiscale;\n  /** OME-specified \"transitional\" metadata record which we mostly ignore, but which gives channel & volume names. */\n  omeroMetadata?: OmeroTransitionalMetadata;\n  /** Which channels in the volume come out of this source - i.e. source channel 0 is volume channel `channelOffset` */\n  channelOffset: number;\n};\n","import { VolumeLoadErrorType, VolumeLoadError } from \"../VolumeLoadError.js\";\nimport type {\n  NumericZarrArray,\n  OMEAxis,\n  OMECoordinateTransformation,\n  OMEDataset,\n  OMEMultiscale,\n  TCZYX,\n  ZarrSource,\n} from \"./types.js\";\n\n/** Extracts channel names from a `ZarrSource`. Handles missing `omeroMetadata`. Does *not* resolve name collisions. */\nexport function getSourceChannelNames(src: ZarrSource): string[] {\n  if (src.omeroMetadata?.channels) {\n    return src.omeroMetadata.channels.map(({ label }, idx) => label ?? `Channel ${idx + src.channelOffset}`);\n  }\n  const length = src.scaleLevels[0].shape[src.axesTCZYX[1]];\n  return Array.from({ length }, (_, idx) => `Channel ${idx + src.channelOffset}`);\n}\n\n/** Turns `axesTCZYX` into the number of dimensions in the array */\nexport const getDimensionCount = ([t, c, z]: TCZYX<number>) => 2 + Number(t > -1) + Number(c > -1) + Number(z > -1);\n\nexport function remapAxesToTCZYX(axes: OMEAxis[]): TCZYX<number> {\n  const axesTCZYX: TCZYX<number> = [-1, -1, -1, -1, -1];\n  const axisNames = [\"t\", \"c\", \"z\", \"y\", \"x\"];\n\n  axes.forEach((axis, idx) => {\n    const axisIdx = axisNames.indexOf(axis.name);\n    if (axisIdx > -1) {\n      axesTCZYX[axisIdx] = idx;\n    } else {\n      throw new VolumeLoadError(`Unrecognized axis in zarr: ${axis.name}`, {\n        type: VolumeLoadErrorType.INVALID_METADATA,\n      });\n    }\n  });\n\n  // it is possible that Z might not exist but we require X and Y at least.\n  const noXAxis = axesTCZYX[4] === -1;\n  if (noXAxis || axesTCZYX[3] === -1) {\n    throw new VolumeLoadError(`Did not find ${noXAxis ? \"an X\" : \"a Y\"} axis in zarr`, {\n      type: VolumeLoadErrorType.INVALID_METADATA,\n    });\n  }\n\n  return axesTCZYX;\n}\n\n/** Reorder an array of values [T, C, Z, Y, X] to the given dimension order */\nexport function orderByDimension<T>(valsTCZYX: TCZYX<T>, orderTCZYX: TCZYX<number>): T[] {\n  const specLen = getDimensionCount(orderTCZYX);\n  const result: T[] = Array(specLen);\n\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= specLen) {\n        throw new VolumeLoadError(`Unexpected axis index in zarr: ${val}`, {\n          type: VolumeLoadErrorType.INVALID_METADATA,\n        });\n      }\n      result[val] = valsTCZYX[idx];\n    }\n  });\n\n  return result;\n}\n\n/** Reorder an array of values in the given dimension order to [T, C, Z, Y, X] */\nexport function orderByTCZYX<T>(valsDimension: T[], orderTCZYX: TCZYX<number>, defaultValue: T): TCZYX<T> {\n  const result: TCZYX<T> = [defaultValue, defaultValue, defaultValue, defaultValue, defaultValue];\n\n  orderTCZYX.forEach((val, idx) => {\n    if (val >= 0) {\n      if (val >= valsDimension.length) {\n        throw new VolumeLoadError(`Unexpected axis index in zarr: ${val}`, {\n          type: VolumeLoadErrorType.INVALID_METADATA,\n        });\n      }\n      result[idx] = valsDimension[val];\n    }\n  });\n\n  return result;\n}\n\n/** Select the scale transform from an OME metadata object with coordinate transforms, and return it in TCZYX order */\nexport function getScale(dataset: OMEDataset | OMEMultiscale, orderTCZYX: TCZYX<number>): TCZYX<number> {\n  const transforms = dataset.coordinateTransformations;\n\n  if (transforms === undefined) {\n    console.warn(\"WARNING: OMEZarrLoader: no coordinate transformations for scale level.\");\n    return [1, 1, 1, 1, 1];\n  }\n\n  // this assumes we'll never encounter the \"path\" variant\n  const isScaleTransform = (t: OMECoordinateTransformation): t is { type: \"scale\"; scale: number[] } =>\n    t.type === \"scale\";\n\n  // there can be any number of coordinateTransformations\n  // but there must be only one of type \"scale\".\n  const scaleTransform = transforms.find(isScaleTransform);\n  if (!scaleTransform) {\n    console.warn(`WARNING: OMEZarrLoader: no coordinate transformation of type \"scale\" for scale level.`);\n    return [1, 1, 1, 1, 1];\n  }\n\n  const scale = scaleTransform.scale.slice();\n  return orderByTCZYX(scale, orderTCZYX, 1);\n}\n\n/**\n * Defines a partial order of zarr arrays based on their size. Specifically:\n * - If array size x, y, z are all equal, the arrays are equal\n * - otherwise, if all xyz of `a` are less than or equal to those of `b`, `a` is less than `b` (and vice versa)\n * - if some xyz is less and some is greater, the arrays are uncomparable\n */\nfunction compareZarrArraySize(\n  aArr: NumericZarrArray,\n  aTCZYX: TCZYX<number>,\n  bArr: NumericZarrArray,\n  bTCZYX: TCZYX<number>\n): number | undefined {\n  const aZ = aTCZYX[2] > -1 ? aArr.shape[aTCZYX[2]] : 1;\n  const bZ = bTCZYX[2] > -1 ? bArr.shape[bTCZYX[2]] : 1;\n  const diffZ = aZ - bZ;\n  const diffY = aArr.shape[aTCZYX[3]] - bArr.shape[bTCZYX[3]];\n  const diffX = aArr.shape[aTCZYX[4]] - bArr.shape[bTCZYX[4]];\n\n  if (diffZ === 0 && diffY === 0 && diffX === 0) {\n    return 0;\n  } else if (diffZ <= 0 && diffY <= 0 && diffX <= 0) {\n    return -1;\n  } else if (diffZ >= 0 && diffY >= 0 && diffX >= 0) {\n    return 1;\n  } else {\n    return undefined;\n  }\n}\n\nconst EPSILON = 0.00001;\nconst aboutEquals = (a: number, b: number): boolean => Math.abs(a - b) < EPSILON;\n\nfunction scaleTransformsAreEqual(aSrc: ZarrSource, aLevel: number, bSrc: ZarrSource, bLevel: number): boolean {\n  const aScale = getScale(aSrc.multiscaleMetadata.datasets[aLevel], aSrc.axesTCZYX);\n  const bScale = getScale(bSrc.multiscaleMetadata.datasets[bLevel], bSrc.axesTCZYX);\n  return aboutEquals(aScale[2], bScale[2]) && aboutEquals(aScale[3], bScale[3]) && aboutEquals(aScale[4], bScale[4]);\n}\n\n/**\n * Ensures that all scale levels in `sources` are matched up by size. More precisely: enforces that, for any scale\n * level `i`, the size of zarr array `s[i]` is equal for every source `s`. We accomplish this by removing any arrays\n * (and their associated OME dataset metadata) which don't match up in all sources.\n *\n * Note that this function modifies the input `sources` array rather than returning a new value.\n *\n * Assumes all sources have scale levels ordered by size from largest to smallest. (This should always be true for\n * compliant OME-Zarr data.)\n */\nexport function matchSourceScaleLevels(sources: ZarrSource[]): void {\n  if (sources.length < 2) {\n    return;\n  }\n\n  // Save matching scale levels and metadata here\n  const matchedLevels: NumericZarrArray[][] = Array.from({ length: sources.length }, () => []);\n  const matchedMetas: OMEDataset[][] = Array.from({ length: sources.length }, () => []);\n\n  // Start as many index counters as we have sources\n  const scaleIndexes: number[] = new Array(sources.length).fill(0);\n  while (scaleIndexes.every((val, idx) => val < sources[idx].scaleLevels.length)) {\n    // First pass: find the smallest source / determine if all sources are equal\n    let allEqual = true;\n    let smallestIdx = 0;\n    let smallestSrc = sources[0];\n    let smallestArr = smallestSrc.scaleLevels[scaleIndexes[0]];\n    for (let currentIdx = 1; currentIdx < sources.length; currentIdx++) {\n      const currentSrc = sources[currentIdx];\n      const currentArr = currentSrc.scaleLevels[scaleIndexes[currentIdx]];\n\n      const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n      if (!ordering) {\n        // Arrays are equal, or they are uncomparable\n        if (ordering === undefined) {\n          throw new VolumeLoadError(\"Incompatible zarr arrays: pixel dimensions are mismatched\", {\n            type: VolumeLoadErrorType.INVALID_MULTI_SOURCE_ZARR,\n          });\n        }\n\n        // Now we know the arrays are equal, but they may still be invalid to match up because...\n        // ...they have different scale transformations\n        if (!scaleTransformsAreEqual(smallestSrc, scaleIndexes[smallestIdx], currentSrc, scaleIndexes[currentIdx])) {\n          // today we are going to treat this as a warning.\n          // For our implementation it is enough that the xyz pixel ranges are the same.\n          // Ideally scale*arraysize=physical size is really the quantity that should be equal, for combining two volume data sets as channels.\n          console.warn(\"Incompatible zarr arrays: scale levels of equal size have different scale transformations\");\n        }\n\n        // ...they have different numbers of timesteps\n        const largestT = smallestSrc.axesTCZYX[0] > -1 ? smallestArr.shape[smallestSrc.axesTCZYX[0]] : 1;\n        const currentT = currentSrc.axesTCZYX[0] > -1 ? currentArr.shape[currentSrc.axesTCZYX[0]] : 1;\n        if (largestT !== currentT) {\n          // we also treat this as a warning.\n          // In OmeZarrLoader we will take the minimum T size of all sources\n          console.warn(`Incompatible zarr arrays: different numbers of timesteps: ${largestT} vs ${currentT}`);\n        }\n      } else {\n        allEqual = false;\n        if (ordering > 0) {\n          smallestIdx = currentIdx;\n          smallestSrc = currentSrc;\n          smallestArr = currentArr;\n        }\n      }\n    }\n\n    if (allEqual) {\n      // We've found a matching set of scale levels! Save it and increment all indexes\n      for (let i = 0; i < scaleIndexes.length; i++) {\n        const currentSrc = sources[i];\n        const matchedScaleLevel = scaleIndexes[i];\n        matchedLevels[i].push(currentSrc.scaleLevels[matchedScaleLevel]);\n        matchedMetas[i].push(currentSrc.multiscaleMetadata.datasets[matchedScaleLevel]);\n        scaleIndexes[i] += 1;\n      }\n    } else {\n      // Increment the indexes of the sources which are larger than the smallest\n      for (const [idx, srcIdx] of scaleIndexes.entries()) {\n        const currentSrc = sources[idx];\n        const currentArr = currentSrc.scaleLevels[srcIdx];\n        const ordering = compareZarrArraySize(smallestArr, smallestSrc.axesTCZYX, currentArr, currentSrc.axesTCZYX);\n        if (ordering !== 0) {\n          scaleIndexes[idx] += 1;\n        }\n      }\n    }\n  }\n\n  if (sources[0].scaleLevels.length === 0) {\n    throw new VolumeLoadError(\"Incompatible zarr arrays: no sets of scale levels found that matched in all sources\", {\n      type: VolumeLoadErrorType.INVALID_MULTI_SOURCE_ZARR,\n    });\n  }\n\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].scaleLevels = matchedLevels[i];\n    sources[i].multiscaleMetadata.datasets = matchedMetas[i];\n  }\n}\n","import { VolumeLoadError, VolumeLoadErrorType } from \"../VolumeLoadError.js\";\nimport { OMEZarrMetadata } from \"./types.js\";\n\nfunction isObjectWithProp<P extends string>(obj: unknown, prop: P): obj is Record<P, unknown> {\n  return typeof obj === \"object\" && obj !== null && prop in obj;\n}\n\nfunction assertMetadataHasProp<P extends string>(\n  obj: unknown,\n  prop: P,\n  name = \"zarr\"\n): asserts obj is Record<P, unknown> {\n  if (!isObjectWithProp(obj, prop)) {\n    throw new VolumeLoadError(`${name} metadata is missing required entry \"${prop}\"`, {\n      type: VolumeLoadErrorType.INVALID_METADATA,\n    });\n  }\n}\n\nfunction assertPropIsArray<P extends string>(\n  obj: Record<P, unknown>,\n  prop: P,\n  name = \"zarr\"\n): asserts obj is Record<P, unknown[]> {\n  if (!Array.isArray(obj[prop])) {\n    throw new VolumeLoadError(`${name} metadata entry \"${prop}\" is not an array`, {\n      type: VolumeLoadErrorType.INVALID_METADATA,\n    });\n  }\n}\n\n/**\n * Validates that the `OMEZarrMetadata` record `data` has the minimal amount of data required to open a volume. Since\n * we only ever open one multiscale, we only validate the multiscale metadata record at index `multiscaleIdx` here.\n * `name` is used in error messages to identify the source of the metadata.\n */\nexport function validateOMEZarrMetadata(\n  data: unknown,\n  multiscaleIdx = 0,\n  name = \"zarr\"\n): asserts data is OMEZarrMetadata {\n  // data is an object with a key \"multiscales\", which is an array\n  assertMetadataHasProp(data, \"multiscales\", name);\n  assertPropIsArray(data, \"multiscales\", name);\n\n  // check that a multiscale metadata entry exists at `multiscaleIdx`\n  const multiscaleMeta = data.multiscales[multiscaleIdx];\n  if (!multiscaleMeta) {\n    throw new VolumeLoadError(`${name} metadata does not have requested multiscale level ${multiscaleIdx}`, {\n      type: VolumeLoadErrorType.INVALID_METADATA,\n    });\n  }\n\n  const multiscaleMetaName = isObjectWithProp(multiscaleMeta, \"name\") ? ` (\"${multiscaleMeta.name})` : \"\";\n  const multiscaleName = `${name} multiscale ${multiscaleIdx}${multiscaleMetaName}`;\n\n  // multiscale has a key \"axes\", which is an array. Each axis has a \"name\".\n  assertMetadataHasProp(multiscaleMeta, \"axes\", multiscaleName);\n  assertPropIsArray(multiscaleMeta, \"axes\", multiscaleName);\n  multiscaleMeta.axes.forEach((axis, i) => assertMetadataHasProp(axis, \"name\", `${multiscaleName} axis ${i}`));\n\n  // multiscale has a key \"datasets\", which is an array. Each dataset has a \"path\".\n  assertMetadataHasProp(multiscaleMeta, \"datasets\", name);\n  assertPropIsArray(multiscaleMeta, \"datasets\", name);\n  multiscaleMeta.datasets.forEach((data, i) => assertMetadataHasProp(data, \"path\", `${multiscaleName} dataset ${i}`));\n}\n","import { Camera, OrthographicCamera, PerspectiveCamera, Vector3 } from \"three\";\n\nexport interface Bounds {\n  bmin: Vector3;\n  bmax: Vector3;\n}\n\n// numeric types compatible with zarrita.js.\n// see https://github.com/manzt/zarrita.js/blob/main/packages/core/src/metadata.ts\nexport type Int8 = \"int8\";\nexport type Int16 = \"int16\";\nexport type Int32 = \"int32\";\nexport type Int64 = \"int64\";\nexport type Uint8 = \"uint8\";\nexport type Uint16 = \"uint16\";\nexport type Uint32 = \"uint32\";\nexport type Uint64 = \"uint64\";\nexport type Float32 = \"float32\";\nexport type Float64 = \"float64\";\nexport type NumberType = Int8 | Int16 | Int32 | Uint8 | Uint16 | Uint32 | Float32 | Float64;\nexport type TypedArray<D> = D extends Int8\n  ? Int8Array\n  : D extends Int16\n  ? Int16Array\n  : D extends Int32\n  ? Int32Array\n  : D extends Int64\n  ? BigInt64Array\n  : D extends Uint8\n  ? Uint8Array\n  : D extends Uint16\n  ? Uint16Array\n  : D extends Uint32\n  ? Uint32Array\n  : D extends Uint64\n  ? BigUint64Array\n  : D extends Float32\n  ? Float32Array\n  : D extends Float64\n  ? Float64Array\n  : never;\n\nexport const ARRAY_CONSTRUCTORS = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  int64: globalThis.BigInt64Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  uint64: globalThis.BigUint64Array,\n  float32: Float32Array,\n  float64: Float64Array,\n};\n\nexport interface FuseChannel {\n  chIndex: number;\n  lut: Uint8Array;\n  // zero is a sentinel value to disable from fusion\n  rgbColor: [number, number, number] | number;\n}\n\n/** If `FuseChannel.rgbColor` is this value, it is disabled from fusion. */\nexport const FUSE_DISABLED_RGB_COLOR = 0;\n\n/**\n * Provide options to control the visual appearance of a Volume\n * @typedef {Object} VolumeChannelDisplayOptions\n * @property {boolean} enabled array of boolean per channel\n * @property {Array.<number>} color array of rgb per channel\n * @property {Array.<number>} specularColor array of rgb per channel\n * @property {Array.<number>} emissiveColor array of rgb per channel\n * @property {number} glossiness array of float per channel\n * @property {boolean} isosurfaceEnabled array of boolean per channel\n * @property {number} isovalue array of number per channel\n * @property {number} isosurfaceOpacity array of number per channel\n * @example let options = {\n   };\n */\nexport interface VolumeChannelDisplayOptions {\n  enabled?: boolean;\n  color?: [number, number, number];\n  specularColor?: [number, number, number];\n  emissiveColor?: [number, number, number];\n  glossiness?: number;\n  isosurfaceEnabled?: boolean;\n  isovalue?: number;\n  isosurfaceOpacity?: number;\n}\n\nexport enum RenderMode {\n  RAYMARCH = 0,\n  PATHTRACE = 1,\n  SLICE = 2,\n}\n\n/**\n * Provide options to control the visual appearance of a Volume\n * @typedef {Object} VolumeDisplayOptions\n * @property {Array.<VolumeChannelDisplayOptions>} channels array of channel display options\n * @property {number} density\n * @property {Array.<number>} translation xyz\n * @property {Array.<number>} rotation xyz angles in radians\n * @property {number} maskChannelIndex\n * @property {number} maskAlpha\n * @property {Array.<number>} clipBounds [xmin, xmax, ymin, ymax, zmin, zmax] all range from 0 to 1 as a percentage of the volume on that axis\n * @property {Array.<number>} scale xyz voxel size scaling\n * @property {boolean} maxProjection true or false (ray marching)\n * @property {number} renderMode 0 for raymarch, 1 for pathtrace\n * @property {number} shadingMethod 0 for phase, 1 for brdf, 2 for hybrid (path tracer)\n * @property {Array.<number>} gamma [min, max, scale]\n * @property {number} primaryRayStepSize in voxels\n * @property {number} secondaryRayStepSize in voxels\n * @property {boolean} showBoundingBox true or false\n * @property {Array.<number>} boundingBoxColor r,g,b for bounding box lines\n * @example let options = {\n   };\n */\nexport interface VolumeDisplayOptions {\n  channels?: VolumeChannelDisplayOptions[];\n  density?: number;\n  translation?: [number, number, number];\n  rotation?: [number, number, number];\n  maskChannelIndex?: number;\n  maskAlpha?: number;\n  clipBounds?: [number, number, number, number, number, number];\n  maxProjection?: boolean;\n  renderMode?: RenderMode;\n  shadingMethod?: number;\n  gamma?: [number, number, number];\n  primaryRayStepSize?: number;\n  secondaryRayStepSize?: number;\n  showBoundingBox?: boolean;\n  boundingBoxColor?: [number, number, number];\n}\n\nexport const isOrthographicCamera = (def: Camera): def is OrthographicCamera =>\n  def && (def as OrthographicCamera).isOrthographicCamera;\n\nexport const isPerspectiveCamera = (def: Camera): def is PerspectiveCamera =>\n  def && (def as PerspectiveCamera).isPerspectiveCamera;\n\nexport const enum ViewportCorner {\n  TOP_LEFT = \"top_left\",\n  TOP_RIGHT = \"top_right\",\n  BOTTOM_LEFT = \"bottom_left\",\n  BOTTOM_RIGHT = \"bottom_right\",\n}\nexport const isTop = (corner: ViewportCorner): boolean =>\n  corner === ViewportCorner.TOP_LEFT || corner === ViewportCorner.TOP_RIGHT;\nexport const isRight = (corner: ViewportCorner): boolean =>\n  corner === ViewportCorner.TOP_RIGHT || corner === ViewportCorner.BOTTOM_RIGHT;\n\nexport const DATARANGE_UINT8: [number, number] = [0, 255];\n","/** Object format used when passing multiple requests to RequestQueue at once. */\nexport type Request<V> = {\n  key: string;\n  requestAction: () => Promise<V>;\n};\n\nexport const DEFAULT_REQUEST_CANCEL_REASON = \"request cancelled\";\n\n/**\n * Internal object interface used by RequestQueue to store request metadata and callbacks.\n */\ninterface RequestItem<V> {\n  /** Key used to index this queue item. */\n  key: string;\n  /** Action to be run. */\n  action: () => Promise<V>;\n  /** Reference to the promise object that will be resolved when the action is complete. */\n  promise: Promise<V>;\n  /** Callback used to resolve the promise. */\n  resolve: (value?: V | PromiseLike<V> | undefined) => void;\n  /** Callback used to reject the promise. */\n  reject: (reason?: unknown) => void;\n  /** Optional, used to track timeouts if the item will be added to the queue later. */\n  timeoutId?: ReturnType<typeof setTimeout>;\n}\n\n/**\n * Manages a queue of asynchronous requests with unique string keys, which can be added to or cancelled.\n * If redundant requests with the same key are issued, the request action will only be run once per key\n * while the original request is still in the queue.\n */\nexport default class RequestQueue {\n  /**\n   * The maximum number of requests that can be handled concurrently.\n   * Once reached, additional requests will be queued up to run once a running request completes.\n   */\n  private maxActiveRequests: number;\n\n  /**\n   * The maximum number of requests that can be handled concurrently if only low-priority requests are waiting. Set\n   * lower than `concurrencyLimit` to always leave space for high-priority requests. Cannot be set higher than\n   * `concurrencyLimit`.\n   */\n  private maxLowPriorityRequests: number;\n\n  /** A queue of requests that are ready to be executed, in order of request time. */\n  private queue: string[];\n\n  /** A queue of low-priority tasks that are ready to be executed. `queue` must be empty before any of these tasks run. */\n  private queueLowPriority: string[];\n\n  /** Stores all requests, even those that are currently active. */\n  private allRequests: Map<string, RequestItem<unknown>>;\n\n  /** Stores requests whose actions are currently being run. */\n  private activeRequests: Set<string>;\n\n  /**\n   * Creates a new RequestQueue.\n   * @param maxActiveRequests The maximum number of requests that will be handled concurrently. This is 10 by default.\n   * @param maxLowPriorityRequests The maximum number of low-priority requests that will be handled concurrently. Equal\n   *    to `maxActiveRequests` by default, but may be set lower to always leave space for new high-priority requests.\n   */\n  constructor(maxActiveRequests = 10, maxLowPriorityRequests = 5) {\n    this.allRequests = new Map();\n    this.activeRequests = new Set();\n    this.queue = [];\n    this.queueLowPriority = [];\n    this.maxActiveRequests = maxActiveRequests;\n    this.maxLowPriorityRequests = Math.min(maxActiveRequests, maxLowPriorityRequests);\n  }\n\n  /**\n   * Stores request metadata to the internal map of all pending requests.\n   * @param key string identifier of the request.\n   * @param requestAction callable function action of the request.\n   * @returns a reference to the new, registered RequestItem.\n   */\n  private registerRequest<T>(key: string, requestAction: () => Promise<T>): RequestItem<T> {\n    // Create a new promise and store the resolve and reject callbacks for later.\n    // This lets us perform the actual action at a later point, when the request is at the\n    // front of the processing queue.\n    let promiseResolve, promiseReject;\n    const promise = new Promise<T>((resolve, reject) => {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n    // Store the request data.\n    const requestItem = {\n      key: key,\n      action: requestAction,\n      resolve: promiseResolve,\n      reject: promiseReject,\n      promise,\n    };\n    this.allRequests.set(key, requestItem);\n    return requestItem;\n  }\n\n  /**\n   * Moves a registered request into the processing queue, clearing any timeouts on the request.\n   * @param key string identifier of the request.\n   * @param lowPriority Whether this request should be added with low priority. False by default.\n   */\n  private addRequestToQueue(key: string, lowPriority?: boolean): void {\n    // Check that this request is not cancelled.\n    if (this.allRequests.has(key)) {\n      // Clear the request timeout, if it has one, since it is being added to the queue.\n      const requestItem = this.allRequests.get(key);\n      if (requestItem && requestItem.timeoutId) {\n        clearTimeout(requestItem.timeoutId);\n        requestItem.timeoutId = undefined;\n      }\n      if (!this.queue.includes(key) && !this.queueLowPriority.includes(key)) {\n        // Add to queue and check if the request can be processed right away.\n        if (lowPriority) {\n          this.queueLowPriority.push(key);\n        } else {\n          this.queue.push(key);\n        }\n        this.dequeue();\n      }\n    }\n  }\n\n  /**\n   * Adds a request with a unique key to the queue, if it doesn't already exist.\n   * @param key The key used to track the request.\n   * @param requestAction Function that will be called to complete the request. The function\n   *  will be run only once per unique key while the request exists, and may be deferred by the\n   *  queue at any time.\n   * @param lowPriority Whether this request should be added with low priority. False by default.\n   * @param delayMs Minimum delay, in milliseconds, before this request should be executed.\n   *\n   * NOTE: Cancelling a request while the action is running WILL NOT stop the action. If this behavior is desired,\n   * actions must be responsible for checking the RequestQueue, determining if the request is still valid (e.g.\n   * using `.hasRequest()`), and stopping or returning early.\n   *\n   * @returns A promise that will resolve on completion of the request, or reject if the request is cancelled.\n   *  If multiple requests are issued with the same key, a promise for the first request will be returned\n   *  until the request is resolved or cancelled.\n   *  Note that the return type of the promise will match that of the first request's instance.\n   */\n  public addRequest<T>(key: string, requestAction: () => Promise<T>, lowPriority = false, delayMs = 0): Promise<T> {\n    if (!this.allRequests.has(key)) {\n      // New request!\n      const requestItem = this.registerRequest(key, requestAction);\n      // If a delay is set, wait to add this to the queue.\n      if (delayMs > 0) {\n        const timeoutId = setTimeout(() => this.addRequestToQueue(key, lowPriority), delayMs);\n        // Save timeout information to request metadata\n        requestItem.timeoutId = timeoutId;\n      } else {\n        // No delay, add immediately\n        this.addRequestToQueue(key, lowPriority);\n      }\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1 && !lowPriority) {\n        // This request is registered and queued, but is now being requested with high priority.\n        // Promote it to high priority.\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n        this.addRequestToQueue(key);\n      } else if (delayMs <= 0) {\n        // This request is registered, but is now being requested without a delay.\n        // Move into queue immediately if it's not already added, and clear any timeouts it may have.\n        this.addRequestToQueue(key, lowPriority);\n      }\n    }\n\n    const promise = this.allRequests.get(key)?.promise;\n    if (!promise) {\n      throw new Error(\"Found no promise to return when getting stored request data.\");\n    }\n    return promise as Promise<T>;\n  }\n\n  /**\n   * Adds multiple requests to the queue, with an optional delay between each.\n   * @param requests An array of RequestItems, which include a key and a request action.\n   * @param lowPriority Whether these requests should be added with low priority. False by default.\n   * @param delayMs An optional minimum delay in milliseconds to be added between each request.\n   *  For example, a delay of 10 ms will cause the second request to be added to the processing queue\n   *  after 10 ms, the third to added after 20 ms, and so on. Set to 10 ms by default.\n   * @returns An array of promises corresponding to the provided requests. (i.e., the `i`th value\n   * of the returned array will be a Promise for the resolution of `requests[i]`). If a request\n   *  with a matching key is already pending, returns the promise for the initial request.\n   */\n  public addRequests<T>(requests: Request<T>[], lowPriority = false, delayMs = 10): Promise<unknown>[] {\n    const promises: Promise<unknown>[] = [];\n    for (let i = 0; i < requests.length; i++) {\n      const item = requests[i];\n      const promise = this.addRequest(item.key, item.requestAction, lowPriority, delayMs * i);\n      promises.push(promise);\n    }\n    return promises;\n  }\n\n  /**\n   * Attempts to remove and run the next queued request item, if resources are available.\n   * @returns true if a request was started, or false if there are too many\n   * requests already active.\n   */\n  private async dequeue(): Promise<void> {\n    const numRequests = this.activeRequests.size;\n    if (\n      numRequests >= this.maxActiveRequests ||\n      (this.queue.length === 0 && (numRequests >= this.maxLowPriorityRequests || this.queueLowPriority.length === 0))\n    ) {\n      return;\n    }\n\n    const requestKey = this.queue.shift() ?? this.queueLowPriority.shift();\n    if (!requestKey) {\n      return;\n    }\n    if (this.activeRequests.has(requestKey)) {\n      // This request is already active, try the next one instead. (this shouldn't happen)\n      this.dequeue();\n      return;\n    }\n\n    const requestItem = this.allRequests.get(requestKey);\n    if (!requestItem) {\n      return;\n    }\n\n    const key = requestItem.key;\n    // Mark that this request is active\n    this.activeRequests.add(key);\n\n    await requestItem.action().then(requestItem.resolve, requestItem.reject);\n    this.activeRequests.delete(key);\n    this.allRequests.delete(key);\n    this.dequeue();\n  }\n\n  /**\n   * Removes any request matching the provided key from the queue and rejects its promise.\n   * @param key The key that should be matched against.\n   * @param cancelReason A message or object that will be used as the promise rejection.\n   */\n  public cancelRequest(key: string, cancelReason: unknown = DEFAULT_REQUEST_CANCEL_REASON): void {\n    if (!this.allRequests.has(key)) {\n      return;\n    }\n    const requestItem = this.allRequests.get(key);\n    if (requestItem) {\n      if (requestItem.timeoutId) {\n        // Cancel requests that have not been queued yet.\n        clearTimeout(requestItem.timeoutId);\n      }\n      // Reject the request, then clear from the queue and known requests.\n      requestItem.reject(cancelReason);\n    }\n    const queueIndex = this.queue.indexOf(key);\n    if (queueIndex > -1) {\n      this.queue.splice(queueIndex, 1);\n    } else {\n      const lowPriorityIndex = this.queueLowPriority.indexOf(key);\n      if (lowPriorityIndex > -1) {\n        this.queueLowPriority.splice(lowPriorityIndex, 1);\n      }\n    }\n    this.allRequests.delete(key);\n    this.activeRequests.delete(key);\n  }\n\n  /**\n   * Rejects all request promises and clears the queue.\n   * @param cancelReason A message or object that will be used as the promise rejection.\n   */\n  public cancelAllRequests(cancelReason: unknown = DEFAULT_REQUEST_CANCEL_REASON): void {\n    // Clear the queue so we don't do extra work while filtering it\n    this.queue = [];\n    this.queueLowPriority = [];\n    for (const key of this.allRequests.keys()) {\n      this.cancelRequest(key, cancelReason);\n    }\n  }\n\n  /**\n   * Returns whether a request with the given key exists in the RequestQueue and is not cancelled.\n   * @param key the key to search for.\n   * @returns true if the request is in the RequestQueue.\n   */\n  public hasRequest(key: string): boolean {\n    return this.allRequests.has(key);\n  }\n\n  /**\n   * Returns whether the request with the given key is currently running (not waiting in the queue).\n   * @param key the key to search for.\n   * @returns true if the request is actively running.\n   */\n  public requestRunning(key: string): boolean {\n    return this.activeRequests.has(key);\n  }\n}\n","import RequestQueue from \"./RequestQueue.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Resolver = (value?: any) => void;\ntype Rejecter = (reason?: unknown) => void;\n\ntype RequestSubscription = {\n  subscriberId: number;\n  resolve: Resolver;\n  reject: Rejecter;\n};\n\n/**\n * An extension of `RequestQueue` that adds a concept of \"subscribers,\" which may share references to a single request\n * or cancel their subscription without disrupting the request for other subscribers.\n */\nexport default class SubscribableRequestQueue {\n  private queue: RequestQueue;\n\n  /** The next unused subscriber ID. Increments whenever a subscriber is added. */\n  private nextSubscriberId: number;\n  /**\n   * Map of subscribers keyed by ID. Subscribers store a map to all their subscriptions by request key.\n   * Subscribers are only useful as handles to cancel subscriptions early, so we only need to store rejecters here.\n   */\n  private subscribers: Map<number, Map<string, Rejecter[]>>;\n  /** Map from \"inner\" request (managed by `queue`) to \"outer\" promises generated per-subscriber. */\n  private requests: Map<string, RequestSubscription[]>;\n\n  /**\n   * Since `SubscribableRequestQueue` wraps `RequestQueue`, its constructor may either take the same arguments as the\n   * `RequestQueue` constructor and create a new `RequestQueue`, or it may take an existing `RequestQueue` to wrap.\n   */\n  constructor(maxActiveRequests?: number, maxLowPriorityRequests?: number);\n  constructor(inner: RequestQueue);\n  constructor(maxActiveRequests?: number | RequestQueue, maxLowPriorityRequests?: number) {\n    if (typeof maxActiveRequests === \"number\" || maxActiveRequests === undefined) {\n      this.queue = new RequestQueue(maxActiveRequests, maxLowPriorityRequests);\n    } else {\n      this.queue = maxActiveRequests;\n    }\n    this.nextSubscriberId = 0;\n    this.subscribers = new Map();\n    this.requests = new Map();\n  }\n\n  /** Resolves all subscriptions to request `key` with `value` */\n  private resolveAll<T>(key: string, value: T): void {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const { resolve, subscriberId } of requests) {\n        resolve(value);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Rejects all subscriptions to request `key` with `reason` */\n  private rejectAll(key: string, reason: unknown): void {\n    const requests = this.requests.get(key);\n    if (requests) {\n      for (const { reject, subscriberId } of requests) {\n        reject(reason);\n        this.subscribers.get(subscriberId)?.delete(key);\n      }\n      this.requests.delete(key);\n    }\n  }\n\n  /** Adds a new request subscriber. Returns a unique ID to identify this subscriber. */\n  addSubscriber(): number {\n    const subscriberId = this.nextSubscriberId;\n    this.nextSubscriberId++;\n    this.subscribers.set(subscriberId, new Map());\n    return subscriberId;\n  }\n\n  /**\n   * Queues a new request, or adds a subscription if the request is already queued/running.\n   *\n   * If `subscriberId` is already subscribed to the request, this rejects the existing promise and returns a new one.\n   */\n  addRequest<T>(\n    key: string,\n    subscriberId: number,\n    requestAction: () => Promise<T>,\n    lowPriority?: boolean,\n    delayMs?: number\n  ): Promise<T> {\n    // Create single underlying request if it does not yet exist\n    this.queue\n      .addRequest(key, requestAction, lowPriority, delayMs)\n      .then((value) => this.resolveAll(key, value))\n      .catch((reason) => this.rejectAll(key, reason));\n\n    if (!this.requests.has(key)) {\n      this.requests.set(key, []);\n    }\n\n    // Validate subscriber\n    if (subscriberId >= this.nextSubscriberId || subscriberId < 0) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has not been registered`);\n    }\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      throw new Error(`SubscribableRequestQueue: subscriber id ${subscriberId} has been removed`);\n    }\n\n    // Create promise and add to list of requests\n    return new Promise<T>((resolve, reject) => {\n      this.requests.get(key)?.push({ resolve, reject, subscriberId });\n      const subscriber = this.subscribers.get(subscriberId);\n      const existingRequest = subscriber?.get(key);\n      if (existingRequest) {\n        existingRequest.push(reject);\n      } else {\n        subscriber?.set(key, [reject]);\n      }\n    });\n  }\n\n  /**\n   * Rejects a subscription and removes it from the list of subscriptions for a request, then cancels the underlying\n   * request if it is no longer subscribed and is not running already.\n   */\n  private rejectSubscription(key: string, reject: Rejecter, cancelReason?: unknown): void {\n    // Reject the outer \"subscription\" promise\n    reject(cancelReason);\n\n    // Get the list of subscriptions for this request\n    const subscriptions = this.requests.get(key);\n    if (!subscriptions) {\n      // This should never happen\n      return;\n    }\n    // Remove this request subscription by ref equality to `reject`\n    const idx = subscriptions.findIndex((sub) => sub.reject === reject);\n    if (idx >= 0) {\n      subscriptions.splice(idx, 1);\n    }\n\n    // Remove the underlying request if there are no more subscribers and the request is not already running\n    if (subscriptions.length < 1 && !this.queue.requestRunning(key)) {\n      this.queue.cancelRequest(key, cancelReason);\n      this.requests.delete(key);\n    }\n  }\n\n  /** Cancels a request subscription, and cancels the underlying request if it is no longer subscribed or running. */\n  cancelRequest(key: string, subscriberId: number, cancelReason?: unknown): boolean {\n    const subscriber = this.subscribers.get(subscriberId);\n    if (!subscriber) {\n      return false;\n    }\n\n    const rejecters = subscriber.get(key);\n    if (!rejecters || !rejecters.length) {\n      return false;\n    }\n\n    for (const reject of rejecters) {\n      this.rejectSubscription(key, reject, cancelReason);\n    }\n    subscriber.delete(key);\n    return true;\n  }\n\n  /** Removes a subscriber and cancels its remaining subscriptions. */\n  removeSubscriber(subscriberId: number, cancelReason?: unknown): void {\n    const subscriptions = this.subscribers.get(subscriberId);\n    if (subscriptions) {\n      for (const [key, rejecters] of subscriptions.entries()) {\n        for (const reject of rejecters) {\n          this.rejectSubscription(key, reject, cancelReason);\n        }\n      }\n      this.subscribers.delete(subscriberId);\n    }\n  }\n\n  /** Returns whether a request with the given `key` is running or waiting in the queue */\n  hasRequest(key: string): boolean {\n    return this.queue.hasRequest(key);\n  }\n\n  /** Returns whether a request with the given `key` is running */\n  requestRunning(key: string): boolean {\n    return this.queue.requestRunning(key);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` exists */\n  hasSubscriber(subscriberId: number): boolean {\n    return this.subscribers.has(subscriberId);\n  }\n\n  /** Returns whether a subscriber with the given `subscriberId` is subscribed to the request with the given `key` */\n  isSubscribed(subscriberId: number, key: string): boolean {\n    return this.subscribers.get(subscriberId)?.has(key) ?? false;\n  }\n}\n","import { parseTimeUnit, TimeUnit } from \"../constants/time.js\";\nimport { Axis } from \"../VolumeRenderSettings.js\";\n\nexport const DEFAULT_SIG_FIGS = 5;\n\nconst SECONDS_IN_MS = 1000;\nconst MINUTES_IN_MS = SECONDS_IN_MS * 60;\nconst HOURS_IN_MS = MINUTES_IN_MS * 60;\nconst DAYS_IN_MS = HOURS_IN_MS * 24;\n\n// Adapted from https://gist.github.com/ArneS/2ecfbe4a9d7072ac56c0.\nfunction digitToUnicodeSupercript(n: number): string {\n  const subst = [0x2070, 185, 178, 179, 0x2074, 0x2075, 0x2076, 0x2077, 0x2078, 0x2079];\n  return String.fromCharCode(subst[n]);\n}\n\n/**\n * Converts a number to scientific notation with the specified number of significant\n * figures, handling negative numbers and rounding.\n * @param input The number to convert.\n * @param significantFigures the number of signficant figures/digits. Must be >= 1.\n * @returns a string, formatted as a number in scientific notation.\n * @example\n * ```\n * numberToSciNotation(1, 3) // \"1.00×10⁰\"\n * numberToSciNotation(0.99, 2) // \"9.9×10⁻¹\"\n * numberToSciNotation(0.999, 2) // \"1.0×10⁰\"\n * numberToSciNotation(-0.05, 1) // \"-5×10⁻²\"\n * numberToSciNotation(1400, 3) // \"1.40×10³\"\n * ```\n */\nfunction numberToSciNotation(input: number, sigFigs = DEFAULT_SIG_FIGS): string {\n  const nativeExpForm = input.toExponential(sigFigs - 1);\n  const [significand, exponent] = nativeExpForm.split(\"e\");\n  const expSign = exponent[0] === \"-\" ? \"⁻\" : \"\";\n  const expDigits = exponent.slice(1).split(\"\");\n  const expSuperscript = expDigits.map((digit) => digitToUnicodeSupercript(Number(digit))).join(\"\");\n  return `${significand}×10${expSign}${expSuperscript}`;\n}\n\n/**\n * Returns a string-encoded number rounded to a specified decimal precision, without ever formatting in scientific\n * notation like `Number.toPrecision` might do.\n */\nfunction toSigFigs(value: number, sigFigs: number): string {\n  const exponent = Math.floor(Math.log10(Math.abs(value)));\n  return value.toFixed(Math.max(sigFigs - exponent - 1, 0));\n}\n\n/** Trims trailing instances of `char` off the end of `str`. */\n// This is not technically a number utility, but it's useful to `formatNumber` below.\nfunction trimTrailing(str: string, char: string): string {\n  let i = str.length - 1;\n  while (str[i] === char) {\n    i--;\n  }\n  return str.slice(0, i + 1);\n}\n\n/**\n * Formats numbers for display as a string with a (hopefully) limited length.\n *\n * - If the number is an integer with 4 or fewer digits, it is returned as a string.\n * - If the number is a decimal, it is rounded to `sigFigs` significant figures. (default 5)\n * - If the number's absolute value is over 10,000 or less than 0.01, it is formatted in scientific notation to\n *   `sciSigFigs` significant figures. (Default `sigFigs - 2`, so 3 if neither are specified. The `- 2` leaves space\n *   for the exponential part. Remember: the purpose of this function is keeping number strings *consistently* short!)\n */\nexport function formatNumber(value: number, sigFigs = DEFAULT_SIG_FIGS, sciSigFigs = sigFigs - 2): string {\n  const valueAbs = Math.abs(value);\n\n  if (Number.isInteger(value)) {\n    // Format integers with 5+ digits in scientific notation\n    if (valueAbs >= 10_000) {\n      return numberToSciNotation(value, sciSigFigs);\n    }\n    // Just stringify other integers\n    return value.toString();\n  } else {\n    const numStr = toSigFigs(value, sigFigs);\n    const numRounded = Math.abs(Number(numStr));\n    if (numRounded >= 10_000 || numRounded < 0.01) {\n      return numberToSciNotation(value, sciSigFigs);\n    }\n    const trimmed = trimTrailing(numStr, \"0\");\n    return trimmed.endsWith(\".\") ? trimmed.slice(0, -1) : trimmed;\n  }\n}\n\nconst timeUnitEnumToMilliseconds = {\n  [TimeUnit.MILLISECOND]: 1,\n  [TimeUnit.SECOND]: SECONDS_IN_MS,\n  [TimeUnit.MINUTE]: MINUTES_IN_MS,\n  [TimeUnit.HOUR]: HOURS_IN_MS,\n  [TimeUnit.DAY]: DAYS_IN_MS,\n};\n\nexport function timeToMilliseconds(time: number, unit: TimeUnit): number {\n  const timeUnitMultiplier = timeUnitEnumToMilliseconds[unit];\n  if (timeUnitMultiplier === undefined) {\n    throw new Error(\"Unrecognized time unit\");\n  }\n  return time * timeUnitMultiplier;\n}\n\n/**\n * Pads the `value` with zeroes to the specified `length` if `shouldPad` is true\n * and returns the resulting string. Otherwise, returns the string representation of `value`.\n */\nfunction padConditionally(value: number, length: number, shouldPad: boolean): string {\n  return shouldPad ? value.toString().padStart(length, \"0\") : value.toString();\n}\n\nfunction formatTimestamp(\n  timeMs: number,\n  options: {\n    useMs: boolean;\n    useSec: boolean;\n    useMin: boolean;\n    useHours: boolean;\n    useDays: boolean;\n  }\n): { timestamp: string; units: string } {\n  const { useMs, useSec, useMin, useHours, useDays } = options;\n  const digits: string[] = [];\n  const units: string[] = [];\n\n  if (useDays) {\n    const days = Math.floor(timeMs / DAYS_IN_MS);\n    digits.push(days.toString());\n    units.push(\"d\");\n  }\n  if (useHours) {\n    const hours = Math.floor((timeMs % DAYS_IN_MS) / HOURS_IN_MS);\n    // If the previous unit is included, pad the hours to 2 digits so the\n    // timestamp is consistent.\n    digits.push(padConditionally(hours, 2, useDays));\n    units.push(\"h\");\n  }\n  if (useMin) {\n    const minutes = Math.floor((timeMs % HOURS_IN_MS) / MINUTES_IN_MS);\n    digits.push(padConditionally(minutes, 2, useHours));\n    units.push(\"m\");\n  }\n  if (useSec) {\n    const seconds = Math.floor((timeMs % MINUTES_IN_MS) / SECONDS_IN_MS);\n    let secondString = padConditionally(seconds, 2, useMin);\n    units.push(\"s\");\n    // If using milliseconds, add as a decimal to the seconds string.\n    if (useMs) {\n      const milliseconds = Math.floor(timeMs % SECONDS_IN_MS);\n      secondString += \".\" + milliseconds.toString().padStart(3, \"0\");\n      // Do not add milliseconds to unit label, since they'll be shown as\n      // part of the seconds string.\n    }\n    digits.push(secondString);\n  } else if (useMs) {\n    const milliseconds = Math.floor(timeMs % SECONDS_IN_MS);\n    digits.push(milliseconds.toString());\n    units.push(\"ms\");\n  }\n  return { timestamp: digits.join(\":\"), units: units.join(\":\") };\n}\n\n/**\n * Gets a timestamp formatted as `{time} / {total} {unit}`. If `unit` is a recognized\n * time unit, the timestamp will be formatted as a `d:hh:mm:ss.ms` string.\n *\n * @param time Current time, in specified units.\n * @param total Total time, in specified units.\n * @param unit The unit of time.\n * @returns A formatted timestamp string.\n * - If `unit` is not recognized, the timestamp will be formatted as `{time} / {total} {unit}`,\n * where `time` and `total` are formatted with significant digits as needed.\n * - If `unit` is recognized, the timestamp will be formatted as `d:hh:mm:ss.ms`, specifying\n * the most significant unit based on the total time, and the least significant unit with\n * `unit`. See `parseTimeUnit()` for recognized time units.\n */\nexport function getTimestamp(time: number, total: number, unit: string): string {\n  const timeUnit = parseTimeUnit(unit);\n\n  if (timeUnit === undefined) {\n    return `${formatNumber(time)} / ${formatNumber(total)} ${unit}`;\n  }\n\n  const timeMs = timeToMilliseconds(time, timeUnit);\n  const totalMs = timeToMilliseconds(total, timeUnit);\n\n  // Toggle each unit based on the total time and the provided timeUnit.\n  // Exploit an enum property where TimeUnit.Milliseconds < TimeUnit.Second < TimeUnit.Minute ... etc.\n  const options = {\n    useMs: timeUnit == TimeUnit.MILLISECOND,\n    useSec: timeUnit == TimeUnit.SECOND || (timeUnit <= TimeUnit.SECOND && totalMs >= SECONDS_IN_MS),\n    useMin: timeUnit == TimeUnit.MINUTE || (timeUnit <= TimeUnit.MINUTE && totalMs >= MINUTES_IN_MS),\n    useHours: timeUnit == TimeUnit.HOUR || (timeUnit <= TimeUnit.HOUR && totalMs >= HOURS_IN_MS),\n    useDays: timeUnit == TimeUnit.DAY || (timeUnit <= TimeUnit.DAY && totalMs >= DAYS_IN_MS),\n  };\n\n  const { timestamp, units } = formatTimestamp(timeMs, options);\n  const { timestamp: totalTimestamp } = formatTimestamp(totalMs, options);\n\n  return `${timestamp} / ${totalTimestamp} ${units}`;\n}\n\n/**\n * Constrains the `src` vector relative to the `target` so it only has freedom along the\n * specified `axis`. Does nothing if `axis = Axis.NONE`.\n *\n * @example\n * ```\n *   const src = [1, 2, 3];\n *   const target = [4, 5, 6];\n *   const constrained = constrainToAxis(src, target, Axis.X);\n *   console.log(constrained); // [1, 5, 6]\n * ```\n */\nexport function constrainToAxis(\n  src: [number, number, number],\n  target: [number, number, number],\n  axis: Axis\n): [number, number, number] {\n  switch (axis) {\n    case Axis.X:\n      return [src[0], target[1], target[2]];\n    case Axis.Y:\n      return [target[0], src[1], target[2]];\n    case Axis.Z:\n      return [target[0], target[1], src[2]];\n    default:\n      return [...src];\n  }\n}\n\nexport function getDataRange(data: ArrayLike<number>): [number, number] {\n  let min = data[0];\n  let max = data[0];\n  for (let i = 1; i < data.length; i++) {\n    min = Math.min(min, data[i]);\n    max = Math.max(max, data[i]);\n  }\n  return [min, max];\n}\n","import { serializeError } from \"serialize-error\";\n\nimport VolumeCache from \"../VolumeCache.js\";\nimport { VolumeFileFormat, createVolumeLoader, pathToFileType } from \"../loaders/index.js\";\nimport { ThreadableVolumeLoader } from \"../loaders/IVolumeLoader.js\";\nimport { VolumeLoadError } from \"../loaders/VolumeLoadError.js\";\nimport RequestQueue from \"../utils/RequestQueue.js\";\nimport SubscribableRequestQueue from \"../utils/SubscribableRequestQueue.js\";\nimport type { WorkerRequest, WorkerRequestPayload, WorkerResponse, WorkerResponsePayload } from \"./types.js\";\nimport { WorkerEventType, WorkerMsgType, WorkerResponseResult } from \"./types.js\";\nimport { rebuildLoadSpec } from \"./util.js\";\n\nlet cache: VolumeCache | undefined = undefined;\nlet queue: RequestQueue | undefined = undefined;\nlet subscribableQueue: SubscribableRequestQueue | undefined = undefined;\nlet loader: ThreadableVolumeLoader | undefined = undefined;\nlet initialized = false;\nlet copyOnLoad = false;\n\ntype MessageHandler<T extends WorkerMsgType> = (payload: WorkerRequestPayload<T>) => Promise<WorkerResponsePayload<T>>;\n\nconst messageHandlers: { [T in WorkerMsgType]: MessageHandler<T> } = {\n  [WorkerMsgType.INIT]: ({ maxCacheSize, maxActiveRequests, maxLowPriorityRequests }) => {\n    if (!initialized) {\n      cache = new VolumeCache(maxCacheSize);\n      queue = new RequestQueue(maxActiveRequests, maxLowPriorityRequests);\n      subscribableQueue = new SubscribableRequestQueue(queue);\n      initialized = true;\n    }\n    return Promise.resolve();\n  },\n\n  [WorkerMsgType.CREATE_LOADER]: async ({ path, options }) => {\n    const pathString = Array.isArray(path) ? path[0] : path;\n    const fileType = options?.fileType || pathToFileType(pathString);\n    copyOnLoad = fileType === VolumeFileFormat.JSON;\n    loader = await createVolumeLoader(path, { ...options, cache, queue: subscribableQueue });\n    return loader !== undefined;\n  },\n\n  [WorkerMsgType.CREATE_VOLUME]: async (loadSpec) => {\n    if (loader === undefined) {\n      throw new VolumeLoadError(\"No loader created\");\n    }\n\n    return await loader.createImageInfo(rebuildLoadSpec(loadSpec));\n  },\n\n  [WorkerMsgType.LOAD_DIMS]: async (loadSpec) => {\n    if (loader === undefined) {\n      throw new VolumeLoadError(\"No loader created\");\n    }\n    return await loader.loadDims(rebuildLoadSpec(loadSpec));\n  },\n\n  [WorkerMsgType.LOAD_VOLUME_DATA]: ({ imageInfo, loadSpec, loaderId, loadId }) => {\n    if (loader === undefined) {\n      throw new VolumeLoadError(\"No loader created\");\n    }\n\n    return loader.loadRawChannelData(\n      imageInfo,\n      rebuildLoadSpec(loadSpec),\n      (imageInfo, loadSpec) => {\n        const message: WorkerResponse<WorkerMsgType> = {\n          responseResult: WorkerResponseResult.EVENT,\n          eventType: WorkerEventType.METADATA_UPDATE,\n          loaderId,\n          loadId,\n          imageInfo,\n          loadSpec,\n        };\n        self.postMessage(message);\n      },\n      (channelIndex, dtype, data, ranges, atlasDims) => {\n        const message: WorkerResponse<WorkerMsgType> = {\n          responseResult: WorkerResponseResult.EVENT,\n          eventType: WorkerEventType.CHANNEL_LOAD,\n          loaderId,\n          loadId,\n          channelIndex,\n          dtype,\n          data,\n          ranges,\n          atlasDims,\n        };\n        (self as unknown as Worker).postMessage(message, copyOnLoad ? [] : data.map((d) => d.buffer));\n      }\n    );\n  },\n\n  [WorkerMsgType.SET_PREFETCH_PRIORITY_DIRECTIONS]: (directions) => {\n    // Silently does nothing if the loader isn't an `OMEZarrLoader`\n    loader?.setPrefetchPriority(directions);\n    return Promise.resolve();\n  },\n\n  [WorkerMsgType.SYNCHRONIZE_MULTICHANNEL_LOADING]: (syncChannels) => {\n    loader?.syncMultichannelLoading(syncChannels);\n    return Promise.resolve();\n  },\n\n  [WorkerMsgType.UPDATE_FETCH_OPTIONS]: (fetchOptions) => {\n    loader?.updateFetchOptions(fetchOptions);\n    return Promise.resolve();\n  },\n};\n\nself.onmessage = async <T extends WorkerMsgType>({ data }: MessageEvent<WorkerRequest<T>>) => {\n  const { msgId, type, payload } = data;\n  let message: WorkerResponse<T>;\n\n  try {\n    const response = await messageHandlers[type](payload);\n    message = { responseResult: WorkerResponseResult.SUCCESS, msgId, type, payload: response };\n  } catch (e) {\n    message = { responseResult: WorkerResponseResult.ERROR, msgId, type, payload: serializeError(e) };\n  }\n  self.postMessage(message);\n};\n","import type { ErrorObject } from \"serialize-error\";\n\nimport type { ImageInfo } from \"../ImageInfo.js\";\nimport type { VolumeDims } from \"../VolumeDims.js\";\nimport type { CreateLoaderOptions, PrefetchDirection } from \"../loaders/index.js\";\nimport type { LoadSpec, LoadedVolumeInfo } from \"../loaders/IVolumeLoader.js\";\nimport type { TypedArray, NumberType } from \"../types.js\";\nimport type { ZarrLoaderFetchOptions } from \"../loaders/OmeZarrLoader.js\";\n\n/** The types of requests that can be made to the worker. Mostly corresponds to methods on `IVolumeLoader`. */\nexport const enum WorkerMsgType {\n  INIT,\n  CREATE_LOADER,\n  CREATE_VOLUME,\n  LOAD_DIMS,\n  LOAD_VOLUME_DATA,\n  SET_PREFETCH_PRIORITY_DIRECTIONS,\n  SYNCHRONIZE_MULTICHANNEL_LOADING,\n  UPDATE_FETCH_OPTIONS,\n}\n\n/** The kind of response a worker can return - `SUCCESS`, `ERROR`, or `EVENT`. */\nexport const enum WorkerResponseResult {\n  SUCCESS,\n  ERROR,\n  EVENT,\n}\n\n/** The kind of events that can occur when loading */\nexport const enum WorkerEventType {\n  /** Fired to update a `Volume`'s `imageInfo` and/or `loadSpec` based on loaded data (time, channels, region, etc.) */\n  METADATA_UPDATE,\n  /** Fired when data for a channel (or batch of channels) is loaded */\n  CHANNEL_LOAD,\n}\n\n/** All messages to/from a worker carry a `msgId`, a `type`, and a `payload` (whose type is determined by `type`). */\ntype WorkerMsgBase<T extends WorkerMsgType, P> = {\n  msgId: number;\n  type: T;\n  payload: P;\n};\n\n/** Maps each `WorkerMsgType` to the type of the payload of requests of that type. */\nexport type WorkerRequestPayload<T extends WorkerMsgType> = {\n  [WorkerMsgType.INIT]: {\n    maxCacheSize?: number;\n    maxActiveRequests?: number;\n    maxLowPriorityRequests?: number;\n  };\n  [WorkerMsgType.CREATE_LOADER]: {\n    path: string | string[];\n    options?: CreateLoaderOptions;\n  };\n  [WorkerMsgType.CREATE_VOLUME]: LoadSpec;\n  [WorkerMsgType.LOAD_DIMS]: LoadSpec;\n  [WorkerMsgType.LOAD_VOLUME_DATA]: {\n    imageInfo: ImageInfo;\n    loadSpec: LoadSpec;\n    loaderId: number;\n    loadId: number;\n  };\n  [WorkerMsgType.SET_PREFETCH_PRIORITY_DIRECTIONS]: PrefetchDirection[];\n  [WorkerMsgType.SYNCHRONIZE_MULTICHANNEL_LOADING]: boolean;\n  [WorkerMsgType.UPDATE_FETCH_OPTIONS]: Partial<ZarrLoaderFetchOptions>;\n}[T];\n\n/** Maps each `WorkerMsgType` to the type of the payload of responses of that type. */\nexport type WorkerResponsePayload<T extends WorkerMsgType> = {\n  [WorkerMsgType.INIT]: void;\n  [WorkerMsgType.CREATE_LOADER]: boolean;\n  [WorkerMsgType.CREATE_VOLUME]: LoadedVolumeInfo;\n  [WorkerMsgType.LOAD_DIMS]: VolumeDims[];\n  [WorkerMsgType.LOAD_VOLUME_DATA]: void;\n  [WorkerMsgType.SET_PREFETCH_PRIORITY_DIRECTIONS]: void;\n  [WorkerMsgType.SYNCHRONIZE_MULTICHANNEL_LOADING]: void;\n  [WorkerMsgType.UPDATE_FETCH_OPTIONS]: void;\n}[T];\n\n/** Event for when a batch of channel data loads. */\nexport type ChannelLoadEvent = {\n  eventType: WorkerEventType.CHANNEL_LOAD;\n  loaderId: number;\n  loadId: number;\n  channelIndex: number[];\n  dtype: NumberType[];\n  data: TypedArray<NumberType>[];\n  ranges: [number, number][];\n  atlasDims?: [number, number];\n};\n\n/** Event for when metadata updates. */\nexport type MetadataUpdateEvent = {\n  eventType: WorkerEventType.METADATA_UPDATE;\n  loaderId: number;\n  loadId: number;\n  imageInfo?: ImageInfo;\n  loadSpec?: LoadSpec;\n};\n\n/** All valid types of worker requests, with some `WorkerMsgType` and a matching payload type. */\nexport type WorkerRequest<T extends WorkerMsgType> = WorkerMsgBase<T, WorkerRequestPayload<T>>;\n/** All valid types of worker responses: `SUCCESS` with a matching payload, `ERROR` with a message, or an `EVENT`. */\nexport type WorkerResponse<T extends WorkerMsgType> =\n  | ({ responseResult: WorkerResponseResult.SUCCESS } & WorkerMsgBase<T, WorkerResponsePayload<T>>)\n  | ({ responseResult: WorkerResponseResult.ERROR } & WorkerMsgBase<T, ErrorObject>)\n  | ({ responseResult: WorkerResponseResult.EVENT } & (ChannelLoadEvent | MetadataUpdateEvent));\n","import { Box3, Vector3 } from \"three\";\nimport { LoadSpec } from \"../loaders/IVolumeLoader\";\n\n/** Recreates a `LoadSpec` that has just been sent to/from a worker to restore three.js object prototypes */\nexport function rebuildLoadSpec(spec: LoadSpec): LoadSpec {\n  return {\n    ...spec,\n    subregion: new Box3(new Vector3().copy(spec.subregion.min), new Vector3().copy(spec.subregion.max)),\n  };\n}\n","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_zarrita_core_dist_src_errors_js-node_modules_geotiff_dist-module_geotiff-5b1ba2\",\"vendors-node_modules_zarrita_core_dist_src_open_js-node_modules_zarrita_indexing_dist_src_ops-b97c78\"], () => (__webpack_require__(\"./src/workers/VolumeLoadWorker.ts\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".volume-viewer-ui.bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"src_workers_VolumeLoadWorker_ts\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunk_aics_volume_viewer\"] = self[\"webpackChunk_aics_volume_viewer\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(\"vendors-node_modules_zarrita_core_dist_src_errors_js-node_modules_geotiff_dist-module_geotiff-5b1ba2\"),\n\t\t__webpack_require__.e(\"vendors-node_modules_zarrita_core_dist_src_open_js-node_modules_zarrita_indexing_dist_src_ops-b97c78\")\n\t]).then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":["DataTexture","LuminanceFormat","RedFormat","RedIntegerFormat","UnsignedByteType","ByteType","FloatType","IntType","UnsignedIntType","ShortType","UnsignedShortType","RGBAFormat","LinearFilter","NearestFilter","UVMapping","ClampToEdgeWrapping","Histogram","Lut","LUT_ARRAY_LENGTH","ARRAY_CONSTRUCTORS","Channel","constructor","name","loaded","dtype","imgData","data","Uint8Array","width","height","rawMin","rawMax","dataTexture","lutTexture","minFilter","magFilter","generateMipmaps","volumeData","histogram","dims","lut","createFromMinMax","colorPalette","fill","colorPaletteAlpha","combineLuts","rgbColor","out","ret","rgb","set","i","image","needsUpdate","setRawDataRange","min","max","remapDomains","getHistogram","getIntensity","x","y","z","normalizeRaw","val","getIntensityFromAtlas","numXtiles","tilex","tiley","Math","floor","offset","rebuildDataTexture","w","h","dispose","format","dataType","internalFormat","console","warn","setFromAtlas","bitsArray","subregionSize","unpackFromAtlas","volimgdata","ctor","atlasrow","tileoffset","tilerowoffset","destOffset","j","subarray","setFromVolumeData","vx","vy","vz","ax","ay","packToAtlas","log","sourceOffset","setLut","setColorPalette","palette","setColorPaletteAlpha","alpha","NBINS","dataMinBin","dataMaxBin","maxBin","bins","Uint32Array","binSize","hinfo","calculateHistogram","length","pixelCount","findBin","dataValue","dataMin","numBins","binIndex","findBinOfValue","value","getDataMin","getDataMax","getMin","getMax","getNumBins","getBin","getBinRange","findBinOfPercentile","pct","limit","count","findBestFitBins","pixcount","hmin","hmax","findAutoIJBins","AUTO_THRESHOLD","threshold","findAutoMinMax","PERCENTAGE","th","b","e","arr","item","volumeSize","physicalPixelSize","Vector3","Vector2","defaultImageInfo","atlasTileDims","subregionOffset","combinedNumChannels","channelNames","channelColors","multiscaleLevel","multiscaleLevelDims","shape","spacing","spaceUnit","timeUnit","transform","translation","rotation","scale","CImageInfo","imageInfo","currentLevelDims","numChannels","originalSize","spatialUnit","times","timeScale","numMultiscaleLevels","computeAtlasSize","volDims","getColorByChannelIndex","clamp","cmin","cmax","lerp","xmin","xmax","a","remapDomain","valueMin","valueMax","oldMin","oldMax","newMin","newMax","pctOfRange","newValue","pctOfOldRange","remapped","remapDomainForCP","iOld","pctOfNewRange","LUT_ENTRIES","arrayFromControlPoints","controlPoints","len","sort","rgba","controlPointToRGBA","startx","c0","c1","color0","color1","lastIndex","color","opacity","controlPoint","createFullRangeControlPoints","opacityMin","opacityMax","createFullRange","tmp","createFromControlPoints","startVal","push","endVal","createFromWindowLevel","wnd","lvl","createFromEqHistogram","map","div","lutControlPoints","slope","lastSlope","lastOpacity","round","createLabelColors","lastr","lastg","lastb","lasta","r","g","ibin","remapLut","remapControlPoints","newLut","i0","i1","ceil","nudgeEndPoints","newControlPoints","oldFirstX","oldLastX","cp","newCP","nudgeRemappedEndControlPoints","EPSILON","first","second","secondLast","last","abs","Infinity","LoadSpec","MAX_ATLAS_EDGE","pickLevelToLoadUnscaled","Volume","loadSpec","loader","scaleLevelBias","maxAtlasEdge","channels","Array","from","_val","idx","loadSpecRequired","slice","subregion","clone","imageMetadata","normRegionSize","normRegionOffset","physicalSize","physicalScale","normPhysicalSize","tickMarkPhysicalLength","setVoxelSize","channelColorsDefault","index","channel","toArray","physicalUnitSymbol","volumeDataObservers","setUnloaded","forEach","isLoaded","updateDimensions","divide","mustLoadNewData","useExplicitLevel","time","containsBox","some","includes","mayLoadNewScaleLevel","equals","updateRequiredData","required","onChannelLoaded","shouldReload","loadScaleLevelDims","dimsZYX","levelToLoad","loadNewData","loadDims","observer","onVolumeLoadError","undefined","loadVolumeData","size","multiply","divideScalar","log10","setUnitSymbol","symbol","getContentCenter","add","subScalar","cleanup","getChannel","channelIndex","batch","every","channelLoadCallback","onVolumeData","setChannelDataFromAtlas","atlasdata","atlaswidth","atlasheight","range","setChannelDataFromVolume","appendEmptyChannel","chname","chcolor","onVolumeChannelAdded","c","getRotation","getTranslation","voxelsToWorldSpace","xyz","m","fromArray","multiplyScalar","addVolumeDataObserver","o","removeVolumeDataObserver","indexOf","splice","removeAllVolumeDataObservers","CACHE_MAX_SIZE_DEFAULT","VolumeCache","maxSize","entries","Map","currentSize","numberOfEntries","removeEntryFromStore","entry","delete","key","byteLength","removeEntryFromList","prev","next","addEntryAsFirst","moveEntryToFirst","evictLast","error","evict","insert","getResult","getEntry","newEntry","result","get","clearWithPrefix","prefix","startsWith","clear","defaultVolumeDims","volumeDims","Euler","SettingsFlags","Axis","VolumeRenderSettings","volume","isOrtho","viewAxis","NONE","orthoScale","flipAxes","maskChannelIndex","maskAlpha","gammaMin","gammaLevel","gammaMax","density","brightness","showBoundingBox","bounds","bmin","bmax","boundingBoxColor","primaryRayStepSize","secondaryRayStepSize","useInterpolation","visible","maxProjectMode","zSlice","diffuse","specular","emissive","glossiness","pixelSamplingRate","resolution","resizeWithVolume","compareArray","a1","a2","elem1","elem2","isEqual","o2","Object","keys","v1","v2","bounds1","bounds2","deepCopyArray","dst","String","defaultColors","HSVtoRGB","s","v","hh","arguments","hsv","f","p","q","t","LCG","imul","myrand","TimeUnit","recognizedTimeUnits","MILLISECOND","Set","SECOND","MINUTE","HOUR","DAY","parseTimeUnit","unit","recognizedUnits","has","Box3","buildDefaultMetadata","loadSpecToString","spec","ThreadableVolumeLoader","setPrefetchPriority","_directions","syncMultichannelLoading","_sync","updateFetchOptions","_options","createVolume","adjustedLoadSpec","createImageInfo","vol","loadSpecOverride","onUpdateMetadata","onChannelData","channelIndices","dtypes","dataArrays","ranges","atlasDims","loadRawChannelData","getDataRange","rescalePixelSize","json","px","pixel_size_x","tile_width","py","pixel_size_y","tile_height","pz","pixel_size_z","convertImageInfo","tr","cols","rows","tiles","channel_names","channel_colors","time_scale","pixel_size_unit","time_unit","userData","originalVolumeSize","originalPhysicalPixelSize","JsonImageInfoLoader","syncChannels","urls","cache","isArray","jsonInfo","getJsonImageInfo","cachedInfo","response","fetch","sync","d","onData","images","requestedChannels","filter","ch","urlPrefix","replace","element","flatMap","wrappedOnData","loadVolumeAtlasData","imageArray","resultChannelIndices","resultChannelDtype","resultChannelData","resultChannelRanges","imagePromises","cacheHit","chindex","cacheResult","channelData","mode","blob","bitmap","createImageBitmap","canvas","OffscreenCanvas","ctx","getContext","globalCompositeOperation","globalAlpha","drawImage","iData","getImageData","channelsBits","channelRange","Promise","all","zarr","zarrGet","FetchStore","SubscribableRequestQueue","composeSubregion","computePackedAtlasDims","convertSubregionToPixels","pickLevelToLoad","unitNameToSymbol","ChunkPrefetchIterator","WrappedStore","getDimensionCount","getScale","getSourceChannelNames","matchSourceScaleLevels","orderByDimension","orderByTCZYX","remapAxesToTCZYX","VolumeLoadError","VolumeLoadErrorType","wrapVolumeLoadError","validateOMEZarrMetadata","CHUNK_REQUEST_CANCEL_REASON","convertChannel","f32","Float32Array","DEFAULT_FETCH_OPTIONS","maxPrefetchDistance","maxPrefetchChunks","OMEZarrLoader","sources","requestQueue","fetchOptions","priorityDirections","createLoader","scenes","queue","concurrencyLimit","prefetchConcurrencyLimit","urlsArr","scenesArr","sourceProms","url","store","root","group","open","kind","catch","NOT_FOUND","scene","attrs","multiscales","omero","multiscaleMetadata","lvlProms","datasets","path","resolve","scaleLevels","axesTCZYX","axes","omeroMetadata","channelOffset","channelCount","priorityDirs","getUnitSymbols","source","xi","spaceUnitName","spaceUnitSymbol","ti","timeUnitName","timeUnitSymbol","getLevelShapesZYX","level","valsTCZYX","sourceIdx","valsDimension","defaultValue","matchChannelToSource","absoluteChannelIndex","lastSrcIdx","lastSrc","lastSrcNumChannels","maxChannelIndex","type","INVALID_METADATA","firstGreaterIdx","findIndex","src","sourceIndex","channelIndexInSource","directions","options","maxExtent","regionSize","getSize","regionArr","source0","hasT","hasZ","shapeLv","sourceLast","cLast","lastHasC","tindex","pxDimsLv","pxSizeLv","channelNamesMap","sourceChannelNames","channelName","numMatchingChannels","alldims","imgdata","fullExtentLoadSpec","prefetchChunk","scaleLevel","coords","subscriber","separator","endsWith","join","isPrefetch","LOAD_DATA_FAILED","beginPrefetch","chunkCoords","numDims","coordsInDimensionOrder","trim","split","parseInt","sourceCoords","chunkDimsTCZYX","chunkDimsUnordered","dim","chunks","prefetchIterator","onlyPriorityDirections","addSubscriber","prefetchCount","chunk","sourceScaleLevel","prefetchSubscriber","removeSubscriber","updateImageInfoForLoad","array0Shape","regionPx","updatedImageInfo","channelIndexes","_","reportKeyBase","sub","channelPromises","sourceCh","unorderedSpec","sliceSpec","reportKey","opts","converted","loadSubscriber","sizeZ","sizeX","sizeY","sizeC","RawArrayLoader","rawData","rawDataInfo","Error","_loadSpec","volSizeBytes","buffer","fromUrl","deserializeError","prepareXML","xml","expr","getOME","parser","DOMParser","xmlDoc","parseFromString","getElementsByTagName","cause","OMEDims","sizex","sizey","sizez","sizec","sizet","pixeltype","dimensionorder","pixelsizex","pixelsizey","pixelsizez","channelnames","getDtype","omepixeltype","mapping","uint8","uint16","uint32","int8","int16","int32","float","getAttributeOrError","el","attr","getAttribute","getOMEDims","imageEl","pixelsEl","Number","channelsEls","id","getBytesPerSample","TiffLoader","loadOmeDims","tiff","allowFullFile","getImage","tiffimgdesc","getFileDirectory","ImageDescription","omeEl","image0El","targetSize","tilesizex","tilesizey","_onUpdateMetadata","cimageinfo","channelProms","thisChannelProm","reject","params","dimensionOrder","bytesPerSample","worker","Worker","URL","import","meta","onmessage","isError","terminate","postMessage","errorConstructors","NodeNotFoundError","KeyError","message","UNKNOWN","ignore","UNIT_SYMBOLS","angstrom","day","foot","hour","inch","meter","micron","mile","minute","parsec","yard","SI_UNITS","SI_PREFIX_ABBVS","micro","deca","unitName","prefixedSIUnit","find","siUnit","substring","capitalize","prefixAbbr","toUpperCase","tw","nextrows","nextcols","ratio","nrows","ncols","doesSpatialDimensionFitInAtlas","spatialDimZYX","xtiles","ytiles","estimateLevelForAtlas","spatialDimsZYX","maxCeil","scaleDims","scaleDimsToSubregion","scaleMultipleDimsToSubregion","smallestDims","scaledDims","region","container","isEmpty","obj","prototype","hasOwnProperty","call","rawImageInfo","metadata","PrefetchDirection","VolumeFileFormat","pathToFileType","JSON","TIFF","ZARR","createVolumeLoader","pathString","fileType","DATA","rawArrayOptions","allEqual","pushN","n","directionToIndex","dir","absDir","updateMinMax","minmax","tzyxMaxPrefetchOffset","tczyxChunksPerSource","extrema","directionStates","priorityDirectionStates","direction","start","flat","dimension","tczyxIndex","end","endsPerSource","chunkDims","sourceEnd","directionState","iterateDirections","offsetDir","newChunk","Symbol","iterator","baseStore","_key","_value","getAndCache","cacheKey","ZARR_EXTS","keyPrefix","fullKey","addRequest","label","axisNames","axis","axisIdx","noXAxis","orderTCZYX","specLen","dataset","transforms","coordinateTransformations","isScaleTransform","scaleTransform","compareZarrArraySize","aArr","aTCZYX","bArr","bTCZYX","aZ","bZ","diffZ","diffY","diffX","aboutEquals","scaleTransformsAreEqual","aSrc","aLevel","bSrc","bLevel","aScale","bScale","matchedLevels","matchedMetas","scaleIndexes","smallestIdx","smallestSrc","smallestArr","currentIdx","currentSrc","currentArr","ordering","INVALID_MULTI_SOURCE_ZARR","largestT","currentT","matchedScaleLevel","srcIdx","isObjectWithProp","prop","assertMetadataHasProp","assertPropIsArray","multiscaleIdx","multiscaleMeta","multiscaleMetaName","multiscaleName","Int8Array","Int16Array","Int32Array","int64","globalThis","BigInt64Array","Uint16Array","uint64","BigUint64Array","float32","float64","Float64Array","FUSE_DISABLED_RGB_COLOR","RenderMode","isOrthographicCamera","def","isPerspectiveCamera","ViewportCorner","isTop","corner","TOP_LEFT","TOP_RIGHT","isRight","BOTTOM_RIGHT","DATARANGE_UINT8","DEFAULT_REQUEST_CANCEL_REASON","RequestQueue","maxActiveRequests","maxLowPriorityRequests","allRequests","activeRequests","queueLowPriority","registerRequest","requestAction","promiseResolve","promiseReject","promise","requestItem","action","addRequestToQueue","lowPriority","timeoutId","clearTimeout","dequeue","delayMs","setTimeout","lowPriorityIndex","addRequests","requests","promises","numRequests","requestKey","shift","then","cancelRequest","cancelReason","queueIndex","cancelAllRequests","hasRequest","requestRunning","nextSubscriberId","subscribers","resolveAll","subscriberId","rejectAll","reason","existingRequest","rejectSubscription","subscriptions","rejecters","hasSubscriber","isSubscribed","DEFAULT_SIG_FIGS","SECONDS_IN_MS","MINUTES_IN_MS","HOURS_IN_MS","DAYS_IN_MS","digitToUnicodeSupercript","subst","fromCharCode","numberToSciNotation","input","sigFigs","nativeExpForm","toExponential","significand","exponent","expSign","expDigits","expSuperscript","digit","toSigFigs","toFixed","trimTrailing","str","char","formatNumber","sciSigFigs","valueAbs","isInteger","toString","numStr","numRounded","trimmed","timeUnitEnumToMilliseconds","timeToMilliseconds","timeUnitMultiplier","padConditionally","shouldPad","padStart","formatTimestamp","timeMs","useMs","useSec","useMin","useHours","useDays","digits","units","days","hours","minutes","seconds","secondString","milliseconds","timestamp","getTimestamp","total","totalMs","totalTimestamp","constrainToAxis","target","X","Y","Z","serializeError","WorkerEventType","WorkerMsgType","WorkerResponseResult","rebuildLoadSpec","subscribableQueue","initialized","copyOnLoad","messageHandlers","INIT","maxCacheSize","CREATE_LOADER","CREATE_VOLUME","LOAD_DIMS","LOAD_VOLUME_DATA","loaderId","loadId","responseResult","EVENT","eventType","METADATA_UPDATE","self","CHANNEL_LOAD","SET_PREFETCH_PRIORITY_DIRECTIONS","SYNCHRONIZE_MULTICHANNEL_LOADING","UPDATE_FETCH_OPTIONS","msgId","payload","SUCCESS","ERROR","copy"],"sourceRoot":""}